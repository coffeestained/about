<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>
<script src="https://unpkg.com/d3-delaunay@4"></script>
<script src="https://unpkg.com/d3-geo-voronoi@1"></script>
<style>
    .d3-container {
        width: 100%;
        display: block;
        overflow-x: auto;
        height: 600px;
        position: relative;
    }
    .d3-container > div.d3-toolbar {
        position: absolute;
        margin: .5em;
        padding: 5px;
        top: .5em;
        right: 0px;
        background: rgba(255,255,255,.6);
        z-index: 999;
        border-radius: 5px;
        font-size: 10px;
    }
    .d3-container > div.d3-toolbar > div {
        text-align: left;
    }
    .d3-container > svg {
        position: absolute;
        top: 0px;
        left: 0px;
        height: 100%;
        width: 100%;
    }
</style>
<div class="d3-container">
    <div class="d3-toolbar">
        <div><input type="radio" name="d3Type" onchange="generateData('flights', null);" /> <i class="fa-solid fa-plane"></i> Flight Volume (Animated soon)</div>
        <div><input type="radio" name="d3Type" checked="checked" onchange="generateData('aStrangeFunction', null);" /> <i class="fa-solid fa-search"></i> A Strange Visualized Class (Coming soon)</div>
        <div id="interactive-options">

            <div>
                <input type="checkbox" id="default-dendogram" name="default-dendogram" />
                <i class="fa-solid fa-scale-unbalanced"></i> Default
            </div>
            <div>
                <input type="checkbox" id="tree-dendogram" name="tree-default" />
                <i class="fa-solid fa-scale-unbalanced"></i> Tree
            </div>

        </div>

    </div>
    <svg height="600" width="1280">
        <!-- must be in this order for drawing -->
        <g id="basemap"></g>
        <g id="flights"></g>
        <g id="airports"></g>
        <g id="voronoi"></g>
        <text id="tooltipD3" style="display: none;"></text>
    </svg>
</div>

<!-- Generate data -->
<script>
    generateData('aStrangeFunction', null);
    function generateData(type, opts) {
        // Select D3 Chart
        let svg  = d3.select("svg");

        // Clear D3 Chart
        d3.selectAll("svg > g").remove();

        if (type == 'flights') {

            svg.append("g").attr("id", "basemap");
            svg.append("g").attr("id", "flights");
            svg.append("g").attr("id", "airports");
            svg.append("g").attr("id", "voronoi");

            const urls = {
                // source: https://observablehq.com/@mbostock/u-s-airports-voronoi
                // source: https://github.com/topojson/us-atlas
                map: "assets/states-albers-10m.json",

                // source: https://gist.github.com/mbostock/7608400
                airports:
                "https://gist.githubusercontent.com/mbostock/7608400/raw/e5974d9bba45bc9ab272d98dd7427567aafd55bc/airports.csv",

                // source: https://gist.github.com/mbostock/7608400
                flights:
                "https://gist.githubusercontent.com/mbostock/7608400/raw/e5974d9bba45bc9ab272d98dd7427567aafd55bc/flights.csv"
            };

            let width  = parseInt(svg.attr("width"));
            let height = parseInt(svg.attr("height"));
            const hypotenuse = Math.sqrt(width * width + height * height);

            // must be hard-coded to match our topojson projection
            // source: https://github.com/topojson/us-atlas
            const projection = d3.geoAlbers().scale(1280).translate([480, 300]);

            const scales = {
                // used to scale airport bubbles
                airports: d3.scaleSqrt()
                .range([4, 18]),

                // used to scale number of segments per line
                segments: d3.scaleLinear()
                .domain([0, hypotenuse])
                .range([1, 10])
            };

            // have these already created for easier drawing
            let g = {
                basemap:  svg.select("g#basemap"),
                flights:  svg.select("g#flights"),
                airports: svg.select("g#airports"),
                voronoi:  svg.select("g#voronoi")
            };

            console.assert(g.basemap.size()  === 1);
            console.assert(g.flights.size()  === 1);
            console.assert(g.airports.size() === 1);
            console.assert(g.voronoi.size()  === 1);

            const tooltipD3 = d3.select("text#tooltipD3");
            console.assert(tooltipD3.size() === 1);

            // load and draw base map
            d3.json(urls.map).then(drawMap);

            // load the airport and flight data together
            const promises = [
                d3.csv(urls.airports, typeAirport),
                d3.csv(urls.flights,  typeFlight)
            ];

            Promise.all(promises).then(processData);

            // process airport and flight data
            function processData(values) {
                console.assert(values.length === 2);

                let airports = values[0];
                let flights  = values[1];

                console.log("airports: " + airports.length);
                console.log(" flights: " + flights.length);

                // convert airports array (pre filter) into map for fast lookup
                let iata = new Map(airports.map(node => [node.iata, node]));

                // calculate incoming and outgoing degree based on flights
                // flights are given by airport iata code (not index)
                flights.forEach(function(link) {
                link.source = iata.get(link.origin);
                link.target = iata.get(link.destination);

                link.source.outgoing += link.count;
                link.target.incoming += link.count;
                });

                // remove airports out of bounds
                let old = airports.length;
                airports = airports.filter(airport => airport.x >= 0 && airport.y >= 0);
                console.log(" removed: " + (old - airports.length) + " airports out of bounds");

                // remove airports with NA state
                old = airports.length;
                airports = airports.filter(airport => airport.state !== "NA");
                console.log(" removed: " + (old - airports.length) + " airports with NA state");

                // remove airports without any flights
                old = airports.length;
                airports = airports.filter(airport => airport.outgoing > 0 && airport.incoming > 0);
                console.log(" removed: " + (old - airports.length) + " airports without flights");

                // sort airports by outgoing degree
                airports.sort((a, b) => d3.descending(a.outgoing, b.outgoing));

                // keep only the top airports
                old = airports.length;
                airports = airports.slice(0, 50);
                console.log(" removed: " + (old - airports.length) + " airports with low outgoing degree");

                // done filtering airports can draw
                drawAirports(airports);
                drawPolygons(airports);

                // reset map to only include airports post-filter
                iata = new Map(airports.map(node => [node.iata, node]));

                // filter out flights that are not between airports we have leftover
                old = flights.length;
                flights = flights.filter(link => iata.has(link.source.iata) && iata.has(link.target.iata));
                console.log(" removed: " + (old - flights.length) + " flights");

                // done filtering flights can draw
                drawFlights(airports, flights);

                console.log({airports: airports});
                console.log({flights: flights});
            }

            // draws the underlying map
            function drawMap(map) {
                // remove non-continental states
                map.objects.states.geometries = map.objects.states.geometries.filter(isContinental);

                // run topojson on remaining states and adjust projection
                let land = topojson.merge(map, map.objects.states.geometries);

                // use null projection; data is already projected
                let path = d3.geoPath();

                // draw base map
                g.basemap.append("path")
                .datum(land)
                .attr("class", "land")
                .attr("d", path);

                // draw interior borders
                g.basemap.append("path")
                .datum(topojson.mesh(map, map.objects.states, (a, b) => a !== b))
                .attr("class", "border interior")
                .attr("d", path);

                // draw exterior borders
                g.basemap.append("path")
                .datum(topojson.mesh(map, map.objects.states, (a, b) => a === b))
                .attr("class", "border exterior")
                .attr("d", path);
            }

            function drawAirports(airports) {
                // adjust scale
                const extent = d3.extent(airports, d => d.outgoing);
                scales.airports.domain(extent);

                // draw airport bubbles
                g.airports.selectAll("circle.airport")
                .data(airports, d => d.iata)
                .enter()
                .append("circle")
                .attr("r",  d => scales.airports(d.outgoing))
                .attr("cx", d => d.x) // calculated on load
                .attr("cy", d => d.y) // calculated on load
                .attr("class", "airport")
                .each(function(d) {
                    // adds the circle object to our airport
                    // makes it fast to select airports on hover
                    d.bubble = this;
                });
            }

            function drawPolygons(airports) {
                // convert array of airports into geojson format
                const geojson = airports.map(function(airport) {
                return {
                    type: "Feature",
                    properties: airport,
                    geometry: {
                    type: "Point",
                    coordinates: [airport.longitude, airport.latitude]
                    }
                };
                });

                // calculate voronoi polygons
                const polygons = d3.geoVoronoi().polygons(geojson);
                console.log(polygons);

                g.voronoi.selectAll("path")
                .data(polygons.features)
                .enter()
                .append("path")
                .attr("d", d3.geoPath(projection))
                .attr("class", "voronoi")
                .on("mouseover", function(d) {
                    let airport = d.properties.site.properties;

                    d3.select(airport.bubble)
                    .classed("highlight", true);

                    d3.selectAll(airport.flights)
                    .classed("highlight", true)
                    .raise();

                    // make tooltip take up space but keep it invisible
                    tooltipD3.style("display", null);
                    tooltipD3.style("visibility", "hidden");

                    // set default tooltip positioning
                    tooltipD3.attr("text-anchor", "middle");
                    tooltipD3.attr("dy", -scales.airports(airport.outgoing) - 4);
                    tooltipD3.attr("x", airport.x);
                    tooltipD3.attr("y", airport.y);

                    // set the tooltip text
                    tooltipD3.text(airport.name + " in " + airport.city + ", " + airport.state);

                    // double check if the anchor needs to be changed
                    let bbox = tooltipD3.node().getBBox();

                    if (bbox.x <= 0) {
                    tooltipD3.attr("text-anchor", "start");
                    }
                    else if (bbox.x + bbox.width >= width) {
                    tooltipD3.attr("text-anchor", "end");
                    }

                    tooltipD3.style("visibility", "visible");
                })
                .on("mouseout", function(d) {
                    let airport = d.properties.site.properties;

                    d3.select(airport.bubble)
                    .classed("highlight", false);

                    d3.selectAll(airport.flights)
                    .classed("highlight", false);

                    d3.select("text#tooltipD3").style("visibility", "hidden");
                })
                .on("dblclick", function(d) {
                    // toggle voronoi outline
                    let toggle = d3.select(this).classed("highlight");
                    d3.select(this).classed("highlight", !toggle);
                });
            }

            function drawFlights(airports, flights) {
                // break each flight between airports into multiple segments
                let bundle = generateSegments(airports, flights);

                // https://github.com/d3/d3-shape#curveBundle
                let line = d3.line()
                .curve(d3.curveBundle)
                .x(airport => airport.x)
                .y(airport => airport.y);

                let links = g.flights.selectAll("path.flight")
                .data(bundle.paths)
                .enter()
                .append("path")
                .attr("d", line)
                .attr("class", "flight")
                .each(function(d) {
                    // adds the path object to our source airport
                    // makes it fast to select outgoing paths
                    d[0].flights.push(this);
                });

                // https://github.com/d3/d3-force
                let layout = d3.forceSimulation()
                // settle at a layout faster
                .alphaDecay(0.1)
                // nearby nodes attract each other
                .force("charge", d3.forceManyBody()
                    .strength(10)
                    .distanceMax(scales.airports.range()[1] * 2)
                )
                // edges want to be as short as possible
                // prevents too much stretching
                .force("link", d3.forceLink()
                    .strength(0.7)
                    .distance(0)
                )
                .on("tick", function(d) {
                    links.attr("d", line);
                })
                .on("end", function(d) {
                    console.log("layout complete");
                });

                layout.nodes(bundle.nodes).force("link").links(bundle.links);
            }

            // Turns a single edge into several segments that can
            // be used for simple edge bundling.
            function generateSegments(nodes, links) {
                // generate separate graph for edge bundling
                // nodes: all nodes including control nodes
                // links: all individual segments (source to target)
                // paths: all segments combined into single path for drawing
                let bundle = {nodes: [], links: [], paths: []};

                // make existing nodes fixed
                bundle.nodes = nodes.map(function(d, i) {
                d.fx = d.x;
                d.fy = d.y;
                return d;
                });

                links.forEach(function(d, i) {
                // calculate the distance between the source and target
                let length = distance(d.source, d.target);

                // calculate total number of inner nodes for this link
                let total = Math.round(scales.segments(length));

                // create scales from source to target
                let xscale = d3.scaleLinear()
                    .domain([0, total + 1]) // source, inner nodes, target
                    .range([d.source.x, d.target.x]);

                let yscale = d3.scaleLinear()
                    .domain([0, total + 1])
                    .range([d.source.y, d.target.y]);

                // initialize source node
                let source = d.source;
                let target = null;

                // add all points to local path
                let local = [source];

                for (let j = 1; j <= total; j++) {
                    // calculate target node
                    target = {
                    x: xscale(j),
                    y: yscale(j)
                    };

                    local.push(target);
                    bundle.nodes.push(target);

                    bundle.links.push({
                    source: source,
                    target: target
                    });

                    source = target;
                }

                local.push(d.target);

                // add last link to target node
                bundle.links.push({
                    source: target,
                    target: d.target
                });

                bundle.paths.push(local);
                });

                return bundle;
            }

            // determines which states belong to the continental united states
            // https://gist.github.com/mbostock/4090846#file-us-state-names-tsv
            function isContinental(state) {
                const id = parseInt(state.id);
                return id < 60 && id !== 2 && id !== 15;
            }

            // see airports.csv
            // convert gps coordinates to number and init degree
            function typeAirport(airport) {
                airport.longitude = parseFloat(airport.longitude);
                airport.latitude  = parseFloat(airport.latitude);

                // use projection hard-coded to match topojson data
                const coords = projection([airport.longitude, airport.latitude]);
                airport.x = coords[0];
                airport.y = coords[1];

                airport.outgoing = 0;  // eventually tracks number of outgoing flights
                airport.incoming = 0;  // eventually tracks number of incoming flights

                airport.flights = [];  // eventually tracks outgoing flights

                return airport;
            }

            // see flights.csv
            // convert count to number
            function typeFlight(flight) {
                flight.count = parseInt(flight.count);
                return flight;
            }

            // calculates the distance between two nodes
            // sqrt( (x2 - x1)^2 + (y2 - y1)^2 )
            function distance(source, target) {
                const dx2 = Math.pow(target.x - source.x, 2);
                const dy2 = Math.pow(target.y - source.y, 2);

                return Math.sqrt(dx2 + dy2);
            }
        }
        if (type == 'aStrangeFunction') {

            width = +svg.attr("width"),
            height = +svg.attr("height"),
            g = svg.append("g").attr("transform", "translate(40,0)");

            var tree = d3.tree()
                .size([height - 400, width - 160]);

            var cluster = d3.cluster()
                .size([height, width - 160]);

            var stratify = d3.stratify()
                .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(".")); });

            let data = [
            {
                "id": "flare",
                "value": ""
            },
            {
                "id": "flare.analytics",
                "value": ""
            },
            {
                "id": "flare.analytics.cluster",
                "value": ""
            },
            {
                "id": "flare.analytics.cluster.AgglomerativeCluster",
                "value": 3938
            },
            {
                "id": "flare.analytics.cluster.CommunityStructure",
                "value": 3812
            },
            {
                "id": "flare.analytics.cluster.HierarchicalCluster",
                "value": 6714
            },
            {
                "id": "flare.analytics.cluster.MergeEdge",
                "value": 743
            },
            {
                "id": "flare.analytics.graph",
                "value": ""
            },
            {
                "id": "flare.analytics.graph.BetweennessCentrality",
                "value": 3534
            },
            {
                "id": "flare.analytics.graph.LinkDistance",
                "value": 5731
            },
            {
                "id": "flare.analytics.graph.MaxFlowMinCut",
                "value": 7840
            },
            {
                "id": "flare.analytics.graph.ShortestPaths",
                "value": 5914
            },
            {
                "id": "flare.analytics.graph.SpanningTree",
                "value": 3416
            },
            {
                "id": "flare.analytics.optimization",
                "value": ""
            },
            {
                "id": "flare.analytics.optimization.AspectRatioBanker",
                "value": 7074
            },
            {
                "id": "flare.animate",
                "value": ""
            },
            {
                "id": "flare.animate.Easing",
                "value": 17010
            },
            {
                "id": "flare.animate.FunctionSequence",
                "value": 5842
            },
            {
                "id": "flare.animate.interpolate",
                "value": ""
            },
            {
                "id": "flare.animate.interpolate.ArrayInterpolator",
                "value": 1983
            },
            {
                "id": "flare.animate.interpolate.ColorInterpolator",
                "value": 2047
            },
            {
                "id": "flare.animate.interpolate.DateInterpolator",
                "value": 1375
            },
            {
                "id": "flare.animate.interpolate.Interpolator",
                "value": 8746
            },
            {
                "id": "flare.animate.interpolate.MatrixInterpolator",
                "value": 2202
            },
            {
                "id": "flare.animate.interpolate.NumberInterpolator",
                "value": 1382
            },
            {
                "id": "flare.animate.interpolate.ObjectInterpolator",
                "value": 1629
            },
            {
                "id": "flare.animate.interpolate.PointInterpolator",
                "value": 1675
            },
            {
                "id": "flare.animate.interpolate.RectangleInterpolator",
                "value": 2042
            },
            {
                "id": "flare.animate.ISchedulable",
                "value": 1041
            },
            {
                "id": "flare.animate.Parallel",
                "value": 5176
            },
            {
                "id": "flare.animate.Pause",
                "value": 449
            },
            {
                "id": "flare.animate.Scheduler",
                "value": 5593
            },
            {
                "id": "flare.animate.Sequence",
                "value": 5534
            },
            {
                "id": "flare.animate.Transition",
                "value": 9201
            },
            {
                "id": "flare.animate.Transitioner",
                "value": 19975
            },
            {
                "id": "flare.animate.TransitionEvent",
                "value": 1116
            },
            {
                "id": "flare.animate.Tween",
                "value": 6006
            },
            {
                "id": "flare.data",
                "value": ""
            },
            {
                "id": "flare.data.converters",
                "value": ""
            },
            {
                "id": "flare.data.converters.Converters",
                "value": 721
            },
            {
                "id": "flare.data.converters.DelimitedTextConverter",
                "value": 4294
            },
            {
                "id": "flare.data.converters.GraphMLConverter",
                "value": 9800
            },
            {
                "id": "flare.data.converters.IDataConverter",
                "value": 1314
            },
            {
                "id": "flare.data.converters.JSONConverter",
                "value": 2220
            },
            {
                "id": "flare.data.DataField",
                "value": 1759
            },
            {
                "id": "flare.data.DataSchema",
                "value": 2165
            },
            {
                "id": "flare.data.DataSet",
                "value": 586
            },
            {
                "id": "flare.data.DataSource",
                "value": 3331
            },
            {
                "id": "flare.data.DataTable",
                "value": 772
            },
            {
                "id": "flare.data.DataUtil",
                "value": 3322
            },
            {
                "id": "flare.display",
                "value": ""
            },
            {
                "id": "flare.display.DirtySprite",
                "value": 8833
            },
            {
                "id": "flare.display.LineSprite",
                "value": 1732
            },
            {
                "id": "flare.display.RectSprite",
                "value": 3623
            },
            {
                "id": "flare.display.TextSprite",
                "value": 10066
            },
            {
                "id": "flare.flex",
                "value": ""
            },
            {
                "id": "flare.flex.FlareVis",
                "value": 4116
            },
            {
                "id": "flare.physics",
                "value": ""
            },
            {
                "id": "flare.physics.DragForce",
                "value": 1082
            },
            {
                "id": "flare.physics.GravityForce",
                "value": 1336
            },
            {
                "id": "flare.physics.IForce",
                "value": 319
            },
            {
                "id": "flare.physics.NBodyForce",
                "value": 10498
            },
            {
                "id": "flare.physics.Particle",
                "value": 2822
            },
            {
                "id": "flare.physics.Simulation",
                "value": 9983
            },
            {
                "id": "flare.physics.Spring",
                "value": 2213
            },
            {
                "id": "flare.physics.SpringForce",
                "value": 1681
            },
            {
                "id": "flare.query",
                "value": ""
            },
            {
                "id": "flare.query.AggregateExpression",
                "value": 1616
            },
            {
                "id": "flare.query.And",
                "value": 1027
            },
            {
                "id": "flare.query.Arithmetic",
                "value": 3891
            },
            {
                "id": "flare.query.Average",
                "value": 891
            },
            {
                "id": "flare.query.BinaryExpression",
                "value": 2893
            },
            {
                "id": "flare.query.Comparison",
                "value": 5103
            },
            {
                "id": "flare.query.CompositeExpression",
                "value": 3677
            },
            {
                "id": "flare.query.Count",
                "value": 781
            },
            {
                "id": "flare.query.DateUtil",
                "value": 4141
            },
            {
                "id": "flare.query.Distinct",
                "value": 933
            },
            {
                "id": "flare.query.Expression",
                "value": 5130
            },
            {
                "id": "flare.query.ExpressionIterator",
                "value": 3617
            },
            {
                "id": "flare.query.Fn",
                "value": 3240
            },
            {
                "id": "flare.query.If",
                "value": 2732
            },
            {
                "id": "flare.query.IsA",
                "value": 2039
            },
            {
                "id": "flare.query.Literal",
                "value": 1214
            },
            {
                "id": "flare.query.Match",
                "value": 3748
            },
            {
                "id": "flare.query.Maximum",
                "value": 843
            },
            {
                "id": "flare.query.methods",
                "value": ""
            },
            {
                "id": "flare.query.methods.add",
                "value": 593
            },
            {
                "id": "flare.query.methods.and",
                "value": 330
            },
            {
                "id": "flare.query.methods.average",
                "value": 287
            },
            {
                "id": "flare.query.methods.count",
                "value": 277
            },
            {
                "id": "flare.query.methods.distinct",
                "value": 292
            },
            {
                "id": "flare.query.methods.div",
                "value": 595
            },
            {
                "id": "flare.query.methods.eq",
                "value": 594
            },
            {
                "id": "flare.query.methods.fn",
                "value": 460
            },
            {
                "id": "flare.query.methods.gt",
                "value": 603
            },
            {
                "id": "flare.query.methods.gte",
                "value": 625
            },
            {
                "id": "flare.query.methods.iff",
                "value": 748
            },
            {
                "id": "flare.query.methods.isa",
                "value": 461
            },
            {
                "id": "flare.query.methods.lt",
                "value": 597
            },
            {
                "id": "flare.query.methods.lte",
                "value": 619
            },
            {
                "id": "flare.query.methods.max",
                "value": 283
            },
            {
                "id": "flare.query.methods.min",
                "value": 283
            },
            {
                "id": "flare.query.methods.mod",
                "value": 591
            },
            {
                "id": "flare.query.methods.mul",
                "value": 603
            },
            {
                "id": "flare.query.methods.neq",
                "value": 599
            },
            {
                "id": "flare.query.methods.not",
                "value": 386
            },
            {
                "id": "flare.query.methods.or",
                "value": 323
            },
            {
                "id": "flare.query.methods.orderby",
                "value": 307
            },
            {
                "id": "flare.query.methods.range",
                "value": 772
            },
            {
                "id": "flare.query.methods.select",
                "value": 296
            },
            {
                "id": "flare.query.methods.stddev",
                "value": 363
            },
            {
                "id": "flare.query.methods.sub",
                "value": 600
            },
            {
                "id": "flare.query.methods.sum",
                "value": 280
            },
            {
                "id": "flare.query.methods.update",
                "value": 307
            },
            {
                "id": "flare.query.methods.variance",
                "value": 335
            },
            {
                "id": "flare.query.methods.where",
                "value": 299
            },
            {
                "id": "flare.query.methods.xor",
                "value": 354
            },
            {
                "id": "flare.query.methods._",
                "value": 264
            },
            {
                "id": "flare.query.Minimum",
                "value": 843
            },
            {
                "id": "flare.query.Not",
                "value": 1554
            },
            {
                "id": "flare.query.Or",
                "value": 970
            },
            {
                "id": "flare.query.Query",
                "value": 13896
            },
            {
                "id": "flare.query.Range",
                "value": 1594
            },
            {
                "id": "flare.query.StringUtil",
                "value": 4130
            },
            {
                "id": "flare.query.Sum",
                "value": 791
            },
            {
                "id": "flare.query.Variable",
                "value": 1124
            },
            {
                "id": "flare.query.Variance",
                "value": 1876
            },
            {
                "id": "flare.query.Xor",
                "value": 1101
            },
            {
                "id": "flare.scale",
                "value": ""
            },
            {
                "id": "flare.scale.IScaleMap",
                "value": 2105
            },
            {
                "id": "flare.scale.LinearScale",
                "value": 1316
            },
            {
                "id": "flare.scale.LogScale",
                "value": 3151
            },
            {
                "id": "flare.scale.OrdinalScale",
                "value": 3770
            },
            {
                "id": "flare.scale.QuantileScale",
                "value": 2435
            },
            {
                "id": "flare.scale.QuantitativeScale",
                "value": 4839
            },
            {
                "id": "flare.scale.RootScale",
                "value": 1756
            },
            {
                "id": "flare.scale.Scale",
                "value": 4268
            },
            {
                "id": "flare.scale.ScaleType",
                "value": 1821
            },
            {
                "id": "flare.scale.TimeScale",
                "value": 5833
            },
            {
                "id": "flare.util",
                "value": ""
            },
            {
                "id": "flare.util.Arrays",
                "value": 8258
            },
            {
                "id": "flare.util.Colors",
                "value": 10001
            },
            {
                "id": "flare.util.Dates",
                "value": 8217
            },
            {
                "id": "flare.util.Displays",
                "value": 12555
            },
            {
                "id": "flare.util.Filter",
                "value": 2324
            },
            {
                "id": "flare.util.Geometry",
                "value": 10993
            },
            {
                "id": "flare.util.heap",
                "value": ""
            },
            {
                "id": "flare.util.heap.FibonacciHeap",
                "value": 9354
            },
            {
                "id": "flare.util.heap.HeapNode",
                "value": 1233
            },
            {
                "id": "flare.util.IEvaluable",
                "value": 335
            },
            {
                "id": "flare.util.IPredicate",
                "value": 383
            },
            {
                "id": "flare.util.IValueProxy",
                "value": 874
            },
            {
                "id": "flare.util.math",
                "value": ""
            },
            {
                "id": "flare.util.math.DenseMatrix",
                "value": 3165
            },
            {
                "id": "flare.util.math.IMatrix",
                "value": 2815
            },
            {
                "id": "flare.util.math.SparseMatrix",
                "value": 3366
            },
            {
                "id": "flare.util.Maths",
                "value": 17705
            },
            {
                "id": "flare.util.Orientation",
                "value": 1486
            },
            {
                "id": "flare.util.palette",
                "value": ""
            },
            {
                "id": "flare.util.palette.ColorPalette",
                "value": 6367
            },
            {
                "id": "flare.util.palette.Palette",
                "value": 1229
            },
            {
                "id": "flare.util.palette.ShapePalette",
                "value": 2059
            },
            {
                "id": "flare.util.palette.SizePalette",
                "value": 2291
            },
            {
                "id": "flare.util.Property",
                "value": 5559
            },
            {
                "id": "flare.util.Shapes",
                "value": 19118
            },
            {
                "id": "flare.util.Sort",
                "value": 6887
            },
            {
                "id": "flare.util.Stats",
                "value": 6557
            },
            {
                "id": "flare.util.Strings",
                "value": 22026
            },
            {
                "id": "flare.vis",
                "value": ""
            },
            {
                "id": "flare.vis.axis",
                "value": ""
            },
            {
                "id": "flare.vis.axis.Axes",
                "value": 1302
            },
            {
                "id": "flare.vis.axis.Axis",
                "value": 24593
            },
            {
                "id": "flare.vis.axis.AxisGridLine",
                "value": 652
            },
            {
                "id": "flare.vis.axis.AxisLabel",
                "value": 636
            },
            {
                "id": "flare.vis.axis.CartesianAxes",
                "value": 6703
            },
            {
                "id": "flare.vis.controls",
                "value": ""
            },
            {
                "id": "flare.vis.controls.AnchorControl",
                "value": 2138
            },
            {
                "id": "flare.vis.controls.ClickControl",
                "value": 3824
            },
            {
                "id": "flare.vis.controls.Control",
                "value": 1353
            },
            {
                "id": "flare.vis.controls.ControlList",
                "value": 4665
            },
            {
                "id": "flare.vis.controls.DragControl",
                "value": 2649
            },
            {
                "id": "flare.vis.controls.ExpandControl",
                "value": 2832
            },
            {
                "id": "flare.vis.controls.HoverControl",
                "value": 4896
            },
            {
                "id": "flare.vis.controls.IControl",
                "value": 763
            },
            {
                "id": "flare.vis.controls.PanZoomControl",
                "value": 5222
            },
            {
                "id": "flare.vis.controls.SelectionControl",
                "value": 7862
            },
            {
                "id": "flare.vis.controls.TooltipControl",
                "value": 8435
            },
            {
                "id": "flare.vis.data",
                "value": ""
            },
            {
                "id": "flare.vis.data.Data",
                "value": 20544
            },
            {
                "id": "flare.vis.data.DataList",
                "value": 19788
            },
            {
                "id": "flare.vis.data.DataSprite",
                "value": 10349
            },
            {
                "id": "flare.vis.data.EdgeSprite",
                "value": 3301
            },
            {
                "id": "flare.vis.data.NodeSprite",
                "value": 19382
            },
            {
                "id": "flare.vis.data.render",
                "value": ""
            },
            {
                "id": "flare.vis.data.render.ArrowType",
                "value": 698
            },
            {
                "id": "flare.vis.data.render.EdgeRenderer",
                "value": 5569
            },
            {
                "id": "flare.vis.data.render.IRenderer",
                "value": 353
            },
            {
                "id": "flare.vis.data.render.ShapeRenderer",
                "value": 2247
            },
            {
                "id": "flare.vis.data.ScaleBinding",
                "value": 11275
            },
            {
                "id": "flare.vis.data.Tree",
                "value": 7147
            },
            {
                "id": "flare.vis.data.TreeBuilder",
                "value": 9930
            },
            {
                "id": "flare.vis.events",
                "value": ""
            },
            {
                "id": "flare.vis.events.DataEvent",
                "value": 2313
            },
            {
                "id": "flare.vis.events.SelectionEvent",
                "value": 1880
            },
            {
                "id": "flare.vis.events.TooltipEvent",
                "value": 1701
            },
            {
                "id": "flare.vis.events.VisualizationEvent",
                "value": 1117
            },
            {
                "id": "flare.vis.legend",
                "value": ""
            },
            {
                "id": "flare.vis.legend.Legend",
                "value": 20859
            },
            {
                "id": "flare.vis.legend.LegendItem",
                "value": 4614
            },
            {
                "id": "flare.vis.legend.LegendRange",
                "value": 10530
            },
            {
                "id": "flare.vis.operator",
                "value": ""
            },
            {
                "id": "flare.vis.operator.distortion",
                "value": ""
            },
            {
                "id": "flare.vis.operator.distortion.BifocalDistortion",
                "value": 4461
            },
            {
                "id": "flare.vis.operator.distortion.Distortion",
                "value": 6314
            },
            {
                "id": "flare.vis.operator.distortion.FisheyeDistortion",
                "value": 3444
            },
            {
                "id": "flare.vis.operator.encoder",
                "value": ""
            },
            {
                "id": "flare.vis.operator.encoder.ColorEncoder",
                "value": 3179
            },
            {
                "id": "flare.vis.operator.encoder.Encoder",
                "value": 4060
            },
            {
                "id": "flare.vis.operator.encoder.PropertyEncoder",
                "value": 4138
            },
            {
                "id": "flare.vis.operator.encoder.ShapeEncoder",
                "value": 1690
            },
            {
                "id": "flare.vis.operator.encoder.SizeEncoder",
                "value": 1830
            },
            {
                "id": "flare.vis.operator.filter",
                "value": ""
            },
            {
                "id": "flare.vis.operator.filter.FisheyeTreeFilter",
                "value": 5219
            },
            {
                "id": "flare.vis.operator.filter.GraphDistanceFilter",
                "value": 3165
            },
            {
                "id": "flare.vis.operator.filter.VisibilityFilter",
                "value": 3509
            },
            {
                "id": "flare.vis.operator.IOperator",
                "value": 1286
            },
            {
                "id": "flare.vis.operator.label",
                "value": ""
            },
            {
                "id": "flare.vis.operator.label.Labeler",
                "value": 9956
            },
            {
                "id": "flare.vis.operator.label.RadialLabeler",
                "value": 3899
            },
            {
                "id": "flare.vis.operator.label.StackedAreaLabeler",
                "value": 3202
            },
            {
                "id": "flare.vis.operator.layout",
                "value": ""
            },
            {
                "id": "flare.vis.operator.layout.AxisLayout",
                "value": 6725
            },
            {
                "id": "flare.vis.operator.layout.BundledEdgeRouter",
                "value": 3727
            },
            {
                "id": "flare.vis.operator.layout.CircleLayout",
                "value": 9317
            },
            {
                "id": "flare.vis.operator.layout.CirclePackingLayout",
                "value": 12003
            },
            {
                "id": "flare.vis.operator.layout.DendrogramLayout",
                "value": 4853
            },
            {
                "id": "flare.vis.operator.layout.ForceDirectedLayout",
                "value": 8411
            },
            {
                "id": "flare.vis.operator.layout.IcicleTreeLayout",
                "value": 4864
            },
            {
                "id": "flare.vis.operator.layout.IndentedTreeLayout",
                "value": 3174
            },
            {
                "id": "flare.vis.operator.layout.Layout",
                "value": 7881
            },
            {
                "id": "flare.vis.operator.layout.NodeLinkTreeLayout",
                "value": 12870
            },
            {
                "id": "flare.vis.operator.layout.PieLayout",
                "value": 2728
            },
            {
                "id": "flare.vis.operator.layout.RadialTreeLayout",
                "value": 12348
            },
            {
                "id": "flare.vis.operator.layout.RandomLayout",
                "value": 870
            },
            {
                "id": "flare.vis.operator.layout.StackedAreaLayout",
                "value": 9121
            },
            {
                "id": "flare.vis.operator.layout.TreeMapLayout",
                "value": 9191
            },
            {
                "id": "flare.vis.operator.Operator",
                "value": 2490
            },
            {
                "id": "flare.vis.operator.OperatorList",
                "value": 5248
            },
            {
                "id": "flare.vis.operator.OperatorSequence",
                "value": 4190
            },
            {
                "id": "flare.vis.operator.OperatorSwitch",
                "value": 2581
            },
            {
                "id": "flare.vis.operator.SortOperator",
                "value": 2023
            },
            {
                "id": "flare.vis.Visualization",
                "value": 16540
            }
            ];

            var root = stratify(data)
                .sort(function(a, b) { return (a.height - b.height) || a.id.localeCompare(b.id); });

            cluster(root);

            var link = g.selectAll(".link")
                .data(root.descendants().slice(1))
            .enter().append("path")
                .attr("class", "link")
                .attr("d", diagonal);

            var node = g.selectAll(".node")
                .data(root.descendants())
            .enter().append("g")
                .attr("class", function(d) { return "node" + (d.children ? " node--internal" : " node--leaf"); })
                .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

            node.append("circle")
                .attr("r", 2.5);

            node.append("text")
                .attr("dy", 3)
                .attr("x", function(d) { return d.children ? -8 : 8; })
                .style("text-anchor", function(d) { return d.children ? "end" : "start"; })
                .text(function(d) { return d.id.substring(d.id.lastIndexOf(".") + 1); });

            d3.selectAll("input")
                .on("change", changed);

            var timeout = setTimeout(function() {
            d3.select("input[value=\"tree\"]")
                .property("checked", true)
                .dispatch("change");
            }, 1000);

            function changed() {
            timeout = clearTimeout(timeout);
            (this.value === "tree" ? tree : cluster)(root);
            var t = d3.transition().duration(750);
            node.transition(t).attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });
            link.transition(t).attr("d", diagonal);
            }


            function diagonal(d) {
            return "M" + d.y + "," + d.x
                + "C" + (d.parent.y + 100) + "," + d.x
                + " " + (d.parent.y + 100) + "," + d.parent.x
                + " " + d.parent.y + "," + d.parent.x;
            }

        }
    }
</script>

<!-- Flight D3 Styles -->
<style>
    .land {
      fill: #dddddd;
    }

    .border {
      fill: none;
      stroke-width: 1px;
    }

    .interior {
      stroke: white;
    }

    .exterior {
      stroke: #bbbbbb;
    }

    .airport {
      fill: white;
      opacity: 0.6;
      stroke: #252525;
    }

    .flight {
      fill: none;
      stroke: #252525;
      stroke-width: 1px;
      stroke-opacity: 0.1;
    }

    .voronoi {
      fill: none;
      stroke: none;
      stroke-width: 1px;
    }

    .highlight {
      opacity: 1 !important;
      stroke: red !important;
      stroke-width: 2px !important;
      stroke-opacity: 0.8 !important;
    }

    g#voronoi {
      pointer-events: all;
    }

    /* shadow trick from bl.ocks.org */
    #tooltipD3 {
      font-size: 10pt;
      font-weight: 900;
      fill: white;
      text-shadow: 1px 1px 0 #252525, 1px -1px 0 #252525, -1px 1px 0 #252525, -1px -1px 0 #252525;
    }
</style>
<!-- Dendogram Styles -->
<style>
    .node circle {
      fill: #999;
    }

    .node text {
      font: 10px sans-serif;
    }

    .node--internal circle {
      fill: #555;
    }

    .node--internal text {
      text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
    }

    .link {
      fill: none;
      stroke: #555;
      stroke-opacity: 0.4;
      stroke-width: 1.5px;
    }

    form {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      position: absolute;
      left: 10px;
      top: 10px;
    }

    label {
      display: block;
    }
</style>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>
<script src="https://unpkg.com/d3-delaunay@4"></script>
<script src="https://unpkg.com/d3-geo-voronoi@1"></script>
<style>
    .d3-container {
        width: 100%;
        display: block;
        overflow-x: auto;
        height: 600px;
        position: relative;
    }
    .d3-container > div.d3-toolbar {
        position: absolute;
        margin: .5em;
        padding: 5px;
        top: .5em;
        right: 0px;
        background: rgba(255,255,255,.6);
        z-index: 999;
        border-radius: 5px;
        font-size: 10px;
    }
    .d3-container > div.d3-toolbar > div {
        text-align: left;
    }
    .d3-container > svg {
        position: absolute;
        top: 0px;
        left: 0px;
        height: 100%;
        width: 100%;
    }
</style>
<div class="d3-container">
    <div class="d3-toolbar">
        <div><input type="radio" name="d3Type" onchange="generateData('flights', null);" /> <i class="fa-solid fa-plane"></i> Flight Volume (Animated soon)</div>
        <div><input type="radio" name="d3Type" checked="checked" onchange="generateData('aStrangeFunction', null);" /> <i class="fa-solid fa-search"></i> A Strange Visualized Class (Coming soon)</div>
        <div id="interactive-d3-options">

            <div>
                <input type="checkbox" id="default-dendogram" name="default-dendogram" />
                <i class="fa-solid fa-scale-unbalanced"></i> Default
            </div>
            <div>
                <input type="checkbox" id="tree-dendogram" name="tree-default" />
                <i class="fa-solid fa-scale-unbalanced"></i> Tree
            </div>

        </div>

    </div>
    <svg height="600" width="1280">
        <!-- must be in this order for drawing -->
        <g id="basemap"></g>
        <g id="flights"></g>
        <g id="airports"></g>
        <g id="voronoi"></g>
        <text id="tooltipD3" style="display: none;"></text>
    </svg>
</div>

<!-- Generate data -->
<script>
    generateData('aStrangeFunction', null);
    function generateData(type, opts) {
        // Select D3 Chart
        let svg  = d3.select("svg");

        // Clear D3 Chart
        d3.selectAll("svg > g").remove();

        // Reset Extra Options
        document.getElementById('interactive-d3-options').classList.remove('interactive-options-active');

        if (type == 'flights') {

            svg.append("g").attr("id", "basemap");
            svg.append("g").attr("id", "flights");
            svg.append("g").attr("id", "airports");
            svg.append("g").attr("id", "voronoi");

            const urls = {
                // source: https://observablehq.com/@mbostock/u-s-airports-voronoi
                // source: https://github.com/topojson/us-atlas
                map: "assets/states-albers-10m.json",

                // source: https://gist.github.com/mbostock/7608400
                airports:
                "https://gist.githubusercontent.com/mbostock/7608400/raw/e5974d9bba45bc9ab272d98dd7427567aafd55bc/airports.csv",

                // source: https://gist.github.com/mbostock/7608400
                flights:
                "https://gist.githubusercontent.com/mbostock/7608400/raw/e5974d9bba45bc9ab272d98dd7427567aafd55bc/flights.csv"
            };

            let width  = parseInt(svg.attr("width"));
            let height = parseInt(svg.attr("height"));
            const hypotenuse = Math.sqrt(width * width + height * height);

            // must be hard-coded to match our topojson projection
            // source: https://github.com/topojson/us-atlas
            const projection = d3.geoAlbers().scale(1280).translate([480, 300]);

            const scales = {
                // used to scale airport bubbles
                airports: d3.scaleSqrt()
                .range([4, 18]),

                // used to scale number of segments per line
                segments: d3.scaleLinear()
                .domain([0, hypotenuse])
                .range([1, 10])
            };

            // have these already created for easier drawing
            let g = {
                basemap:  svg.select("g#basemap"),
                flights:  svg.select("g#flights"),
                airports: svg.select("g#airports"),
                voronoi:  svg.select("g#voronoi")
            };

            console.assert(g.basemap.size()  === 1);
            console.assert(g.flights.size()  === 1);
            console.assert(g.airports.size() === 1);
            console.assert(g.voronoi.size()  === 1);

            const tooltipD3 = d3.select("text#tooltipD3");
            console.assert(tooltipD3.size() === 1);

            // load and draw base map
            d3.json(urls.map).then(drawMap);

            // load the airport and flight data together
            const promises = [
                d3.csv(urls.airports, typeAirport),
                d3.csv(urls.flights,  typeFlight)
            ];

            Promise.all(promises).then(processData);

            // process airport and flight data
            function processData(values) {
                console.assert(values.length === 2);

                let airports = values[0];
                let flights  = values[1];

                console.log("airports: " + airports.length);
                console.log(" flights: " + flights.length);

                // convert airports array (pre filter) into map for fast lookup
                let iata = new Map(airports.map(node => [node.iata, node]));

                // calculate incoming and outgoing degree based on flights
                // flights are given by airport iata code (not index)
                flights.forEach(function(link) {
                link.source = iata.get(link.origin);
                link.target = iata.get(link.destination);

                link.source.outgoing += link.count;
                link.target.incoming += link.count;
                });

                // remove airports out of bounds
                let old = airports.length;
                airports = airports.filter(airport => airport.x >= 0 && airport.y >= 0);
                console.log(" removed: " + (old - airports.length) + " airports out of bounds");

                // remove airports with NA state
                old = airports.length;
                airports = airports.filter(airport => airport.state !== "NA");
                console.log(" removed: " + (old - airports.length) + " airports with NA state");

                // remove airports without any flights
                old = airports.length;
                airports = airports.filter(airport => airport.outgoing > 0 && airport.incoming > 0);
                console.log(" removed: " + (old - airports.length) + " airports without flights");

                // sort airports by outgoing degree
                airports.sort((a, b) => d3.descending(a.outgoing, b.outgoing));

                // keep only the top airports
                old = airports.length;
                airports = airports.slice(0, 50);
                console.log(" removed: " + (old - airports.length) + " airports with low outgoing degree");

                // done filtering airports can draw
                drawAirports(airports);
                drawPolygons(airports);

                // reset map to only include airports post-filter
                iata = new Map(airports.map(node => [node.iata, node]));

                // filter out flights that are not between airports we have leftover
                old = flights.length;
                flights = flights.filter(link => iata.has(link.source.iata) && iata.has(link.target.iata));
                console.log(" removed: " + (old - flights.length) + " flights");

                // done filtering flights can draw
                drawFlights(airports, flights);

                console.log({airports: airports});
                console.log({flights: flights});
            }

            // draws the underlying map
            function drawMap(map) {
                // remove non-continental states
                map.objects.states.geometries = map.objects.states.geometries.filter(isContinental);

                // run topojson on remaining states and adjust projection
                let land = topojson.merge(map, map.objects.states.geometries);

                // use null projection; data is already projected
                let path = d3.geoPath();

                // draw base map
                g.basemap.append("path")
                .datum(land)
                .attr("class", "land")
                .attr("d", path);

                // draw interior borders
                g.basemap.append("path")
                .datum(topojson.mesh(map, map.objects.states, (a, b) => a !== b))
                .attr("class", "border interior")
                .attr("d", path);

                // draw exterior borders
                g.basemap.append("path")
                .datum(topojson.mesh(map, map.objects.states, (a, b) => a === b))
                .attr("class", "border exterior")
                .attr("d", path);
            }

            function drawAirports(airports) {
                // adjust scale
                const extent = d3.extent(airports, d => d.outgoing);
                scales.airports.domain(extent);

                // draw airport bubbles
                g.airports.selectAll("circle.airport")
                .data(airports, d => d.iata)
                .enter()
                .append("circle")
                .attr("r",  d => scales.airports(d.outgoing))
                .attr("cx", d => d.x) // calculated on load
                .attr("cy", d => d.y) // calculated on load
                .attr("class", "airport")
                .each(function(d) {
                    // adds the circle object to our airport
                    // makes it fast to select airports on hover
                    d.bubble = this;
                });
            }

            function drawPolygons(airports) {
                // convert array of airports into geojson format
                const geojson = airports.map(function(airport) {
                return {
                    type: "Feature",
                    properties: airport,
                    geometry: {
                    type: "Point",
                    coordinates: [airport.longitude, airport.latitude]
                    }
                };
                });

                // calculate voronoi polygons
                const polygons = d3.geoVoronoi().polygons(geojson);
                console.log(polygons);

                g.voronoi.selectAll("path")
                .data(polygons.features)
                .enter()
                .append("path")
                .attr("d", d3.geoPath(projection))
                .attr("class", "voronoi")
                .on("mouseover", function(d) {
                    let airport = d.properties.site.properties;

                    d3.select(airport.bubble)
                    .classed("highlight", true);

                    d3.selectAll(airport.flights)
                    .classed("highlight", true)
                    .raise();

                    // make tooltip take up space but keep it invisible
                    tooltipD3.style("display", null);
                    tooltipD3.style("visibility", "hidden");

                    // set default tooltip positioning
                    tooltipD3.attr("text-anchor", "middle");
                    tooltipD3.attr("dy", -scales.airports(airport.outgoing) - 4);
                    tooltipD3.attr("x", airport.x);
                    tooltipD3.attr("y", airport.y);

                    // set the tooltip text
                    tooltipD3.text(airport.name + " in " + airport.city + ", " + airport.state);

                    // double check if the anchor needs to be changed
                    let bbox = tooltipD3.node().getBBox();

                    if (bbox.x <= 0) {
                    tooltipD3.attr("text-anchor", "start");
                    }
                    else if (bbox.x + bbox.width >= width) {
                    tooltipD3.attr("text-anchor", "end");
                    }

                    tooltipD3.style("visibility", "visible");
                })
                .on("mouseout", function(d) {
                    let airport = d.properties.site.properties;

                    d3.select(airport.bubble)
                    .classed("highlight", false);

                    d3.selectAll(airport.flights)
                    .classed("highlight", false);

                    d3.select("text#tooltipD3").style("visibility", "hidden");
                })
                .on("dblclick", function(d) {
                    // toggle voronoi outline
                    let toggle = d3.select(this).classed("highlight");
                    d3.select(this).classed("highlight", !toggle);
                });
            }

            function drawFlights(airports, flights) {
                // break each flight between airports into multiple segments
                let bundle = generateSegments(airports, flights);

                // https://github.com/d3/d3-shape#curveBundle
                let line = d3.line()
                .curve(d3.curveBundle)
                .x(airport => airport.x)
                .y(airport => airport.y);

                let links = g.flights.selectAll("path.flight")
                .data(bundle.paths)
                .enter()
                .append("path")
                .attr("d", line)
                .attr("class", "flight")
                .each(function(d) {
                    // adds the path object to our source airport
                    // makes it fast to select outgoing paths
                    d[0].flights.push(this);
                });

                // https://github.com/d3/d3-force
                let layout = d3.forceSimulation()
                // settle at a layout faster
                .alphaDecay(0.1)
                // nearby nodes attract each other
                .force("charge", d3.forceManyBody()
                    .strength(10)
                    .distanceMax(scales.airports.range()[1] * 2)
                )
                // edges want to be as short as possible
                // prevents too much stretching
                .force("link", d3.forceLink()
                    .strength(0.7)
                    .distance(0)
                )
                .on("tick", function(d) {
                    links.attr("d", line);
                })
                .on("end", function(d) {
                    console.log("layout complete");
                });

                layout.nodes(bundle.nodes).force("link").links(bundle.links);
            }

            // Turns a single edge into several segments that can
            // be used for simple edge bundling.
            function generateSegments(nodes, links) {
                // generate separate graph for edge bundling
                // nodes: all nodes including control nodes
                // links: all individual segments (source to target)
                // paths: all segments combined into single path for drawing
                let bundle = {nodes: [], links: [], paths: []};

                // make existing nodes fixed
                bundle.nodes = nodes.map(function(d, i) {
                d.fx = d.x;
                d.fy = d.y;
                return d;
                });

                links.forEach(function(d, i) {
                // calculate the distance between the source and target
                let length = distance(d.source, d.target);

                // calculate total number of inner nodes for this link
                let total = Math.round(scales.segments(length));

                // create scales from source to target
                let xscale = d3.scaleLinear()
                    .domain([0, total + 1]) // source, inner nodes, target
                    .range([d.source.x, d.target.x]);

                let yscale = d3.scaleLinear()
                    .domain([0, total + 1])
                    .range([d.source.y, d.target.y]);

                // initialize source node
                let source = d.source;
                let target = null;

                // add all points to local path
                let local = [source];

                for (let j = 1; j <= total; j++) {
                    // calculate target node
                    target = {
                    x: xscale(j),
                    y: yscale(j)
                    };

                    local.push(target);
                    bundle.nodes.push(target);

                    bundle.links.push({
                    source: source,
                    target: target
                    });

                    source = target;
                }

                local.push(d.target);

                // add last link to target node
                bundle.links.push({
                    source: target,
                    target: d.target
                });

                bundle.paths.push(local);
                });

                return bundle;
            }

            // determines which states belong to the continental united states
            // https://gist.github.com/mbostock/4090846#file-us-state-names-tsv
            function isContinental(state) {
                const id = parseInt(state.id);
                return id < 60 && id !== 2 && id !== 15;
            }

            // see airports.csv
            // convert gps coordinates to number and init degree
            function typeAirport(airport) {
                airport.longitude = parseFloat(airport.longitude);
                airport.latitude  = parseFloat(airport.latitude);

                // use projection hard-coded to match topojson data
                const coords = projection([airport.longitude, airport.latitude]);
                airport.x = coords[0];
                airport.y = coords[1];

                airport.outgoing = 0;  // eventually tracks number of outgoing flights
                airport.incoming = 0;  // eventually tracks number of incoming flights

                airport.flights = [];  // eventually tracks outgoing flights

                return airport;
            }

            // see flights.csv
            // convert count to number
            function typeFlight(flight) {
                flight.count = parseInt(flight.count);
                return flight;
            }

            // calculates the distance between two nodes
            // sqrt( (x2 - x1)^2 + (y2 - y1)^2 )
            function distance(source, target) {
                const dx2 = Math.pow(target.x - source.x, 2);
                const dy2 = Math.pow(target.y - source.y, 2);

                return Math.sqrt(dx2 + dy2);
            }
        }
        if (type == 'aStrangeFunction') {

            document.getElementById('interactive-d3-options').classList.add('interactive-options-active');

            width = +svg.attr("width"),
            height = +svg.attr("height"),
            g = svg.append("g").attr("transform", "translate(40,0)");

            var tree = d3.tree()
                .size([height - 400, width - 160]);

            var cluster = d3.cluster()
                .size([height, width - 160]);

            var stratify = d3.stratify()
                .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(".")); });

            let data = [
            {
                "id": "flare",
                "value": ""
            },
            {
                "id": "flare.analytics",
                "value": ""
            },
            {
                "id": "flare.analytics.cluster",
                "value": ""
            },
            {
                "id": "flare.analytics.cluster.AgglomerativeCluster",
                "value": 3938
            },
            {
                "id": "flare.analytics.cluster.CommunityStructure",
                "value": 3812
            },
            {
                "id": "flare.analytics.cluster.HierarchicalCluster",
                "value": 6714
            },
            {
                "id": "flare.analytics.cluster.MergeEdge",
                "value": 743
            },
            {
                "id": "flare.analytics.graph",
                "value": ""
            },
            {
                "id": "flare.analytics.graph.BetweennessCentrality",
                "value": 3534
            },
            {
                "id": "flare.analytics.graph.LinkDistance",
                "value": 5731
            },
            {
                "id": "flare.analytics.graph.MaxFlowMinCut",
                "value": 7840
            },
            {
                "id": "flare.analytics.graph.ShortestPaths",
                "value": 5914
            },
            {
                "id": "flare.analytics.graph.SpanningTree",
                "value": 3416
            },
            {
                "id": "flare.analytics.optimization",
                "value": ""
            },
            {
                "id": "flare.analytics.optimization.AspectRatioBanker",
                "value": 7074
            },
            {
                "id": "flare.animate",
                "value": ""
            },
            {
                "id": "flare.animate.Easing",
                "value": 17010
            },
            {
                "id": "flare.animate.FunctionSequence",
                "value": 5842
            },
            {
                "id": "flare.animate.interpolate",
                "value": ""
            },
            {
                "id": "flare.animate.interpolate.ArrayInterpolator",
                "value": 1983
            },
            {
                "id": "flare.animate.interpolate.ColorInterpolator",
                "value": 2047
            },
            {
                "id": "flare.animate.interpolate.DateInterpolator",
                "value": 1375
            },
            {
                "id": "flare.animate.interpolate.Interpolator",
                "value": 8746
            },
            {
                "id": "flare.animate.interpolate.MatrixInterpolator",
                "value": 2202
            },
            {
                "id": "flare.animate.interpolate.NumberInterpolator",
                "value": 1382
            },
            {
                "id": "flare.animate.interpolate.ObjectInterpolator",
                "value": 1629
            },
            {
                "id": "flare.animate.interpolate.PointInterpolator",
                "value": 1675
            },
            {
                "id": "flare.animate.interpolate.RectangleInterpolator",
                "value": 2042
            },
            {
                "id": "flare.animate.ISchedulable",
                "value": 1041
            },
            {
                "id": "flare.animate.Parallel",
                "value": 5176
            },
            {
                "id": "flare.animate.Pause",
                "value": 449
            },
            {
                "id": "flare.animate.Scheduler",
                "value": 5593
            },
            {
                "id": "flare.animate.Sequence",
                "value": 5534
            },
            {
                "id": "flare.animate.Transition",
                "value": 9201
            },
            {
                "id": "flare.animate.Transitioner",
                "value": 19975
            },
            {
                "id": "flare.animate.TransitionEvent",
                "value": 1116
            },
            {
                "id": "flare.animate.Tween",
                "value": 6006
            },
            {
                "id": "flare.data",
                "value": ""
            },
            {
                "id": "flare.data.converters",
                "value": ""
            },
            {
                "id": "flare.data.converters.Converters",
                "value": 721
            },
            {
                "id": "flare.data.converters.DelimitedTextConverter",
                "value": 4294
            },
            {
                "id": "flare.data.converters.GraphMLConverter",
                "value": 9800
            },
            {
                "id": "flare.data.converters.IDataConverter",
                "value": 1314
            },
            {
                "id": "flare.data.converters.JSONConverter",
                "value": 2220
            },
            {
                "id": "flare.data.DataField",
                "value": 1759
            },
            {
                "id": "flare.data.DataSchema",
                "value": 2165
            },
            {
                "id": "flare.data.DataSet",
                "value": 586
            },
            {
                "id": "flare.data.DataSource",
                "value": 3331
            },
            {
                "id": "flare.data.DataTable",
                "value": 772
            },
            {
                "id": "flare.data.DataUtil",
                "value": 3322
            },
            {
                "id": "flare.display",
                "value": ""
            },
            {
                "id": "flare.display.DirtySprite",
                "value": 8833
            },
            {
                "id": "flare.display.LineSprite",
                "value": 1732
            },
            {
                "id": "flare.display.RectSprite",
                "value": 3623
            },
            {
                "id": "flare.display.TextSprite",
                "value": 10066
            },
            {
                "id": "flare.flex",
                "value": ""
            },
            {
                "id": "flare.flex.FlareVis",
                "value": 4116
            },
            {
                "id": "flare.physics",
                "value": ""
            },
            {
                "id": "flare.physics.DragForce",
                "value": 1082
            },
            {
                "id": "flare.physics.GravityForce",
                "value": 1336
            },
            {
                "id": "flare.physics.IForce",
                "value": 319
            },
            {
                "id": "flare.physics.NBodyForce",
                "value": 10498
            },
            {
                "id": "flare.physics.Particle",
                "value": 2822
            },
            {
                "id": "flare.physics.Simulation",
                "value": 9983
            },
            {
                "id": "flare.physics.Spring",
                "value": 2213
            },
            {
                "id": "flare.physics.SpringForce",
                "value": 1681
            },
            {
                "id": "flare.query",
                "value": ""
            },
            {
                "id": "flare.query.AggregateExpression",
                "value": 1616
            },
            {
                "id": "flare.query.And",
                "value": 1027
            },
            {
                "id": "flare.query.Arithmetic",
                "value": 3891
            },
            {
                "id": "flare.query.Average",
                "value": 891
            },
            {
                "id": "flare.query.BinaryExpression",
                "value": 2893
            },
            {
                "id": "flare.query.Comparison",
                "value": 5103
            },
            {
                "id": "flare.query.CompositeExpression",
                "value": 3677
            },
            {
                "id": "flare.query.Count",
                "value": 781
            },
            {
                "id": "flare.query.DateUtil",
                "value": 4141
            },
            {
                "id": "flare.query.Distinct",
                "value": 933
            },
            {
                "id": "flare.query.Expression",
                "value": 5130
            },
            {
                "id": "flare.query.ExpressionIterator",
                "value": 3617
            },
            {
                "id": "flare.query.Fn",
                "value": 3240
            },
            {
                "id": "flare.query.If",
                "value": 2732
            },
            {
                "id": "flare.query.IsA",
                "value": 2039
            },
            {
                "id": "flare.query.Literal",
                "value": 1214
            },
            {
                "id": "flare.query.Match",
                "value": 3748
            },
            {
                "id": "flare.query.Maximum",
                "value": 843
            },
            {
                "id": "flare.query.methods",
                "value": ""
            },
            {
                "id": "flare.query.methods.add",
                "value": 593
            },
            {
                "id": "flare.query.methods.and",
                "value": 330
            },
            {
                "id": "flare.query.methods.average",
                "value": 287
            },
            {
                "id": "flare.query.methods.count",
                "value": 277
            },
            {
                "id": "flare.query.methods.distinct",
                "value": 292
            },
            {
                "id": "flare.query.methods.div",
                "value": 595
            },
            {
                "id": "flare.query.methods.eq",
                "value": 594
            },
            {
                "id": "flare.query.methods.fn",
                "value": 460
            },
            {
                "id": "flare.query.methods.gt",
                "value": 603
            },
            {
                "id": "flare.query.methods.gte",
                "value": 625
            },
            {
                "id": "flare.query.methods.iff",
                "value": 748
            },
            {
                "id": "flare.query.methods.isa",
                "value": 461
            },
            {
                "id": "flare.query.methods.lt",
                "value": 597
            },
            {
                "id": "flare.query.methods.lte",
                "value": 619
            },
            {
                "id": "flare.query.methods.max",
                "value": 283
            },
            {
                "id": "flare.query.methods.min",
                "value": 283
            },
            {
                "id": "flare.query.methods.mod",
                "value": 591
            },
            {
                "id": "flare.query.methods.mul",
                "value": 603
            },
            {
                "id": "flare.query.methods.neq",
                "value": 599
            },
            {
                "id": "flare.query.methods.not",
                "value": 386
            },
            {
                "id": "flare.query.methods.or",
                "value": 323
            },
            {
                "id": "flare.query.methods.orderby",
                "value": 307
            },
            {
                "id": "flare.query.methods.range",
                "value": 772
            },
            {
                "id": "flare.query.methods.select",
                "value": 296
            },
            {
                "id": "flare.query.methods.stddev",
                "value": 363
            },
            {
                "id": "flare.query.methods.sub",
                "value": 600
            },
            {
                "id": "flare.query.methods.sum",
                "value": 280
            },
            {
                "id": "flare.query.methods.update",
                "value": 307
            },
            {
                "id": "flare.query.methods.variance",
                "value": 335
            },
            {
                "id": "flare.query.methods.where",
                "value": 299
            },
            {
                "id": "flare.query.methods.xor",
                "value": 354
            },
            {
                "id": "flare.query.methods._",
                "value": 264
            },
            {
                "id": "flare.query.Minimum",
                "value": 843
            },
            {
                "id": "flare.query.Not",
                "value": 1554
            },
            {
                "id": "flare.query.Or",
                "value": 970
            },
            {
                "id": "flare.query.Query",
                "value": 13896
            },
            {
                "id": "flare.query.Range",
                "value": 1594
            },
            {
                "id": "flare.query.StringUtil",
                "value": 4130
            },
            {
                "id": "flare.query.Sum",
                "value": 791
            },
            {
                "id": "flare.query.Variable",
                "value": 1124
            },
            {
                "id": "flare.query.Variance",
                "value": 1876
            },
            {
                "id": "flare.query.Xor",
                "value": 1101
            },
            {
                "id": "flare.scale",
                "value": ""
            },
            {
                "id": "flare.scale.IScaleMap",
                "value": 2105
            },
            {
                "id": "flare.scale.LinearScale",
                "value": 1316
            },
            {
                "id": "flare.scale.LogScale",
                "value": 3151
            },
            {
                "id": "flare.scale.OrdinalScale",
                "value": 3770
            },
            {
                "id": "flare.scale.QuantileScale",
                "value": 2435
            },
            {
                "id": "flare.scale.QuantitativeScale",
                "value": 4839
            },
            {
                "id": "flare.scale.RootScale",
                "value": 1756
            },
            {
                "id": "flare.scale.Scale",
                "value": 4268
            },
            {
                "id": "flare.scale.ScaleType",
                "value": 1821
            },
            {
                "id": "flare.scale.TimeScale",
                "value": 5833
            },
            {
                "id": "flare.util",
                "value": ""
            },
            {
                "id": "flare.util.Arrays",
                "value": 8258
            },
            {
                "id": "flare.util.Colors",
                "value": 10001
            },
            {
                "id": "flare.util.Dates",
                "value": 8217
            },
            {
                "id": "flare.util.Displays",
                "value": 12555
            },
            {
                "id": "flare.util.Filter",
                "value": 2324
            },
            {
                "id": "flare.util.Geometry",
                "value": 10993
            },
            {
                "id": "flare.util.heap",
                "value": ""
            },
            {
                "id": "flare.util.heap.FibonacciHeap",
                "value": 9354
            },
            {
                "id": "flare.util.heap.HeapNode",
                "value": 1233
            },
            {
                "id": "flare.util.IEvaluable",
                "value": 335
            },
            {
                "id": "flare.util.IPredicate",
                "value": 383
            },
            {
                "id": "flare.util.IValueProxy",
                "value": 874
            },
            {
                "id": "flare.util.math",
                "value": ""
            },
            {
                "id": "flare.util.math.DenseMatrix",
                "value": 3165
            },
            {
                "id": "flare.util.math.IMatrix",
                "value": 2815
            },
            {
                "id": "flare.util.math.SparseMatrix",
                "value": 3366
            },
            {
                "id": "flare.util.Maths",
                "value": 17705
            },
            {
                "id": "flare.util.Orientation",
                "value": 1486
            },
            {
                "id": "flare.util.palette",
                "value": ""
            },
            {
                "id": "flare.util.palette.ColorPalette",
                "value": 6367
            },
            {
                "id": "flare.util.palette.Palette",
                "value": 1229
            },
            {
                "id": "flare.util.palette.ShapePalette",
                "value": 2059
            },
            {
                "id": "flare.util.palette.SizePalette",
                "value": 2291
            },
            {
                "id": "flare.util.Property",
                "value": 5559
            },
            {
                "id": "flare.util.Shapes",
                "value": 19118
            },
            {
                "id": "flare.util.Sort",
                "value": 6887
            },
            {
                "id": "flare.util.Stats",
                "value": 6557
            },
            {
                "id": "flare.util.Strings",
                "value": 22026
            },
            {
                "id": "flare.vis",
                "value": ""
            },
            {
                "id": "flare.vis.axis",
                "value": ""
            },
            {
                "id": "flare.vis.axis.Axes",
                "value": 1302
            },
            {
                "id": "flare.vis.axis.Axis",
                "value": 24593
            },
            {
                "id": "flare.vis.axis.AxisGridLine",
                "value": 652
            },
            {
                "id": "flare.vis.axis.AxisLabel",
                "value": 636
            },
            {
                "id": "flare.vis.axis.CartesianAxes",
                "value": 6703
            },
            {
                "id": "flare.vis.controls",
                "value": ""
            },
            {
                "id": "flare.vis.controls.AnchorControl",
                "value": 2138
            },
            {
                "id": "flare.vis.controls.ClickControl",
                "value": 3824
            },
            {
                "id": "flare.vis.controls.Control",
                "value": 1353
            },
            {
                "id": "flare.vis.controls.ControlList",
                "value": 4665
            },
            {
                "id": "flare.vis.controls.DragControl",
                "value": 2649
            },
            {
                "id": "flare.vis.controls.ExpandControl",
                "value": 2832
            },
            {
                "id": "flare.vis.controls.HoverControl",
                "value": 4896
            },
            {
                "id": "flare.vis.controls.IControl",
                "value": 763
            },
            {
                "id": "flare.vis.controls.PanZoomControl",
                "value": 5222
            },
            {
                "id": "flare.vis.controls.SelectionControl",
                "value": 7862
            },
            {
                "id": "flare.vis.controls.TooltipControl",
                "value": 8435
            },
            {
                "id": "flare.vis.data",
                "value": ""
            },
            {
                "id": "flare.vis.data.Data",
                "value": 20544
            },
            {
                "id": "flare.vis.data.DataList",
                "value": 19788
            },
            {
                "id": "flare.vis.data.DataSprite",
                "value": 10349
            },
            {
                "id": "flare.vis.data.EdgeSprite",
                "value": 3301
            },
            {
                "id": "flare.vis.data.NodeSprite",
                "value": 19382
            },
            {
                "id": "flare.vis.data.render",
                "value": ""
            },
            {
                "id": "flare.vis.data.render.ArrowType",
                "value": 698
            },
            {
                "id": "flare.vis.data.render.EdgeRenderer",
                "value": 5569
            },
            {
                "id": "flare.vis.data.render.IRenderer",
                "value": 353
            },
            {
                "id": "flare.vis.data.render.ShapeRenderer",
                "value": 2247
            },
            {
                "id": "flare.vis.data.ScaleBinding",
                "value": 11275
            },
            {
                "id": "flare.vis.data.Tree",
                "value": 7147
            },
            {
                "id": "flare.vis.data.TreeBuilder",
                "value": 9930
            },
            {
                "id": "flare.vis.events",
                "value": ""
            },
            {
                "id": "flare.vis.events.DataEvent",
                "value": 2313
            },
            {
                "id": "flare.vis.events.SelectionEvent",
                "value": 1880
            },
            {
                "id": "flare.vis.events.TooltipEvent",
                "value": 1701
            },
            {
                "id": "flare.vis.events.VisualizationEvent",
                "value": 1117
            },
            {
                "id": "flare.vis.legend",
                "value": ""
            },
            {
                "id": "flare.vis.legend.Legend",
                "value": 20859
            },
            {
                "id": "flare.vis.legend.LegendItem",
                "value": 4614
            },
            {
                "id": "flare.vis.legend.LegendRange",
                "value": 10530
            },
            {
                "id": "flare.vis.operator",
                "value": ""
            },
            {
                "id": "flare.vis.operator.distortion",
                "value": ""
            },
            {
                "id": "flare.vis.operator.distortion.BifocalDistortion",
                "value": 4461
            },
            {
                "id": "flare.vis.operator.distortion.Distortion",
                "value": 6314
            },
            {
                "id": "flare.vis.operator.distortion.FisheyeDistortion",
                "value": 3444
            },
            {
                "id": "flare.vis.operator.encoder",
                "value": ""
            },
            {
                "id": "flare.vis.operator.encoder.ColorEncoder",
                "value": 3179
            },
            {
                "id": "flare.vis.operator.encoder.Encoder",
                "value": 4060
            },
            {
                "id": "flare.vis.operator.encoder.PropertyEncoder",
                "value": 4138
            },
            {
                "id": "flare.vis.operator.encoder.ShapeEncoder",
                "value": 1690
            },
            {
                "id": "flare.vis.operator.encoder.SizeEncoder",
                "value": 1830
            },
            {
                "id": "flare.vis.operator.filter",
                "value": ""
            },
            {
                "id": "flare.vis.operator.filter.FisheyeTreeFilter",
                "value": 5219
            },
            {
                "id": "flare.vis.operator.filter.GraphDistanceFilter",
                "value": 3165
            },
            {
                "id": "flare.vis.operator.filter.VisibilityFilter",
                "value": 3509
            },
            {
                "id": "flare.vis.operator.IOperator",
                "value": 1286
            },
            {
                "id": "flare.vis.operator.label",
                "value": ""
            },
            {
                "id": "flare.vis.operator.label.Labeler",
                "value": 9956
            },
            {
                "id": "flare.vis.operator.label.RadialLabeler",
                "value": 3899
            },
            {
                "id": "flare.vis.operator.label.StackedAreaLabeler",
                "value": 3202
            },
            {
                "id": "flare.vis.operator.layout",
                "value": ""
            },
            {
                "id": "flare.vis.operator.layout.AxisLayout",
                "value": 6725
            },
            {
                "id": "flare.vis.operator.layout.BundledEdgeRouter",
                "value": 3727
            },
            {
                "id": "flare.vis.operator.layout.CircleLayout",
                "value": 9317
            },
            {
                "id": "flare.vis.operator.layout.CirclePackingLayout",
                "value": 12003
            },
            {
                "id": "flare.vis.operator.layout.DendrogramLayout",
                "value": 4853
            },
            {
                "id": "flare.vis.operator.layout.ForceDirectedLayout",
                "value": 8411
            },
            {
                "id": "flare.vis.operator.layout.IcicleTreeLayout",
                "value": 4864
            },
            {
                "id": "flare.vis.operator.layout.IndentedTreeLayout",
                "value": 3174
            },
            {
                "id": "flare.vis.operator.layout.Layout",
                "value": 7881
            },
            {
                "id": "flare.vis.operator.layout.NodeLinkTreeLayout",
                "value": 12870
            },
            {
                "id": "flare.vis.operator.layout.PieLayout",
                "value": 2728
            },
            {
                "id": "flare.vis.operator.layout.RadialTreeLayout",
                "value": 12348
            },
            {
                "id": "flare.vis.operator.layout.RandomLayout",
                "value": 870
            },
            {
                "id": "flare.vis.operator.layout.StackedAreaLayout",
                "value": 9121
            },
            {
                "id": "flare.vis.operator.layout.TreeMapLayout",
                "value": 9191
            },
            {
                "id": "flare.vis.operator.Operator",
                "value": 2490
            },
            {
                "id": "flare.vis.operator.OperatorList",
                "value": 5248
            },
            {
                "id": "flare.vis.operator.OperatorSequence",
                "value": 4190
            },
            {
                "id": "flare.vis.operator.OperatorSwitch",
                "value": 2581
            },
            {
                "id": "flare.vis.operator.SortOperator",
                "value": 2023
            },
            {
                "id": "flare.vis.Visualization",
                "value": 16540
            }
            ];

            var root = stratify(data)
                .sort(function(a, b) { return (a.height - b.height) || a.id.localeCompare(b.id); });

            cluster(root);

            var link = g.selectAll(".link")
                .data(root.descendants().slice(1))
            .enter().append("path")
                .attr("class", "link")
                .attr("d", diagonal);

            var node = g.selectAll(".node")
                .data(root.descendants())
            .enter().append("g")
                .attr("class", function(d) { return "node" + (d.children ? " node--internal" : " node--leaf"); })
                .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

            node.append("circle")
                .attr("r", 2.5);

            node.append("text")
                .attr("dy", 3)
                .attr("x", function(d) { return d.children ? -8 : 8; })
                .style("text-anchor", function(d) { return d.children ? "end" : "start"; })
                .text(function(d) { return d.id.substring(d.id.lastIndexOf(".") + 1); });

            d3.selectAll("input")
                .on("change", changed);

            var timeout = setTimeout(function() {
            d3.select("input[value=\"tree\"]")
                .property("checked", true)
                .dispatch("change");
            }, 1000);

            function changed() {
            timeout = clearTimeout(timeout);
            (this.value === "tree" ? tree : cluster)(root);
            var t = d3.transition().duration(750);
            node.transition(t).attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });
            link.transition(t).attr("d", diagonal);
            }


            function diagonal(d) {
            return "M" + d.y + "," + d.x
                + "C" + (d.parent.y + 100) + "," + d.x
                + " " + (d.parent.y + 100) + "," + d.parent.x
                + " " + d.parent.y + "," + d.parent.x;
            }

        }
    }
</script>

<!-- Flight D3 Styles -->
<style>
    .land {
      fill: #dddddd;
    }

    .border {
      fill: none;
      stroke-width: 1px;
    }

    .interior {
      stroke: white;
    }

    .exterior {
      stroke: #bbbbbb;
    }

    .airport {
      fill: white;
      opacity: 0.6;
      stroke: #252525;
    }

    .flight {
      fill: none;
      stroke: #252525;
      stroke-width: 1px;
      stroke-opacity: 0.1;
    }

    .voronoi {
      fill: none;
      stroke: none;
      stroke-width: 1px;
    }

    .highlight {
      opacity: 1 !important;
      stroke: red !important;
      stroke-width: 2px !important;
      stroke-opacity: 0.8 !important;
    }

    g#voronoi {
      pointer-events: all;
    }

    /* shadow trick from bl.ocks.org */
    #tooltipD3 {
      font-size: 10pt;
      font-weight: 900;
      fill: white;
      text-shadow: 1px 1px 0 #252525, 1px -1px 0 #252525, -1px 1px 0 #252525, -1px -1px 0 #252525;
    }
</style>

<!-- Dendogram Styles -->
<style>
    .node circle {
      fill: #999;
    }

    .node text {
      font: 10px sans-serif;
    }

    .node--internal circle {
      fill: #555;
    }

    .node--internal text {
      text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
    }

    .link {
      fill: none;
      stroke: #555;
      stroke-opacity: 0.4;
      stroke-width: 1.5px;
    }

    form {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      position: absolute;
      left: 10px;
      top: 10px;
    }

    label {
      display: block;
    }

    .interactive-options-active {
        margin-left: 1.5em !important;
        height: auto !important;
        opacity: 1 !important;
    }

    #interactive-options {
        opacity: 0;
        height: 0px;
        margin-left: 0px;
        display: flex;
        flex-direction: column;
        transition: opacity 2s, height 1s, margin-left .5s;
    }
</style>

<!--
    A Strange Class
-->
<script>
    class StrangeClass {

        constructor(options = {}) {
            Object.assign(this, options);
            this.history = [];
        }

        static getHistory() {
            return this.lastname+' '+this.firstname
        }

    }

    function initStrangeties(json) {
        console.log("Hi: ", json);
        const Peculiarities = new StrangeClass({
            ip: json.ip
        });
        console.log(Peculiarities);
    }


</script>
<script type="application/javascript" src="https://api.ipify.org?format=jsonp&callback=initStrangeties"></script>
