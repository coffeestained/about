/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import e from"../core/Accessor.js";import{debounce as i}from"../core/promiseUtils.js";import{property as o}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./ensureType.js";import{subclass as r}from"../core/accessorSupport/decorators/subclass.js";import s from"../geometry/Extent.js";import{c as a}from"./aaBoundingRect.js";import{g as n}from"../geometry/SpatialReference.js";import p from"../layers/support/TileInfo.js";import{B as m}from"./Bitmap.js";import{T as h}from"./TileInfoView.js";import{T as d}from"./TileKey.js";const c=Math.PI/180,l=a(),u=[0,0],g=new d(0,0,0,0);let f=class extends e{constructor(t){super(t),this._imagePromise=null,this.bitmaps=[],this.hidpi=!1,this.imageMaxWidth=2048,this.imageMaxHeight=2048,this.imageRotationSupported=!1,this.imageNormalizationSupported=!1,this.update=i((async(t,e)=>{if(!t.stationary||this.destroyed)return null;const i=t.state,o=n(i.spatialReference),r=this.hidpi?t.pixelRatio:1,s=this.imageNormalizationSupported&&i.worldScreenWidth&&i.worldScreenWidth<i.size[0];s?(u[0]=i.worldScreenWidth,u[1]=i.size[1]):this.imageRotationSupported?(u[0]=i.size[0],u[1]=i.size[1]):function(t,e){const i=e.rotation*c,o=Math.abs(Math.cos(i)),r=Math.abs(Math.sin(i)),[s,a]=e.size;t[0]=Math.round(a*r+s*o),t[1]=Math.round(a*o+s*r)}(u,i);const a=Math.floor(u[0]*r)>this.imageMaxWidth||Math.floor(u[1]*r)>this.imageMaxHeight,p=o&&(i.extent.xmin<o.valid[0]||i.extent.xmax>o.valid[1]),m=!this.imageNormalizationSupported&&p,h=!a&&!m,d=this.imageRotationSupported?i.rotation:0;if(h){const t=s?i.paddedViewState.center:i.center;this._imagePromise=this._singleExport(i,u,t,i.resolution,d,r,e)}else{let t=Math.min(this.imageMaxWidth,this.imageMaxHeight);m&&(t=Math.min(i.worldScreenWidth,t)),this._imagePromise=this._tiledExport(i,t,r,e)}return this._imagePromise.then((async t=>{if(this._imagePromise=null,!this.destroyed){this.bitmaps=t??[];for(const e of this.container.children)t.includes(e)||e.fadeOut().then((()=>{e.remove()}));for(const e of t)this.container.addChild(e),e.fadeIn()}})).catch((t=>{throw this._imagePromise=null,t}))}),5e3)}destroy(){this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}updateExports(t){for(const e of this.container.children){if(!e.visible||!e.stage)return;t(e),e.invalidateTexture(),e.requestRender()}}async _export(t,e,i,o,r,s){const a=await this.fetchSource(t,Math.floor(e*r),Math.floor(i*r),{rotation:o,pixelRatio:r,signal:s}),n=new m(a,"additive");return n.x=t.xmin,n.y=t.ymax,n.resolution=t.width/e,n.rotation=o,n.pixelRatio=r,n}async _singleExport(t,e,i,o,r,a,n){!function(t,e,i,o){const[r,s]=e,[a,n]=o,p=.5*i;t[0]=r-p*a,t[1]=s-p*n,t[2]=r+p*a,t[3]=s+p*n}(l,i,o,e);const p=new s(l[0],l[1],l[2],l[3],t.spatialReference);return[await this._export(p,e[0],e[1],r,a,n)]}_tiledExport(t,e,i,o){const r=p.create({size:e,spatialReference:t.spatialReference,scales:[t.scale]}),a=new h(r),n=a.getTileCoverage(t);if(!n)return null;const m=[];return n.forEach(((r,n,p,h)=>{g.set(r,n,p,h),a.getTileBounds(l,g);const d=new s(l[0],l[1],l[2],l[3],t.spatialReference);m.push(this._export(d,e,e,0,i,o))})),Promise.all(m)}};t([o()],f.prototype,"_imagePromise",void 0),t([o()],f.prototype,"bitmaps",void 0),t([o()],f.prototype,"container",void 0),t([o()],f.prototype,"fetchSource",void 0),t([o()],f.prototype,"hidpi",void 0),t([o()],f.prototype,"imageMaxWidth",void 0),t([o()],f.prototype,"imageMaxHeight",void 0),t([o()],f.prototype,"imageRotationSupported",void 0),t([o()],f.prototype,"imageNormalizationSupported",void 0),t([o()],f.prototype,"requestUpdate",void 0),t([o()],f.prototype,"updating",null),f=t([r("esri.views.2d.layers.support.ExportStrategy")],f);const x=f;export{x as E};
