/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../core/Error.js";import{i as r,a as n}from"./maybe.js";import{open as t}from"../core/workers/workers.js";import a from"../layers/support/PixelBlock.js";import o from"../layers/support/DimensionalDefinition.js";class i{constructor(){this._workerThread=null,this._destroyed=!1}async initialize(){const e=await t("RasterWorker");this._destroyed?e.close():this._workerThread=e}destroy(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)}async convertVectorFieldData(r,n){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("convertVectorFieldData",{pixelBlock:r.pixelBlock.toJSON(),type:r.dataType},n);return t?new a(t):null}async decode(r,n){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("decode",r,n);return t?new a(t):null}async symbolize(n,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const o={extent:n.extent&&n.extent.toJSON(),pixelBlock:r(n.pixelBlock)&&n.pixelBlock.toJSON(),simpleStretchParams:n.simpleStretchParams,bandIds:n.bandIds},i=await this._workerThread.invoke("symbolize",o,t);return i?new a(i):null}async updateSymbolizer(r,n){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=r?.rendererJSON?.histograms;await Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:r.toJSON(),histograms:t},n))}async stretch(r,n){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const t={srcPixelBlock:r.pixelBlock.toJSON(),stretchParams:r.stretchParams},o=await this._workerThread.invoke("stretch",t,n);return o?new a(o):null}async split(r,n){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const t={srcPixelBlock:r.pixelBlock.toJSON(),tileSize:r.tileSize,maximumPyramidLevel:r.maximumPyramidLevel},o=await this._workerThread.invoke("split",t,n);return o&&o.forEach(((e,r)=>{o.set(r,e?a.fromJSON(e):null)})),o}async estimateStatisticsHistograms(r,n){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const t={srcPixelBlock:r.pixelBlock.toJSON()};return await this._workerThread.invoke("estimateStatisticsHistograms",t,n)}async mosaicAndTransform(n,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!n?.srcPixelBlocks?.length)return{pixelBlock:null};const o={...n,srcPixelBlocks:n.srcPixelBlocks.map((e=>r(e)?e.toJSON():null))},i=await this._workerThread.invoke("mosaicAndTransform",o,t);return{pixelBlock:i.pixelBlock?new a(i.pixelBlock):null,localNorthDirections:i.localNorthDirections}}async createFlowMesh(r,n){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t={buffer:r.flowData.data.buffer,maskBuffer:r.flowData.mask.buffer,width:r.flowData.width,height:r.flowData.height},{meshType:a,simulationSettings:o}=r,i=await this._workerThread.invoke("createFlowMesh",{meshType:a,flowData:t,simulationSettings:o},{...n,transferList:[t.buffer,t.maskBuffer]});return{vertexData:new Float32Array(i.vertexBuffer),indexData:new Uint32Array(i.indexBuffer)}}getProjectionOffsetGrid(n,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const a=r(n.datumTransformation)?n.datumTransformation.steps.map((e=>({wkid:e.wkid,wkt:e.wkt,isInverse:e.isInverse}))):null,o=r(n.rasterTransform)?n.rasterTransform.toJSON():null,i={projectedExtent:n.projectedExtent.toJSON(),srcBufferExtent:n.srcBufferExtent.toJSON(),pixelSize:n.pixelSize,hasWrapAround:n.hasWrapAround,spacing:n.spacing,datumTransformationSteps:a,rasterTransform:o,isAdaptive:n.isAdaptive,includeGCSGrid:n.includeGCSGrid};return this._workerThread.invoke("getProjectionOffsetGrid",i,t)}}function s(e,r,n){const t=r.shift();if(0===n.length){const e=[];n.push({sliceId:-1,multidimensionalDefinition:e})}const a=n.length;for(let r=0;r<a;r++){const r=n.shift().multidimensionalDefinition;t.values.forEach((a=>{n.push({sliceId:-1,multidimensionalDefinition:[...r,{variableName:e,dimensionName:t.name,values:[a]}]})}))}r.length&&s(e,r,n)}function l(e,r){const n=[];let t=0;return(r?e.variables.filter((e=>e.name.toLowerCase()===r.toLowerCase())):[...e.variables].sort(((e,r)=>e.name>r.name?1:-1))).forEach((e=>{const r=[],a=[...e.dimensions].sort(((e,r)=>e.name>r.name?-1:1));s(e.name,a,r),r.forEach((e=>{n.push({...e,sliceId:t++})}))})),n}function c(e,n,t){let a=e;if(n&&(n=[...n].sort(((e,r)=>e.dimensionName<r.dimensionName?-1:1))).forEach((({dimensionName:e,values:r,isSlice:n})=>{r.length&&(a=a.filter((t=>{const a=t.multidimensionalDefinition.find((r=>r.dimensionName===e));if(null==a)return!1;const o=a.values[0];return"number"==typeof o?"number"==typeof r[0]?r.includes(o):r.some((e=>e[0]<=o&&e[1]>=o)):"number"==typeof r[0]?r.some((e=>o[0]<=e&&o[1]>=e)):n?r.some((e=>e[0]===o[0]&&e[0]===o[1])):r.some((e=>e[0]>=o[0]&&e[0]<=o[1]||e[1]>=o[0]&&e[1]<=o[1]||e[0]<o[0]&&e[1]>o[1]))})))})),a.length&&t&&r(t.start)&&r(t.end)){const e=t.start.getTime(),r=t.end.getTime(),n=a[0].multidimensionalDefinition.findIndex((e=>"StdTime"===e.dimensionName));n>-1&&(a=a.filter((t=>{const a=t.multidimensionalDefinition[n].values[0];return e<=a&&r>=a})))}return a.map((e=>e.sliceId))}function u(e,r){const{multidimensionalInfo:t,keyProperties:a}=e;if(n(t))return null;const i=a?.DefaultVariable,{variables:s}=t,l=i?s.find((({name:e})=>e===i))??s[0]:s[0];return l.dimensions.map((e=>{const{values:n,extent:t}=e;let a=n?.[0]??t[0];return"stdz"===e.name.toLowerCase()&&!e.hasRanges&&Math.abs(t[1])<=Math.abs(t[0])&&(a=n?.length?e.values[n.length-1]:t[1]),new o({variableName:l.name,dimensionName:e.name,values:[a],isSlice:!r||!!e.hasRanges})}))}function h(e){return!(n(e)||!e.length)&&e.some((e=>{if(null==e.values)return!0;const r=e.values.length;return 0===r||r>1||!e.isSlice&&Array.isArray(e.values[0])}))}function d(e,r){const{values:n}=r;if(n?.length)return Array.isArray(n[0])!==Array.isArray(e)?-1:Array.isArray(n[0])?n.findIndex((r=>r[0]===e[0]&&r[1]===e[1])):n.indexOf(e);const{extent:t}=r;if(Array.isArray(e)||e<t[0]||e>t[1])return-1;const a=r.interval||1;if("ISO8601"!==r.unit)return Math.round((e-t[0])/a);const o=t[0];let i=-1;switch(r.intervalUnit?.toLowerCase()||"seconds"){case"seconds":i=Math.round((e-o)/1e3/a);break;case"minutes":i=Math.round((e-o)/6e4/a);break;case"hours":i=Math.round((e-o)/36e5/a);break;case"days":i=Math.round((e-o)/864e5/a);break;case"months":{const r=new Date(e).getUTCFullYear()-new Date(o).getUTCFullYear(),n=new Date(o).getUTCMonth(),t=new Date(e).getUTCMonth();i=0===r?t-n:t+11-n+12*(r-1)}break;case"years":i=Math.round((new Date(e).getUTCFullYear()-new Date(o).getUTCFullYear())/a);break;case"decades":i=Math.round((new Date(e).getUTCFullYear()-new Date(o).getUTCFullYear())/10/a)}return i}function m(e){let r=e.values?.length;if(r)return r;const{extent:n,unit:t}=e,a=e.interval||1,o=n[1]-n[0];if("ISO8601"!==t)return Math.round(o/a);switch(e.intervalUnit?.toLowerCase()??"seconds"){case"seconds":r=Math.round(o/1e3/a);break;case"minutes":r=Math.round(o/6e4/a);break;case"hours":r=Math.round(o/36e5/a);break;case"days":r=Math.round(o/864e5/a);break;case"months":{const e=new Date(n[1]).getUTCFullYear()-new Date(n[0]).getUTCFullYear(),t=new Date(n[1][0]).getUTCMonth(),a=new Date(n[1][1]).getUTCMonth();r=0===e?a-t+1:a+11-t+12*(e-1)+1}break;case"years":r=Math.round((new Date(n[1]).getUTCFullYear()-new Date(n[0]).getUTCFullYear())/a);break;case"decades":r=Math.round((new Date(n[1]).getUTCFullYear()-new Date(n[0]).getUTCFullYear())/10/a);break;default:r=0}return r}function f(e,r){let n=0;const t=e[0].variableName,a=[...r.variables].sort(((e,r)=>e.name>r.name?1:-1));for(let r=0;r<a.length;r++){const o=a[r],i=[...o.dimensions].sort(((e,r)=>e.name>r.name?-1:1));if(o.name!==t){n+=i.map((e=>m(e))).reduce(((e,r)=>e*r));continue}const s=i.map((e=>m(e))),l=i.length;for(let r=0;r<l;r++){const t=e.find((e=>e.dimensionName===i[r].name));if(null==t)return null;const a=d(t.values[0],i[r]);if(-1===a)return null;s.shift(),n+=r===l-1?a:a*s.reduce(((e,r)=>e*r))}break}return n}export{i as R,f as a,c as b,l as c,u as g,h as i};
