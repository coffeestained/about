/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{a as t}from"./maybe.js";import{c as i}from"./aaBoundingRect.js";import{c as s}from"./extentUtils.js";import{c as n}from"../geometry/Polygon.js";import{isPoint as e,isMultipoint as h,isExtent as o,isPolygon as r,isPolyline as u}from"../geometry/support/jsonUtils.js";import{c as m,u as x,o as l}from"./normalizeUtilsCommon.js";import{g as a,i as c}from"../geometry/SpatialReference.js";function p(t){return _(t,!0)}function f(t){return _(t,!1)}function _(i,n){if(t(i))return null;const p=i.spatialReference,f=a(p),_="toJSON"in i?i.toJSON():i;if(!f)return _;const I=c(p)?102100:4326,C=m[I].maxX,S=m[I].minX;if(e(_))return y(_,C,S);if(h(_))return _.points=_.points.map((t=>y(t,C,S))),_;if(o(_))return function(t,i){if(!i)return t;const s=function(t,i){const s=[],{ymin:n,ymax:e,xmin:h,xmax:o}=t,r=t.xmax-t.xmin,[u,m]=i.valid,{x,frameId:l}=d(t.xmin,i),{x:a,frameId:c}=d(t.xmax,i),p=x===a&&r>0;if(r>2*m){const t={xmin:h<o?x:a,ymin:n,xmax:m,ymax:e},i={xmin:u,ymin:n,xmax:h<o?a:x,ymax:e},r={xmin:0,ymin:n,xmax:m,ymax:e},p={xmin:u,ymin:n,xmax:0,ymax:e},f=[],_=[];g(t,r)&&f.push(l),g(t,p)&&_.push(l),g(i,r)&&f.push(c),g(i,p)&&_.push(c);for(let t=l+1;t<c;t++)f.push(t),_.push(t);s.push(new O(t,[l]),new O(i,[c]),new O(r,f),new O(p,_))}else x>a||p?s.push(new O({xmin:x,ymin:n,xmax:m,ymax:e},[l]),new O({xmin:u,ymin:n,xmax:a,ymax:e},[c])):s.push(new O({xmin:x,ymin:n,xmax:a,ymax:e},[l]));return s}(t,i).map((t=>t.extent));return s.length<2?s[0]||t:s.length>2?(t.xmin=i.valid[0],t.xmax=i.valid[1],t):{rings:s.map((t=>[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]))}}(_,f);if(r(_)||u(_)){const t=s(P,_),i={xmin:t[0],ymin:t[1],xmax:t[2],ymax:t[3]},e=l(i.xmin,S)*(2*C),h=0===e?_:x(_,e);return i.xmin+=e,i.xmax+=e,i.xmax>C?v(h,C,n):i.xmin<S?v(h,S,n):h}return _}function y(t,i,s){if(Array.isArray(t)){const n=t[0];if(n>i){const s=l(n,i);t[0]=n+s*(-2*i)}else if(n<s){const i=l(n,s);t[0]=n+i*(-2*s)}}else{const n=t.x;if(n>i){const s=l(n,i);t.x+=s*(-2*i)}else if(n<s){const i=l(n,s);t.x+=i*(-2*s)}}return t}function d(t,i){const[s,n]=i.valid,e=2*n;let h,o=0;return t>n?(h=Math.ceil(Math.abs(t-n)/e),t-=h*e,o=h):t<s&&(h=Math.ceil(Math.abs(t-s)/e),t+=h*e,o=-h),{x:t,frameId:o}}function g(t,i){const{xmin:s,ymin:n,xmax:e,ymax:h}=i;return I(t,s,n)&&I(t,s,h)&&I(t,e,h)&&I(t,e,n)}function I(t,i,s){return i>=t.xmin&&i<=t.xmax&&s>=t.ymin&&s<=t.ymax}function v(t,i,s=!0){const e=!u(t);if(e&&n(t),s)return(new C).cut(t,i);const h=e?t.rings:t.paths,o=e?4:2,r=h.length,m=-2*i;for(let t=0;t<r;t++){const i=h[t];if(i&&i.length>=o){const t=[];for(const s of i)t.push([s[0]+m,s[1]]);h.push(t)}}return e?t.rings=h:t.paths=h,t}class O{constructor(t,i){this.extent=t,this.frameIds=i}}const P=i();class C{constructor(){this.linesIn=[],this.linesOut=[]}cut(t,i){let s;if(this.xCut=i,t.rings)this.closed=!0,s=t.rings,this.minPts=4;else{if(!t.paths)return null;this.closed=!1,s=t.paths,this.minPts=2}for(const t of s){if(!t||t.length<this.minPts)continue;let i=!0;for(const s of t)i?(this.moveTo(s),i=!1):this.lineTo(s);this.closed&&this.close()}this._pushLineIn(),this._pushLineOut(),s=[];for(const t of this.linesIn)t&&t.length>=this.minPts&&s.push(t);const n=-2*this.xCut;for(const t of this.linesOut)if(t&&t.length>=this.minPts){for(const i of t)i[0]+=n;s.push(t)}return this.closed?t.rings=s:t.paths=s,t}moveTo(t){this._pushLineIn(),this._pushLineOut(),this._prevSide=this._side(t[0]),this._moveTo(t[0],t[1],this._prevSide),this._prevPt=t,this._firstPt=t}lineTo(t){const i=this._side(t[0]);if(i*this._prevSide==-1){const s=this._intersect(this._prevPt,t);this._lineTo(this.xCut,s,0),this._prevSide=0,this._lineTo(t[0],t[1],i)}else this._lineTo(t[0],t[1],i);this._prevSide=i,this._prevPt=t}close(){const t=this._firstPt,i=this._prevPt;t[0]===i[0]&&t[1]===i[1]||this.lineTo(t),this._checkClosingPt(this.lineIn),this._checkClosingPt(this.lineOut)}_moveTo(t,i,s){this.closed?(this.lineIn.push([s<=0?t:this.xCut,i]),this.lineOut.push([s>=0?t:this.xCut,i])):(s<=0&&this.lineIn.push([t,i]),s>=0&&this.lineOut.push([t,i]))}_lineTo(t,i,s){this.closed?(this._addPolyVertex(this.lineIn,s<=0?t:this.xCut,i),this._addPolyVertex(this.lineOut,s>=0?t:this.xCut,i)):s<0?(0===this._prevSide&&this._pushLineOut(),this.lineIn.push([t,i])):s>0?(0===this._prevSide&&this._pushLineIn(),this.lineOut.push([t,i])):this._prevSide<0?(this.lineIn.push([t,i]),this.lineOut.push([t,i])):this._prevSide>0&&(this.lineOut.push([t,i]),this.lineIn.push([t,i]))}_addPolyVertex(t,i,s){const n=t.length;n>1&&t[n-1][0]===i&&t[n-2][0]===i?t[n-1][1]=s:t.push([i,s])}_checkClosingPt(t){const i=t.length;i>3&&t[0][0]===this.xCut&&t[i-2][0]===this.xCut&&t[1][0]===this.xCut&&(t[0][1]=t[i-2][1],t.pop())}_side(t){return t<this.xCut?-1:t>this.xCut?1:0}_intersect(t,i){const s=(this.xCut-t[0])/(i[0]-t[0]);return t[1]+s*(i[1]-t[1])}_pushLineIn(){this.lineIn&&this.lineIn.length>=this.minPts&&this.linesIn.push(this.lineIn),this.lineIn=[]}_pushLineOut(){this.lineOut&&this.lineOut.length>=this.minPts&&this.linesOut.push(this.lineOut),this.lineOut=[]}}export{f as a,p as n};
