/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../core/Evented.js";import{HandleOwner as i}from"../core/HandleOwner.js";import{i as s,a as n,u as r}from"./maybe.js";import{eachAlwaysValues as o,throwIfAborted as a,isAborted as c}from"../core/promiseUtils.js";import{sync as d,watch as h,syncAndInitial as p}from"../core/reactiveUtils.js";import{property as l}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import{s as u}from"./ensureType.js";import{subclass as g}from"../core/accessorSupport/decorators/subclass.js";import{e as f,f as v,c as y,s as x,b as m,u as E,q as _,l as S,j as w}from"./vec2.js";import V from"../core/Handles.js";import{h as P}from"./mathUtils.js";import{S as T}from"./QueryEngineResult.js";import{a as C,f as H}from"./vec2f64.js";import{d as I}from"./Settings2.js";import{o as j,L,a as R,R as O,s as F,b,P as M,I as q}from"./RightAngleSnappingHint.js";import{p as N,a as A,b as k,L as z,i as G,c as Y,d as D,e as X,f as Z}from"./geometry2dUtils.js";import{a as U,b as W}from"./viewUtils.js";import Q from"../core/Accessor.js";import B from"../core/Collection.js";import J from"../views/interactive/snapping/SnappingOptions.js";class K{constructor(e){this.coordinateHelper=e}}class $ extends K{constructor(e,t){super(e),this.point=t}objectEqual(e){return e instanceof $&&j(this.point,e.point)}check(e){return x(e,this.point)<I.pointThreshold}closestTo(){return this.coordinateHelper.clone(this.point)}intersect(e){const t=[];return e instanceof ee?t.push(...k({start:e.start,end:e.end,type:e instanceof ie?z.LINE:z.RAY},this.point)):e instanceof ne&&t.push(...Z(e.center,e.radius,this.point)),t.map((t=>new se(this.coordinateHelper,t,this,e)))}}class ee extends K{constructor(e,t,i){super(e),this.start=t,this.end=i}objectEqual(e){return e instanceof ee&&j(this.start,e.start)&&j(this.end,e.end)}intersect(e){const t=[];return e instanceof $?t.push(...k({start:this.start,end:this.end,type:this instanceof ie?z.LINE:z.RAY},e.point)):e instanceof ee?t.push(...G({start:this.start,end:this.end,type:this instanceof ie?z.LINE:z.RAY},{start:e.start,end:e.end,type:e instanceof ie?z.LINE:z.RAY})):e instanceof ne&&t.push(...Y({start:this.start,end:this.end,type:this instanceof ie?z.LINE:z.RAY},e.center,e.radius)),t.map((t=>new se(this.coordinateHelper,t,this,e)))}}class te extends ee{constructor(e,t,i){super(e,t,i),this.dir=C(),this.p=C()}objectEqual(e){return e instanceof te&&super.objectEqual(e)}check(e){return f(this.dir,this.end,this.start),f(this.p,e,this.start),v(this.dir,this.p)>=0&&N(e,this.start,this.end)<I.pointOnLineThreshold}closestTo(e){const t=this.coordinateHelper.clone(e);return A(t,e,this.start,this.end),t}}class ie extends ee{constructor(e,t,i){super(e,t,i)}objectEqual(e){return e instanceof ie&&super.objectEqual(e)}check(e){return N(e,this.start,this.end)<I.pointOnLineThreshold}closestTo(e){const t=this.coordinateHelper.clone(e);return D(t,e,this.start,this.end),t}}class se extends K{constructor(e,t,i,s){super(e),this.intersection=t,this.first=i,this.second=s}objectEqual(e){return e instanceof se&&this.first.objectEqual(e.first)&&this.second.objectEqual(e.second)}check(){return!1}closestTo(e){const t=this.coordinateHelper.clone(e);return y(t,this.intersection),t}intersect(){return[]}}class ne extends K{constructor(e,t,i){super(e),this.center=t,this.radius=i}objectEqual(e){return e instanceof ne&&this.center[0]===e.center[0]&&this.center[1]===e.center[1]&&this.radius===e.radius}check(){return!1}closestTo(e){const t=this.coordinateHelper.clone(e);return X(t,e,this.center,this.radius),t}intersect(e){const t=[];return e instanceof ee?t.push(...Y({start:e.start,end:e.end,type:e instanceof ie?z.LINE:z.RAY},this.center,this.radius)):e instanceof $&&t.push(...Z(this.center,this.radius,e.point)),t.map((t=>new se(this.coordinateHelper,t,this,e)))}}class re{constructor(e,t,i,s){this.coordinateHelper=e,this.targetPoint=t,this.constraint=i,this.elevationInfo=s}}class oe extends re{constructor({coordinateHelper:e,targetPoint:t,objectId:i,constraint:s,elevationInfo:n}){super(e,t,s,n),this.objectId=i}}class ae extends oe{constructor(e){super({...e,constraint:new ie(e.coordinateHelper,e.edgeStart,e.edgeEnd)})}get hints(){return[new L(R.REFERENCE,this.constraint.start,this.constraint.end,this.elevationInfo)]}}class ce extends re{constructor({coordinateHelper:e,targetPoint:t,constraint:i,previousVertex:s,otherVertex:n,otherVertexType:r,objectId:o,elevationInfo:a}){super(e,t,i,a),this.previousVertex=s,this.otherVertex=n,this.otherVertexType=r,this.objectId=o}get hints(){const e=this.previousVertex,t=this.otherVertexType===de.CENTER?this.otherVertex:this.targetPoint,i=this.otherVertexType===de.CENTER?this.targetPoint:this.otherVertex,s=this.elevationInfo;return[new L(R.TARGET,t,i,s),new L(R.REFERENCE,e,t,s),new O(this.previousVertex,t,i,s)]}}var de;!function(e){e[e.NEXT=0]="NEXT",e[e.CENTER=1]="CENTER"}(de||(de={}));let he=class extends i{constructor(e){super(e),this.options=null,this.sourceModules={featureService:{module:null,loader:null},featureCollection:{module:null,loader:null},graphics:{module:null,loader:null}}}get updating(){return u(this.snappingSources,(({snappingSource:e})=>e.updating))||this.updatingHandles.updating}get snappingSources(){const e=this._get("snappingSources")||new Map,t=new Map;if(s(this.options)&&s(this.options.featureSources))for(const i of this.options.featureSources.items){const n=i.layer.uid,r=e.get(n);if(r){e.delete(n),t.set(n,r);continue}if(!i.layer.loaded){this.updatingHandles.addPromise(i.layer.load());continue}const o=this._createSourceInfo(i);s(o)&&t.set(n,o)}for(const[,t]of e)t.destroy();return t}initialize(){this.updatingHandles.add((()=>this.snappingSources),(()=>this.notifyChange("updating")),d),s(this.view)&&this.handles.add([this.view.on("layerview-create",(e=>this._updateLayerView(e.layer,e.layerView))),this.view.on("layerview-destroy",(e=>this._updateLayerView(e.layer,null)))])}_updateLayerView(e,t){for(const[,i]of this.snappingSources)i.snappingSource.layerSource.layer===e&&(i.layerView=t)}destroy(){this._set("options",null);for(const[,e]of this.snappingSources)e.destroy()}async fetchCandidates(e,t,i){if(n(this.options)||!this.options.effectiveFeatureEnabled)return[];const r=[],c=this._computeScreeenSizeDistanceParameters(e,t),d={distance:c,point:e,coordinateHelper:t.coordinateHelper,types:this.types,filter:null};for(const[,{snappingSource:e,layerView:n}]of this.snappingSources)!e.layerSource.enabled||s(n)&&n.suspended||r.push(e.fetchCandidates(d,i).then((i=>i.filter((i=>!this._candidateIsExcluded(e,i,t.excludeFeature))))));const h=(await o(r)).flat();return this._addRightAngleCandidates(h,e,c,t),a(i),F(e,h),h}_addRightAngleCandidates(e,t,i,n){const o=s(n.vertexHandle)?n.vertexHandle.rightEdge?.rightVertex?.pos:s(n.editGeometryOperations)&&"polygon"===n.editGeometryOperations.data.type?r(n.editGeometryOperations.data.components[0]?.getFirstVertex())?.pos:null,a=s(n.vertexHandle)?n.vertexHandle.leftEdge?.leftVertex?.pos:s(n.editGeometryOperations)?r(n.editGeometryOperations.data.components[0]?.getLastVertex())?.pos:null,c=e.length;for(let s=0;s<c;s++)this._addRightAngleCandidate(e[s],a,t,i,n,e),this._addRightAngleCandidate(e[s],o,t,i,n,e)}_addRightAngleCandidate(e,t,i,s,r,o){if(n(t)||!(e instanceof ae))return;const a=e.constraint.closestTo(t),c=(a[0]-i[0])/s.x,d=(a[1]-i[1])/s.y;if(c*c+d*d<=1){const i=r.coordinateHelper;o.push(new ce({coordinateHelper:i,targetPoint:a,otherVertex:t,otherVertexType:de.NEXT,previousVertex:e.constraint.start,constraint:new te(i,t,a),objectId:e.objectId,elevationInfo:e.elevationInfo}))}}_computeScreeenSizeDistanceParameters(e,t){const i=s(this.options)?this.options.distance*("touch"===t.pointer?this.options.touchSensitivityMultiplier:1):0;if(n(this.view))return{x:i,y:i,pixelSize:i};if("2d"===this.view.type){const e=i*this.view.resolution;return{x:e,y:e,pixelSize:e}}return this._computeScreenSizeDistanceParameters3D(e,i,this.view,t)}_computeScreenSizeDistanceParameters3D(e,t,i,s){const{coordinateHelper:n,elevationInfo:r}=s,o=i.state.camera.computeScreenPixelSizeAt(U(e,n,r,i,le)),a=o*i.renderCoordsHelper.unitInMeters/i.mapCoordsHelper.unitInMeters,c=t*a;return{x:c/this._computeScreenMagnitudeOfMapOffset(e,a,0,i,s),y:c/this._computeScreenMagnitudeOfMapOffset(e,0,a,i,s),pixelSize:o}}_computeScreenMagnitudeOfMapOffset(e,t,i,s,{coordinateHelper:n,elevationInfo:r}){const o=n.clone(e);o[0]+=t,o[1]+=i;const a=W(e,n,r,s),c=W(o,n,r,s),d=c.x-a.x,h=c.y-a.y;return Math.sqrt(d*d+h*h)}get types(){return T.EDGE|T.VERTEX}_candidateIsExcluded(e,t,i){if(n(i))return!1;const s=this._getCandidateObjectId(t);if(n(s))return!1;const r=e.layerSource.layer;return"graphics"===r.type?i.uid===s:i.sourceLayer===r&&!(!i.attributes||!("objectIdField"in r))&&i.attributes[r.objectIdField]===s}_getCandidateObjectId(e){return e instanceof oe?e.objectId:null}_createSourceInfo(e){const t=this._createFeatureSnappingSourceType(e);if(n(t))return null;if("loading"in t)return this.updatingHandles.addPromise(t.loading.then((()=>{this.destroyed||this.notifyChange("snappingSources")}))),null;const i=s(this.view)?this.view.allLayerViews.find((t=>t.layer===e.layer)):null;return new pe(t.source,i)}_createFeatureSnappingSourceType(e){switch(e.layer.type){case"feature":case"geojson":case"csv":case"subtype-group":case"wfs":return this._createFeatureSnappingSourceFeatureLayer(e);case"graphics":return this._createFeatureSnappingSourceGraphicsLayer(e)}return null}_createFeatureSnappingSourceFeatureLayer(e){switch(e.layer.source.type){case"feature-layer":{const t=this._getSourceModule("featureService");return s(t.module)?{source:new t.module.FeatureServiceSnappingSource({spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}case"memory":case"csv":case"geojson":case"wfs":{if("mesh"===e.layer.geometryType)return null;const t=this._getSourceModule("featureCollection");return s(t.module)?{source:new t.module.FeatureCollectionSnappingSource({layerSource:e})}:{loading:t.loader}}}return null}_createFeatureSnappingSourceGraphicsLayer(e){const t=this._getSourceModule("graphics");return s(t.module)?{source:new t.module.GraphicsSnappingSource({spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}_getSourceModule(e){const t=this.sourceModules[e];if(n(t.loader)){const i=this._loadSourceModule(e).then((e=>{t.module=e}));return t.loader=i,{module:t.module,loader:i}}return{module:t.module,loader:t.loader}}_loadSourceModule(e){switch(e){case"featureService":return this.updatingHandles.addPromise(import("./FeatureServiceSnappingSource.js"));case"featureCollection":return this.updatingHandles.addPromise(import("./FeatureCollectionSnappingSource.js"));case"graphics":return this.updatingHandles.addPromise(import("./GraphicsSnappingSource.js"))}return null}};e([l({constructOnly:!0})],he.prototype,"spatialReference",void 0),e([l({constructOnly:!0})],he.prototype,"view",void 0),e([l()],he.prototype,"options",void 0),e([l({readOnly:!0})],he.prototype,"updating",null),e([l({readOnly:!0})],he.prototype,"snappingSources",null),he=e([g("esri.views.interactive.snapping.FeatureSnappingEngine")],he);class pe{constructor(e,t){this.snappingSource=e,this.layerView=t,this.handles=new V;const i=this.snappingSource.layerSource.layer;if("refresh"in i){const t=i;this.handles.add(t.on("refresh",(()=>e.refresh())))}this.handles.add([h((()=>e.updating),(t=>e.layerSource.updating=t),p),h((()=>e.availability),(t=>e.layerSource.availability=t),p)])}destroy(){this.snappingSource.destroy(),this.handles.destroy()}}const le=P();class ue{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=I.shortLineThreshold*I.shortLineThreshold}snap(e,t){return s(t.vertexHandle)?"vertex"!==t.vertexHandle.type?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(e.leftVertex.pos,e.rightVertex.pos,t)}exceedsShortLineThreshold(e,t,{elevationInfo:i,editGeometryOperations:s}){const n=s.data.coordinateHelper;return 0===this.squaredShortLineThreshold||b(W(t,n,i,this.view),W(e,n,i,this.view))>this.squaredShortLineThreshold}squaredProximityTreshold(e){return"touch"===e?this.squaredTouchProximityThreshold:this.squaredMouseProximityTreshold}get squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}}class ge extends re{constructor({coordinateHelper:e,lineStart:t,lineEnd:i,targetPoint:s,elevationInfo:n}){super(e,s,new ie(e,t,i),n),this.referenceLineHint=new L(R.REFERENCE_EXTENSION,t,i,n)}get hints(){return[this.referenceLineHint,new L(R.TARGET,this._lineEndClosestToTarget(),this.targetPoint,this.elevationInfo)]}_lineEndClosestToTarget(){const e=this.constraint.start,t=this.constraint.end;return Math.sign(v(f(ve,t,e),f(fe,this.targetPoint,e)))>0?t:e}}const fe=C(),ve=C();class ye extends ue{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,n=[];if(s<1)return n;const r=t.coordinateHelper,o=W(e,r,t.elevationInfo,this.view),a=i.edges[s-1];let c=a;do{this.edgeExceedsShortLineThreshold(c,t)&&this._processCandidateProposal(c.leftVertex.pos,c.rightVertex.pos,e,o,t,n),c=c.leftVertex.leftEdge}while(c&&c!==a);return n}snapExistingVertex(e,t){const i=[],s=r(t.vertexHandle),n=s.component;if(n.edges.length<2)return i;const o=t.coordinateHelper,a=W(e,o,t.elevationInfo,this.view),c=s.leftEdge,d=s.rightEdge;c&&d&&this.edgeExceedsShortLineThreshold(c,t)&&this.edgeExceedsShortLineThreshold(d,t)&&this._processCandidateProposal(c.leftVertex.pos,d.rightVertex.pos,e,a,t,i);const h=n.edges[0];let p=h;do{p!==s.leftEdge&&p!==s.rightEdge&&this.edgeExceedsShortLineThreshold(p,t)&&this._processCandidateProposal(p.leftVertex.pos,p.rightVertex.pos,e,a,t,i),p=p.rightVertex.rightEdge}while(p&&p!==h);return i}_processCandidateProposal(e,t,i,s,n,r){const o=D(C(),i,e,t),{coordinateHelper:a,elevationInfo:c,pointer:d}=n,h=a.fromXYZ(o,a.getZ(i,0));b(s,W(h,a,c,this.view))<this.squaredProximityTreshold(d)&&r.push(new ge({coordinateHelper:a,lineStart:e,lineEnd:t,targetPoint:h,elevationInfo:c}))}}class xe extends re{constructor({coordinateHelper:e,referenceLine:t,lineStart:i,targetPoint:s,elevationInfo:n}){const r=e.clone(i);f(r,m(r,r,t.rightVertex.pos),t.leftVertex.pos),super(e,s,new ie(e,i,r),n),this._referenceLines=[{edge:t,fadeLeft:!0,fadeRight:!0}]}get hints(){const e=this.elevationInfo;return[new L(R.TARGET,this.constraint.start,this.targetPoint,e),new M(this.constraint.start,this.targetPoint,e),...this._referenceLines.map((t=>new L(R.REFERENCE,t.edge.leftVertex.pos,t.edge.rightVertex.pos,e,t.fadeLeft,t.fadeRight)))]}addReferenceLine(e){const t={edge:e,fadeLeft:!0,fadeRight:!0};this._referenceLines.forEach((i=>{e.rightVertex.rightEdge===i.edge&&(i.fadeLeft=!1,t.fadeRight=!1),e.leftVertex.leftEdge===i.edge&&(i.fadeRight=!1,t.fadeLeft=!1)})),this._referenceLines.push(t)}}class me extends ue{constructor(){super(...arguments),this._tmpProjection=C()}snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,n=i.vertices.length,r=[];if(s<2)return r;const o=W(e,t.coordinateHelper,t.elevationInfo,this.view),a=i.vertices[n-1],c=i.vertices[0],d=i.edges[s-1];let h=d;do{this.edgeExceedsShortLineThreshold(h,t)&&(this._checkEdgeForParalleLines(h,a.pos,e,o,t,r),this._checkEdgeForParalleLines(h,c.pos,e,o,t,r)),h=h.leftVertex.leftEdge}while(h&&h!==d);return r}snapExistingVertex(e,t){const i=[],s=r(t.vertexHandle),n=s.component;if(n.edges.length<3)return i;const o=W(e,t.coordinateHelper,t.elevationInfo,this.view),a=s.leftEdge,c=s.rightEdge,d=n.vertices[0],h=n.vertices.length,p=n.vertices[h-1],l=n.edges[0];let u=l;do{u!==a&&u!==c&&this.edgeExceedsShortLineThreshold(u,t)&&(a&&this._checkEdgeForParalleLines(u,a.leftVertex.pos,e,o,t,i),c&&this._checkEdgeForParalleLines(u,c.rightVertex.pos,e,o,t,i),s===d?this._checkEdgeForParalleLines(u,p.pos,e,o,t,i):s===p&&this._checkEdgeForParalleLines(u,d.pos,e,o,t,i)),u=u.rightVertex.rightEdge}while(u&&u!==l);return i}_checkEdgeForParalleLines(e,t,i,s,n,r){const o=e.leftVertex.pos,a=e.rightVertex.pos;if(D(this._tmpProjection,t,o,a),x(this._tmpProjection,t)<I.parallelLineThreshold)return;D(this._tmpProjection,i,o,a,t);const{coordinateHelper:c,elevationInfo:d,pointer:h}=n,p=c.fromXYZ(this._tmpProjection,c.getZ(i,0));if(b(s,W(p,c,d,this.view))<this.squaredProximityTreshold(h)){if(this._parallelToPreviousCandidate(e,r))return;r.push(new xe({coordinateHelper:c,referenceLine:e,lineStart:t,targetPoint:p,elevationInfo:d}))}}_parallelToPreviousCandidate(e,t){const i=e.leftVertex.pos,s=e.rightVertex.pos;for(const n of t)if(D(this._tmpProjection,s,n.constraint.start,n.constraint.end,i),x(this._tmpProjection,s)<I.parallelLineThreshold)return n.addReferenceLine(e),!0;return!1}}class Ee extends ue{constructor(){super(...arguments),this._tmp=C()}snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.vertices.length,n=[];if(s<2)return n;const r=W(e,t.coordinateHelper,t.elevationInfo,this.view),o=i.vertices[s-1];this._checkForSnappingCandidate(n,o.leftEdge,o.pos,e,o.leftEdge.leftVertex.pos,o.pos,t,e,r);const a=i.vertices[0];return this._checkForSnappingCandidate(n,a.rightEdge,a.pos,e,a.rightEdge.rightVertex.pos,a.pos,t,e,r),n}snapExistingVertex(e,t){const i=[],s=r(t.vertexHandle),n=s.component,o=n.vertices.length;if(o<3)return i;const a=W(e,t.coordinateHelper,t.elevationInfo,this.view),c=s.leftEdge,d=s.rightEdge,h=n.vertices[0],p=n.vertices[o-1];if(!c)return this._checkForSnappingCandidate(i,h.rightEdge.rightVertex.rightEdge,h.rightEdge.rightVertex.pos,e,h.rightEdge.rightVertex.rightEdge.rightVertex.pos,h.rightEdge.rightVertex.pos,t,e,a),i;if(!d)return this._checkForSnappingCandidate(i,p.leftEdge.leftVertex.leftEdge,p.leftEdge.leftVertex.pos,e,p.leftEdge.leftVertex.leftEdge.leftVertex.pos,p.leftEdge.leftVertex.pos,t,e,a),i;if(c&&c.leftVertex.leftEdge){const s=c.leftVertex.leftEdge;this._checkForSnappingCandidate(i,s,c.leftVertex.pos,e,s.leftVertex.pos,c.leftVertex.pos,t,e,a)}if(d&&d.rightVertex.rightEdge){const s=d.rightVertex.rightEdge;this._checkForSnappingCandidate(i,s,d.rightVertex.pos,e,s.rightVertex.pos,d.rightVertex.pos,t,e,a)}return i}_checkForSnappingCandidate(e,t,i,s,n,r,o,a,c){if(!this.edgeExceedsShortLineThreshold(t,o))return;f(this._tmp,t.rightVertex.pos,t.leftVertex.pos);const d=H(this._tmp[1],-this._tmp[0]),h=v(d,f(this._tmp,s,i))/E(d),{coordinateHelper:p,elevationInfo:l,pointer:u}=o,g=p.fromXYZ(_(C(),r,d,h),p.getZ(a,0));b(c,W(g,p,l,this.view))<this.squaredProximityTreshold(u)&&e.push(new ce({coordinateHelper:p,targetPoint:g,constraint:new te(p,r,_(p.createVector(),r,d,Math.sign(h))),previousVertex:n,otherVertex:r,otherVertexType:de.CENTER,elevationInfo:l}))}}class _e extends re{constructor({coordinateHelper:e,targetPoint:t,point1:i,point2:s,elevationInfo:n}){super(e,t,new ne(e,S(Se,i,s,.5),.5*w(i,s)),n),this.p1=i,this.p2=s}get hints(){const e=this.elevationInfo;return[new L(R.REFERENCE,this.targetPoint,this.p1,e),new L(R.REFERENCE,this.targetPoint,this.p2,e),new O(this.p1,this.targetPoint,this.p2,e)]}}const Se=C();class we extends ue{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[],n=i.vertices.length;if("polygon"!==t.editGeometryOperations.data.type||n<2)return s;const r=i.vertices[0],o=i.vertices[n-1];return this._processCandidateProposal(r.pos,o.pos,e,t,s),s}snapExistingVertex(e,t){const i=[],s=r(t.vertexHandle),n=s.component;return n.edges.length<2?i:"polyline"!==t.editGeometryOperations.data.type||0!==s.index&&s.index!==n.vertices.length-1?(this._processCandidateProposal(s.leftEdge.leftVertex.pos,s.rightEdge.rightVertex.pos,e,t,i),i):i}_processCandidateProposal(e,t,i,s,n){if(!this.exceedsShortLineThreshold(e,t,s))return;const r=S(C(),e,t,.5),o=.5*w(e,t),a=X(C(),i,r,o),{coordinateHelper:c,elevationInfo:d,pointer:h}=s,p=c.fromXYZ(a,c.getZ(i,0)),l=W(i,c,d,this.view);b(l,W(p,c,d,this.view))<this.squaredProximityTreshold(h)&&n.push(new _e({coordinateHelper:c,targetPoint:p,point1:e,point2:t,elevationInfo:d}))}}let Ve=class extends Q{constructor(e){super(e),this.updating=!1,this._snappers=new B}initialize(){this._snappers.push(new me(this.view,this.options),new ye(this.view,this.options),new Ee(this.view,this.options),new we(this.view,this.options))}set options(e){this._set("options",e);for(const t of this._snappers)t.options=e}async fetchCandidates(e,t){if(!this.options.effectiveSelfEnabled)return[];const i=[];for(const s of this._snappers.items)i.push(...s.snap(e,t));return F(e,i),i}};function Pe(e,t){return[new Ve({view:e,options:t}),new he({view:e,options:t,spatialReference:e.spatialReference})]}e([l({readOnly:!0})],Ve.prototype,"updating",void 0),e([l({constructOnly:!0})],Ve.prototype,"view",void 0),e([l()],Ve.prototype,"options",null),Ve=e([g("esri.views.interactive.snapping.SelfSnappingEngine")],Ve);class Te extends re{constructor(e,t,i,s,n){super(e,t,new se(e,t,i.constraint,s.constraint),n),this.first=i,this.second=s}get hints(){return this.first.targetPoint=this.targetPoint,this.second.targetPoint=this.targetPoint,[...this.first.hints,...this.second.hints,new q(this.targetPoint,this.elevationInfo)]}}let Ce=class extends(t.EventedMixin(i)){constructor(e){super(e),this.options=new J,this.snappingEnginesFactory=Pe,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[]}initialize(){this.handles.add([h((()=>{const{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:i,distance:s}=this.options;return{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:i,distance:s}}),(()=>{this.doneSnapping(),this.emit("changed")}),d),h((()=>this.options),(e=>{for(const t of this._engines)t.options=e}),d),h((()=>({viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,snappingEnginesFactory:this.snappingEnginesFactory})),(({viewReady:e,snappingEnginesFactory:t})=>this._recreateEngines(e,t)),p)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some((e=>e.updating))}_recreateEngines(e,t){if(this._destroyEngines(),!e)return;const{view:i,options:s}=this;this._engines=t(i,s)}_destroyEngines(){for(const e of this._engines)e.destroy();this._engines=[]}get squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}async snap(e,t,i){const n=t.coordinateHelper.pointToVector(e),r=await this._fetchCandidates(n,t,i);return{get valid(){return!c(i)},apply:()=>{const{snappedPoint:e,hints:i}=this._processCandidates(n,r,t);return this._removeVisualization(),s(t.visualizer)&&this.handles.add(t.visualizer.draw(i,{coordinateHelper:t.coordinateHelper,elevationInfo:t.elevationInfo,view:this.view}),He),e}}}update(e,t){this._removeVisualization();let i=e;const n=[];if(s(this._currentMainCandidate)){const s=t.coordinateHelper,r=s.pointToVector(e),o=this._currentMainCandidate.constraint.closestTo(r);if(b(W(r,s,t.elevationInfo,this.view),W(o,s,t.elevationInfo,this.view))<this._squaredPointProximityThreshold(t.pointer)){i=s.vectorToDehydratedPoint(o),this._currentMainCandidate.targetPoint=o,n.push(...this._currentMainCandidate.hints);for(const e of this._currentOtherActiveCandidates)e.targetPoint=o,n.push(...e.hints)}else this._currentMainCandidate=null,this._currentOtherActiveCandidates=[]}return s(t.visualizer)&&this.handles.add(t.visualizer.draw(n,{coordinateHelper:t.coordinateHelper,elevationInfo:t.elevationInfo,view:this.view}),He),i}doneSnapping(){this._removeVisualization(),this._currentMainCandidate=null,this._currentOtherActiveCandidates=[]}_removeVisualization(){this.handles.remove(He)}async _fetchCandidates(e,t,i){return(await Promise.all(this._engines.map((s=>s.fetchCandidates(e,t,i))))).flat()}_processCandidates(e,t,i){if(t.length<1)return this.doneSnapping(),{snappedPoint:i.coordinateHelper.vectorToDehydratedPoint(e),hints:[]};F(e,t);const n=this._currentMainCandidate;if(s(n)){const s=this._findOldConstraintInNewCandidates(n,t);if(s>=0){if(!(t[s]instanceof Te))return this._intersectWithOtherCandidates(s,t,e,i);if(x(e,n.targetPoint)<this._squaredPointProximityThreshold(i.pointer))return this._updateSnappingCandidate(n,t,i)}}return this._intersectWithOtherCandidates(0,t,e,i)}_findOldConstraintInNewCandidates(e,t){return e instanceof Te?this._findOldCandidateIndex(t,e.first)>=0&&this._findOldCandidateIndex(t,e.second)>=0?0:-1:this._findOldCandidateIndex(t,e)}_intersectWithOtherCandidates(e,t,i,s){const n=t[e],r=[],o=s.coordinateHelper;for(let a=0;a<t.length;++a){if(a===e)continue;const c=t[a];for(const e of n.constraint.intersect(c.constraint)){const t=o.fromXYZ(e.intersection,n.targetPoint[2]);r.push([new Te(o,t,n,c,c.elevationInfo),b(W(i,s.coordinateHelper,s.elevationInfo,this.view),W(t,s.coordinateHelper,s.elevationInfo,this.view))])}}return r.length>0&&(r.sort(((e,t)=>e[1]-t[1])),r[0][1]<this._squaredPointProximityThreshold(s.pointer))?this._updateSnappingCandidate(r[0][0],t,s):this._updateSnappingCandidate(n,t,s)}_updateSnappingCandidate(e,t,i){this.doneSnapping(),this._currentMainCandidate=e;const s=this._currentMainCandidate.targetPoint,n=[];n.push(...e.hints);for(const i of t){if(e instanceof Te){if(i.constraint.objectEqual(e.first.constraint)||i.constraint.objectEqual(e.second.constraint))continue}else if(i.constraint.objectEqual(e.constraint))continue;i.constraint.check(s)&&(i.targetPoint=s,this._currentOtherActiveCandidates.push(i),n.push(...i.hints))}return{snappedPoint:i.coordinateHelper.vectorToDehydratedPoint(s),hints:n}}_squaredPointProximityThreshold(e){return"touch"===e?this.squaredTouchProximityThreshold:this.squaredMouseProximityTreshold}_findOldCandidateIndex(e,t){let i=-1;for(let s=0;s<e.length;++s)if(t.constraint.objectEqual(e[s].constraint)){i=s;break}return i}get test(){return{visualizationsActive:this.handles.has(He),engines:this._engines}}};e([l({constructOnly:!0})],Ce.prototype,"view",void 0),e([l()],Ce.prototype,"options",void 0),e([l({readOnly:!0})],Ce.prototype,"updating",null),e([l()],Ce.prototype,"snappingEnginesFactory",void 0),e([l()],Ce.prototype,"_engines",void 0),e([l()],Ce.prototype,"squaredMouseProximityTreshold",null),e([l()],Ce.prototype,"squaredTouchProximityThreshold",null),Ce=e([g("esri.views.interactive.snapping.SnappingManager")],Ce);const He="visualization-handle";export{ae as E,oe as F,$ as P,Ce as S};
