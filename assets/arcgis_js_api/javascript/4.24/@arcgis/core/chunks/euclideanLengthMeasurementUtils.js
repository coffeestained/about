/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{a as t,i as e,p as n}from"./maybe.js";import{ignoreAbortErrors as r,debounce as a}from"../core/promiseUtils.js";import{p as i}from"./dehydratedFeatureComparison.js";import{E as o}from"./dragEventPipeline.js";import{S as s}from"./SnappingContext.js";import{T as c,I as l}from"./Scheduler.js";import{c as u}from"./quantityUtils.js";import{v as p,t as f}from"./unitUtils.js";import{v as d,s as m,h as x}from"./mathUtils.js";import{projectVectorToVector as h}from"../geometry/projection.js";import{e as y}from"../geometry/SpatialReference.js";import{c as v}from"./measurementUtils2.js";class g{constructor(){this.next=new o}createSnapDragEventPipelineStep({predicate:u=(()=>!0),cancel:p,snappingManager:f,snappingContext:d,updatingHandles:m}){if(t(f))return t=>t;let x=null,h=null;const y=()=>{x=n(x),f.doneSnapping(),e(h)&&h.frameTask.remove(),h=null};p.next((t=>(y(),t))),this.next=new o;const v=a((async({frameTask:t,point:e,context:n,event:r,dx:a,dy:o},s)=>{const c=await t.schedule((()=>f.snap(e,n,s)),s);if(c.valid){let l=await t.schedule((()=>c.apply()),s);e!==g&&(l=f.update(g,n)),i(l,z)||(r.mapEnd.x=l.x+a,r.mapEnd.y=l.y+o,this.next.execute(r))}}));let g,z;return t=>{if(!u(t))return t;if("start"===t.action){const n="3d"===f.view.type?f.view.resourceController.scheduler.registerTask(c.SNAPPING):l;h={context:new s({editGeometryOperations:d.editGeometryOperations,elevationInfo:d.elevationInfo,pointer:d.pointer,vertexHandle:e(t.info)?t.info.handle:null,excludeFeature:d.excludeFeature,visualizer:d.visualizer}),originalPos:e(t.snapOrigin)?d.coordinateHelper.vectorToDehydratedPoint(t.snapOrigin):t.mapStart,frameTask:n}}if(e(h)){const n=h.context.coordinateHelper.vectorToDehydratedPoint(h.context.coordinateHelper.arrayToVector([h.originalPos.x,h.originalPos.y,h.originalPos.z]));n.x+=t.mapEnd.x-t.mapStart.x,n.y+=t.mapEnd.y-t.mapStart.y;const a=t.mapStart.x-h.originalPos.x,i=t.mapStart.y-h.originalPos.y,o={...t,action:"update"},s=h.context,c=f.update(n,h.context);if(z=c,t.mapEnd.x=c.x+a,t.mapEnd.y=c.y+i,g=n,"end"!==t.action){const t=h.frameTask;e(x)||(x=new AbortController),m.addPromise(r(v({frameTask:t,event:o,context:s,point:n,dx:a,dy:i},x.signal)))}}return"end"===t.action&&y(),t}}}function z(t){return j(t,"direct")}function S(t){return j(t,"horizontal")}function j(e,n){const{hasZ:r,spatialReference:a}=e,i=v(a);let o=0;const s=f(i);if(t(s))return null;const c="direct"===n?w:Z;for(const n of e.paths){if(n.length<2)continue;const e=n.length-1;for(let i=0;i<e;++i){const e=n[i];H[0]=e[0],H[1]=e[1],H[2]=r?e[2]:0;const s=n[i+1];U[0]=s[0],U[1]=s[1],U[2]=r?s[2]:0;const l=c(H,U,a);if(t(l))return null;o+=l.value}}return u(o,s)}function P(t,n){const{spatialReference:r}=t;return y(r,n.spatialReference)?(H[0]=t.x,H[1]=t.y,H[2]=t.hasZ?t.z:0,U[0]=n.x,U[1]=n.y,U[2]=n.hasZ?n.z:0,function(t,n,r){const a=C(H,U,r);return e(a)?{direct:u(a.direct,a.unit),horizontal:u(a.horizontal,a.unit),vertical:u(a.vertical,a.unit)}:null}(0,0,r)):null}function T(t,e){const{spatialReference:n}=t;return y(n,e.spatialReference)?(H[0]=t.x,H[1]=t.y,H[2]=t.hasZ?t.z:0,U[0]=e.x,U[1]=e.y,U[2]=e.hasZ?e.z:0,Z(H,U,n)):null}function E(t,e){const{spatialReference:n}=t;return y(n,e.spatialReference)?(H[0]=t.x,H[1]=t.y,H[2]=t.hasZ?t.z:0,U[0]=e.x,U[1]=e.y,U[2]=e.hasZ?e.z:0,k(H,U,n)):null}function R(t){return H[0]=t.x,H[1]=t.y,H[2]=t.hasZ?t.z:0,function(t,n){const r=p(n);return e(r)?u(t[2],r):null}(H,t.spatialReference)}function w(t,n,r){const a=C(t,n,r,"direct");return e(a)?u(a.direct,a.unit):null}function Z(t,n,r){const a=C(t,n,r,"horizontal");return e(a)?u(a.horizontal,a.unit):null}function k(t,n,r){const a=C(t,n,r,"vertical");return e(a)?u(a.verticalSigned,a.unit):null}function C(e,n,r,a){const i=v(r),o=f(i);if(t(o))return null;const s=n[2]-e[2];if("vertical"===a)return{verticalSigned:s,unit:o};if(!h(e,r,b,i)||!h(n,r,I,i))return null;if("direct"===a)return{direct:d(I,b),unit:o};if(m(O,e[0],e[1],n[2]),!h(O,r,O,i))return null;const c=d(O,I);return"horizontal"===a?{horizontal:c,unit:o}:{direct:d(I,b),horizontal:c,vertical:Math.abs(s),unit:o}}const H=x(),U=x(),b=x(),I=x(),O=x();export{g as S,w as a,S as b,z as c,T as d,Z as e,P as f,R as g,k as h,E as v};
