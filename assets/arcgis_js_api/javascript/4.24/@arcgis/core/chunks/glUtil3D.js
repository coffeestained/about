/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{a as e,j as t,i as r,u as i}from"./maybe.js";import{P as s,R as n,S as a}from"./basicInterfaces.js";import{P as o}from"../core/scheduling.js";import{h as c,f as l,q as u,G as h,y as f,Z as d,s as m,d as g,w as p,b as _}from"./mathUtils.js";import{a as v}from"./Util.js";import{C as b,b as x,N as T,g as P,D as S}from"./Material.js";import{g as w,c as I,a as y}from"./geometryDataUtils.js";import{V as A}from"./VertexAttribute.js";import{k as E,e as O}from"./mat4.js";import{a as F,b as M,c as L,B as D}from"./BufferView.js";import{P as U,C as B,S as N,D as R,T as z,a as C,b as $,c as j,U as G}from"./enums.js";import{w as H,T as V}from"./Texture.js";import{c as k}from"./mat4f64.js";import{a as q}from"./vec4f64.js";import{a as K}from"./vec2.js";import{Z as W,a as Y}from"./vec2f64.js";import{c as X}from"./mat4f32.js";import Q from"../core/Error.js";import{L as Z}from"./Logger.js";import{_ as J}from"./tslib.es6.js";import{p as ee,S as te}from"./ShaderTechniqueConfiguration.js";import{V as re}from"./VertexElementDescriptor.js";import{V as ie,B as se}from"./VertexArrayObject.js";class ne{constructor(e,t,r,i){this.primitiveIndices=e,this._numIndexPerPrimitive=t,this.indices=r,this.position=i,this.center=c(),v(e.length>=1),v(r.length%this._numIndexPerPrimitive==0),v(r.length>=e.length*this._numIndexPerPrimitive),v(3===i.size||4===i.size);const{data:s,size:n}=i,a=e.length;let o=n*r[this._numIndexPerPrimitive*e[0]];ae.clear(),ae.push(o),this.bbMin=l(s[o],s[o+1],s[o+2]),this.bbMax=u(this.bbMin);for(let t=0;t<a;++t){const i=this._numIndexPerPrimitive*e[t];for(let e=0;e<this._numIndexPerPrimitive;++e){o=n*r[i+e],ae.push(o);let t=s[o];this.bbMin[0]=Math.min(t,this.bbMin[0]),this.bbMax[0]=Math.max(t,this.bbMax[0]),t=s[o+1],this.bbMin[1]=Math.min(t,this.bbMin[1]),this.bbMax[1]=Math.max(t,this.bbMax[1]),t=s[o+2],this.bbMin[2]=Math.min(t,this.bbMin[2]),this.bbMax[2]=Math.max(t,this.bbMax[2])}}h(this.center,this.bbMin,this.bbMax,.5),this.radius=.5*Math.max(Math.max(this.bbMax[0]-this.bbMin[0],this.bbMax[1]-this.bbMin[1]),this.bbMax[2]-this.bbMin[2]);let f=this.radius*this.radius;for(let e=0;e<ae.length;++e){o=ae.getItemAt(e);const t=s[o]-this.center[0],r=s[o+1]-this.center[1],i=s[o+2]-this.center[2],n=t*t+r*r+i*i;if(n<=f)continue;const a=Math.sqrt(n),c=.5*(a-this.radius);this.radius=this.radius+c,f=this.radius*this.radius;const l=c/a;this.center[0]+=t*l,this.center[1]+=r*l,this.center[2]+=i*l}ae.clear()}getCenter(){return this.center}getBSRadius(){return this.radius}getBBMin(){return this.bbMin}getBBMax(){return this.bbMax}getChildren(){if(this._children)return this._children;if(f(this.bbMin,this.bbMax)>1){const e=h(c(),this.bbMin,this.bbMax,.5),t=this.primitiveIndices.length,r=new Uint8Array(t),i=new Array(8);for(let e=0;e<8;++e)i[e]=0;const{data:s,size:n}=this.position;for(let a=0;a<t;++a){let t=0;const o=this._numIndexPerPrimitive*this.primitiveIndices[a];let c=n*this.indices[o],l=s[c],u=s[c+1],h=s[c+2];for(let e=1;e<this._numIndexPerPrimitive;++e){c=n*this.indices[o+e];const t=s[c],r=s[c+1],i=s[c+2];t<l&&(l=t),r<u&&(u=r),i<h&&(h=i)}l<e[0]&&(t|=1),u<e[1]&&(t|=2),h<e[2]&&(t|=4),r[a]=t,++i[t]}let a=0;for(let e=0;e<8;++e)i[e]>0&&++a;if(a<2)return;const o=new Array(8);for(let e=0;e<8;++e)o[e]=i[e]>0?new Uint32Array(i[e]):void 0;for(let e=0;e<8;++e)i[e]=0;for(let e=0;e<t;++e){const t=r[e];o[t][i[t]++]=this.primitiveIndices[e]}this._children=new Array(8);for(let e=0;e<8;++e)void 0!==o[e]&&(this._children[e]=new ne(o[e],this._numIndexPerPrimitive,this.indices,this.position))}return this._children}static prune(){ae.prune()}}const ae=new o({deallocator:null});class oe extends b{constructor(e,t=[],r=s.Triangle,i=-1){super(),this._primitiveType=r,this.edgeIndicesLength=i,this.type=x.Geometry,this._vertexAttributes=new Map,this._indices=new Map,this._boundingInfo=null;for(const[t,r]of e)r&&this._vertexAttributes.set(t,{...r});if(null==t||0===t.length){const e=function(e){const t=e.values().next().value;return null==t?0:t.data.length/t.size}(this._vertexAttributes),t=w(e);this.edgeIndicesLength=this.edgeIndicesLength<0?e:this.edgeIndicesLength;for(const e of this._vertexAttributes.keys())this._indices.set(e,t)}else for(const[e,r]of t)r&&(this._indices.set(e,ce(r)),e===A.POSITION&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._indices.get(e).length:this.edgeIndicesLength))}cloneShallow(){const e=new oe([],void 0,this._primitiveType,void 0),{_vertexAttributes:t,_indices:r}=e;return this._vertexAttributes.forEach(((e,r)=>{t.set(r,e)})),this._indices.forEach(((e,t)=>{r.set(t,e)})),e.screenToWorldRatio=this.screenToWorldRatio,e._boundingInfo=this._boundingInfo,e}get vertexAttributes(){return this._vertexAttributes}getMutableAttribute(e){const t=this._vertexAttributes.get(e);return t&&!t.exclusive&&(t.data=Array.from(t.data),t.exclusive=!0),t}get indices(){return this._indices}get indexCount(){const e=this._indices.values().next().value;return e?e.length:0}get primitiveType(){return this._primitiveType}get faceCount(){return this.indexCount/3}get boundingInfo(){return e(this._boundingInfo)&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(e){return this.primitiveType===s.Triangle?this._computeAttachmentOriginTriangles(e):this._computeAttachmentOriginPoints(e)}_computeAttachmentOriginTriangles(e){const t=this.indices.get(A.POSITION),r=this.vertexAttributes.get(A.POSITION);return I(r,t,e)}_computeAttachmentOriginPoints(e){const t=this.indices.get(A.POSITION),r=this.vertexAttributes.get(A.POSITION);return y(r,t,e)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const e=this.indices.get(A.POSITION);if(0===e.length)return null;const t=this.primitiveType===s.Triangle?3:1;v(e.length%t==0,"Indexing error: "+e.length+" not divisible by "+t);const r=w(e.length/t),i=this.vertexAttributes.get(A.POSITION);return new ne(r,t,e,i)}}function ce(e){if(e.BYTES_PER_ELEMENT===Uint16Array.BYTES_PER_ELEMENT)return e;for(const t of e)if(t>=65536)return e;return new Uint16Array(e)}var le,ue;!function(e){e[e.Color=0]="Color",e[e.Depth=1]="Depth",e[e.Normal=2]="Normal",e[e.Shadow=3]="Shadow",e[e.Highlight=4]="Highlight",e[e.Draped=5]="Draped",e[e.Occlusion=6]="Occlusion",e[e.Alpha=7]="Alpha",e[e.COUNT=8]="COUNT"}(le||(le={}));class he{constructor(e){this._material=e.material,this._techniqueRepository=e.techniqueRep,this._output=e.output}dispose(){this._techniqueRepository.release(this._technique)}get technique(){return this._technique}ensureTechnique(e,t,r=this._output){return this._technique=this._techniqueRepository.releaseAndAcquire(e,this._material.getConfiguration(r,t),this._technique),this._technique}ensureResources(e){return n.LOADED}}function fe(e,t,r,i,s=1){const n=r.typedBuffer,a=r.typedBufferStride,o=e.length;if(i*=a,1===s)for(let r=0;r<o;++r)n[i]=t[e[r]],i+=a;else for(let r=0;r<o;++r){const o=t[e[r]];for(let e=0;e<s;e++)n[i]=o,i+=a}}function de(e,t,r,i){const s=r.typedBuffer,n=r.typedBufferStride,a=e.length;i*=n;for(let r=0;r<a;++r){const a=2*e[r];s[i]=t[a],s[i+1]=t[a+1],i+=n}}function me(e,t,r,i,s){const n=r.typedBuffer,a=r.typedBufferStride,o=e.length;if(i*=a,null==s||1===s)for(let r=0;r<o;++r){const s=3*e[r];n[i]=t[s],n[i+1]=t[s+1],n[i+2]=t[s+2],i+=a}else for(let r=0;r<o;++r){const o=3*e[r];for(let e=0;e<s;++e)n[i]=t[o],n[i+1]=t[o+1],n[i+2]=t[o+2],i+=a}}function ge(e,t,r,i,s=1){const n=r.typedBuffer,a=r.typedBufferStride,o=e.length;if(i*=a,1===s)for(let r=0;r<o;++r){const s=4*e[r];n[i]=t[s],n[i+1]=t[s+1],n[i+2]=t[s+2],n[i+3]=t[s+3],i+=a}else for(let r=0;r<o;++r){const o=4*e[r];for(let e=0;e<s;++e)n[i]=t[o],n[i+1]=t[o+1],n[i+2]=t[o+2],n[i+3]=t[o+3],i+=a}}function pe(e,t,r,i,s,n=1){if(!r)return void me(e,t,i,s,n);const a=i.typedBuffer,o=i.typedBufferStride,c=e.length,l=r[0],u=r[1],h=r[2],f=r[4],d=r[5],m=r[6],g=r[8],p=r[9],_=r[10],v=r[12],b=r[13],x=r[14];if(s*=o,1===n)for(let r=0;r<c;++r){const i=3*e[r],n=t[i],c=t[i+1],T=t[i+2];a[s]=l*n+f*c+g*T+v,a[s+1]=u*n+d*c+p*T+b,a[s+2]=h*n+m*c+_*T+x,s+=o}else for(let r=0;r<c;++r){const i=3*e[r],c=t[i],T=t[i+1],P=t[i+2],S=l*c+f*T+g*P+v,w=u*c+d*T+p*P+b,I=h*c+m*T+_*P+x;for(let e=0;e<n;++e)a[s]=S,a[s+1]=w,a[s+2]=I,s+=o}}function _e(e,t,r,i,s,n=1){if(!r)return void me(e,t,i,s,n);const a=r,o=i.typedBuffer,c=i.typedBufferStride,l=e.length,u=a[0],h=a[1],f=a[2],d=a[4],m=a[5],g=a[6],p=a[8],_=a[9],v=a[10],b=!E(a),x=1e-6,T=.999999;if(s*=c,1===n)for(let r=0;r<l;++r){const i=3*e[r],n=t[i],a=t[i+1],l=t[i+2];let P=u*n+d*a+p*l,S=h*n+m*a+_*l,w=f*n+g*a+v*l;if(b){const e=P*P+S*S+w*w;if(e<T&&e>x){const t=1/Math.sqrt(e);P*=t,S*=t,w*=t}}o[s+0]=P,o[s+1]=S,o[s+2]=w,s+=c}else for(let r=0;r<l;++r){const i=3*e[r],a=t[i],l=t[i+1],P=t[i+2];let S=u*a+d*l+p*P,w=h*a+m*l+_*P,I=f*a+g*l+v*P;if(b){const e=S*S+w*w+I*I;if(e<T&&e>x){const t=1/Math.sqrt(e);S*=t,w*=t,I*=t}}for(let e=0;e<n;++e)o[s+0]=S,o[s+1]=w,o[s+2]=I,s+=c}}function ve(e,t,r,i,s,n=1){if(!r)return void ge(e,t,i,s,n);const a=r,o=i.typedBuffer,c=i.typedBufferStride,l=e.length,u=a[0],h=a[1],f=a[2],d=a[4],m=a[5],g=a[6],p=a[8],_=a[9],v=a[10],b=!E(a),x=1e-6,T=.999999;if(s*=c,1===n)for(let r=0;r<l;++r){const i=4*e[r],n=t[i],a=t[i+1],l=t[i+2],P=t[i+3];let S=u*n+d*a+p*l,w=h*n+m*a+_*l,I=f*n+g*a+v*l;if(b){const e=S*S+w*w+I*I;if(e<T&&e>x){const t=1/Math.sqrt(e);S*=t,w*=t,I*=t}}o[s+0]=S,o[s+1]=w,o[s+2]=I,o[s+3]=P,s+=c}else for(let r=0;r<l;++r){const i=4*e[r],a=t[i],l=t[i+1],P=t[i+2],S=t[i+3];let w=u*a+d*l+p*P,I=h*a+m*l+_*P,y=f*a+g*l+v*P;if(b){const e=w*w+I*I+y*y;if(e<T&&e>x){const t=1/Math.sqrt(e);w*=t,I*=t,y*=t}}for(let e=0;e<n;++e)o[s+0]=w,o[s+1]=I,o[s+2]=y,o[s+3]=S,s+=c}}function be(e,t,r,i,s,n=1){const a=i.typedBuffer,o=i.typedBufferStride,c=e.length;if(s*=o,1===n){if(4===r)for(let r=0;r<c;++r){const i=4*e[r];a[s]=t[i],a[s+1]=t[i+1],a[s+2]=t[i+2],a[s+3]=t[i+3],s+=o}else if(3===r)for(let r=0;r<c;++r){const i=3*e[r];a[s]=t[i],a[s+1]=t[i+1],a[s+2]=t[i+2],a[s+3]=255,s+=o}}else if(4===r)for(let r=0;r<c;++r){const i=4*e[r];for(let e=0;e<n;++e)a[s]=t[i],a[s+1]=t[i+1],a[s+2]=t[i+2],a[s+3]=t[i+3],s+=o}else if(3===r)for(let r=0;r<c;++r){const i=3*e[r];for(let e=0;e<n;++e)a[s]=t[i],a[s+1]=t[i+1],a[s+2]=t[i+2],a[s+3]=255,s+=o}}function xe(e,t,r,i,s,n){for(const a of t.fieldNames){const t=e.vertexAttributes.get(a),o=e.indices.get(a);if(t&&o)switch(a){case A.POSITION:{v(3===t.size);const e=s.getField(a,D);e&&pe(o,t.data,r,e,n);break}case A.NORMAL:{v(3===t.size);const e=s.getField(a,D);e&&_e(o,t.data,i,e,n);break}case A.UV0:{v(2===t.size);const e=s.getField(a,L);e&&de(o,t.data,e,n);break}case A.COLOR:{v(3===t.size||4===t.size);const e=s.getField(a,M);e&&be(o,t.data,t.size,e,n);break}case A.SYMBOLCOLOR:{v(3===t.size||4===t.size);const e=s.getField(a,M);e&&be(o,t.data,t.size,e,n);break}case A.TANGENT:{v(4===t.size);const e=s.getField(a,F);e&&ve(o,t.data,i,e,n);break}}}}class Te{constructor(e,t){this._module=e,this._loadModule=t}get(){return this._module}async reload(){return this._module=await this._loadModule(),this._module}}class Pe{constructor(e,t,r){this.release=r,t&&(this.initializeConfiguration(e,t),this._configuration=t.snapshot()),this._program=this.initializeProgram(e),this._pipeline=this.initializePipeline(e.rctx.capabilities)}destroy(){this._program=t(this._program),this._pipeline=this._configuration=null}reload(e){t(this._program),this._program=this.initializeProgram(e),this._pipeline=this.initializePipeline(e.rctx.capabilities)}get program(){return this._program}get compiled(){return this.program.isCompiled}get key(){return this._configuration.key}get configuration(){return this._configuration}bindPass(e,t){this.program.bindPass(e,t)}bindDraw(e,t){this.program.bindDraw(e,t),this.program.rebindTextures()}bindPipelineState(e,t=null,r){e.setPipelineState(this.getPipelineState(t,r))}ensureAttributeLocations(e){this.program.assertCompatibleVertexAttributeLocations(e)}get primitiveType(){return U.TRIANGLES}getPipelineState(e,t){return this._pipeline}initializeConfiguration(e,t){}}!function(e){e[e.Pass=0]="Pass",e[e.Draw=1]="Draw"}(ue||(ue={}));class Se{constructor(e,t,r){this._context=e,this._locations=r,this._textures=new Map,this._freeTextureUnits=new o({deallocator:null}),this._glProgram=e.programCache.acquire(t.generate("vertex"),t.generate("fragment"),r),this._glProgram.stop=()=>{throw new Error("Wrapped _glProgram used directly")},this.bindPass=t.generateBind(ue.Pass,this),this.bindDraw=t.generateBind(ue.Draw,this),this._fragmentUniforms=H()?t.fragmentUniforms:null}dispose(){this._glProgram.dispose()}get glName(){return this._glProgram.glName}get isCompiled(){return this._glProgram.isCompiled}setUniform1b(e,t){this._glProgram.setUniform1i(e,t?1:0)}setUniform1i(e,t){this._glProgram.setUniform1i(e,t)}setUniform1f(e,t){this._glProgram.setUniform1f(e,t)}setUniform2f(e,t,r){this._glProgram.setUniform2f(e,t,r)}setUniform2fv(e,t){this._glProgram.setUniform2fv(e,t)}setUniform3f(e,t,r,i){this._glProgram.setUniform3f(e,t,r,i)}setUniform3fv(e,t){this._glProgram.setUniform3fv(e,t)}setUniform4f(e,t,r,i,s){this._glProgram.setUniform4f(e,t,r,i,s)}setUniform4fv(e,t){this._glProgram.setUniform4fv(e,t)}setUniformMatrix3fv(e,t){this._glProgram.setUniformMatrix3fv(e,t)}setUniformMatrix4fv(e,t){this._glProgram.setUniformMatrix4fv(e,t)}setUniform1fv(e,t){this._glProgram.setUniform1fv(e,t)}setUniform1iv(e,t){this._glProgram.setUniform1iv(e,t)}setUniform2iv(e,t){this._glProgram.setUniform3iv(e,t)}setUniform3iv(e,t){this._glProgram.setUniform3iv(e,t)}setUniform4iv(e,t){this._glProgram.setUniform4iv(e,t)}assertCompatibleVertexAttributeLocations(e){e.locations!==this._locations&&console.error("VertexAttributeLocations are incompatible")}stop(){this._textures.clear(),this._freeTextureUnits.clear()}bindTexture(t,r){if(e(r)||null==r.glName){const e=this._textures.get(t);return e&&(this._context.bindTexture(null,e.unit),this._freeTextureUnit(e),this._textures.delete(t)),null}let i=this._textures.get(t);return null==i?(i=this._allocTextureUnit(r),this._textures.set(t,i)):i.texture=r,this._context.useProgram(this),this.setUniform1i(t,i.unit),this._context.bindTexture(r,i.unit),i.unit}rebindTextures(){this._context.useProgram(this),this._textures.forEach(((e,t)=>{this._context.bindTexture(e.texture,e.unit),this.setUniform1i(t,e.unit)})),r(this._fragmentUniforms)&&this._fragmentUniforms.forEach((e=>{"sampler2D"!==e.type&&"samplerCube"!==e.type||this._textures.has(e.name)||console.error(`Texture sampler ${e.name} has no bound texture`)}))}_allocTextureUnit(e){return{texture:e,unit:0===this._freeTextureUnits.length?this._textures.size:this._freeTextureUnits.pop()}}_freeTextureUnit(e){this._freeTextureUnits.push(e.unit)}}const we={func:B.LESS},Ie={func:B.ALWAYS},ye={mask:255},Ae={mask:0},Ee=e=>({function:{func:B.NOTEQUAL,ref:e,mask:e},operation:{fail:N.KEEP,zFail:N.KEEP,zPass:N.KEEP}}),Oe=e=>({function:{func:B.ALWAYS,ref:e,mask:e},operation:{fail:N.KEEP,zFail:N.KEEP,zPass:N.REPLACE}}),Fe={function:{func:B.ALWAYS,ref:a.OutlineVisualElementMask,mask:a.OutlineVisualElementMask},operation:{fail:N.KEEP,zFail:N.KEEP,zPass:N.ZERO}},Me={function:{func:B.ALWAYS,ref:a.OutlineVisualElementMask,mask:a.OutlineVisualElementMask},operation:{fail:N.KEEP,zFail:N.KEEP,zPass:N.REPLACE}},Le={function:{func:B.EQUAL,ref:a.OutlineVisualElementMask,mask:a.OutlineVisualElementMask},operation:{fail:N.KEEP,zFail:N.KEEP,zPass:N.KEEP}},De={function:{func:B.NOTEQUAL,ref:a.OutlineVisualElementMask,mask:a.OutlineVisualElementMask},operation:{fail:N.KEEP,zFail:N.KEEP,zPass:N.KEEP}};class Ue{constructor(e,t,i,s,n=null){this.name=e,this.type=t,this.arraySize=n,this.bind={[ue.Pass]:null,[ue.Draw]:null},r(i)&&r(s)&&(this.bind[i]=s)}equals(e){return this.type===e.type&&this.name===e.name&&this.arraySize===e.arraySize}}class Be extends Ue{constructor(e,t){super(e,"vec3",ue.Draw,((r,i,s)=>r.setUniform3fv(e,t(i,s))))}}class Ne extends Ue{constructor(e,t){super(e,"vec3",ue.Pass,((r,i,s)=>r.setUniform3fv(e,t(i,s))))}}class Re extends T{constructor(e){super(),this.slicePlaneLocalOrigin=e}}function ze(e,t){$e(e,t,[new Ne("slicePlaneOrigin",((e,r)=>Ve(t,e,r))),new Ne("slicePlaneBasis1",((e,r)=>ke(t,e,r,i(r.slicePlane)?.basis1))),new Ne("slicePlaneBasis2",((e,r)=>ke(t,e,r,i(r.slicePlane)?.basis2)))])}function Ce(e,t){$e(e,t,[new Be("slicePlaneOrigin",((e,r)=>Ve(t,e,r))),new Be("slicePlaneBasis1",((e,r)=>ke(t,e,r,i(r.slicePlane)?.basis1))),new Be("slicePlaneBasis2",((e,r)=>ke(t,e,r,i(r.slicePlane)?.basis2)))])}function $e(e,t,r){if(!t.hasSlicePlane){const r=P`#define rejectBySlice(_pos_) false
#define discardBySlice(_pos_) {}
#define highlightSlice(_color_, _pos_) (_color_)`;return t.hasSliceInVertexProgram&&e.vertex.code.add(r),void e.fragment.code.add(r)}e.extensions.add("GL_OES_standard_derivatives"),t.hasSliceInVertexProgram&&e.vertex.uniforms.add(r),e.fragment.uniforms.add(r);const i=P`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
};
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);
return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2
);
}
bool sliceByFactors(SliceFactors factors) {
return factors.front < 0.0
&& factors.side0 < 0.0
&& factors.side1 < 0.0
&& factors.side2 < 0.0
&& factors.side3 < 0.0;
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
#define rejectBySlice(_pos_) sliceByPlane(_pos_)
#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }`,s=P`vec4 applySliceHighlight(vec4 color, vec3 pos) {
SliceFactors factors = calculateSliceFactors(pos);
const float HIGHLIGHT_WIDTH = 1.0;
const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);
factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);
factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);
factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);
factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);
factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);
if (sliceByFactors(factors)) {
return color;
}
float highlightFactor = (1.0 - step(0.5, factors.front))
* (1.0 - step(0.5, factors.side0))
* (1.0 - step(0.5, factors.side1))
* (1.0 - step(0.5, factors.side2))
* (1.0 - step(0.5, factors.side3));
return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);
}`,n=t.hasSliceHighlight?P`
        ${s}
        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))
      `:P`#define highlightSlice(_color_, _pos_) (_color_)`;t.hasSliceInVertexProgram&&e.vertex.code.add(i),e.fragment.code.add(i),e.fragment.code.add(n)}function je(e,t,r){return e.instancedDoublePrecision?m(qe,r.camera.viewInverseTransposeMatrix[3],r.camera.viewInverseTransposeMatrix[7],r.camera.viewInverseTransposeMatrix[11]):t.slicePlaneLocalOrigin}function Ge(e,t){return r(e)?g(Ke,t.origin,e):t.origin}function He(e,t,i){return e.hasSliceTranslatedView?r(t)?O(Ye,i.camera.viewMatrix,t):i.camera.viewMatrix:null}function Ve(t,i,s){if(e(s.slicePlane))return d;const n=je(t,i,s),a=Ge(n,s.slicePlane),o=He(t,n,s);return r(o)?p(Ke,a,o):a}function ke(t,i,s,n){if(e(n)||e(s.slicePlane))return d;const a=je(t,i,s),o=Ge(a,s.slicePlane),c=He(t,a,s);return r(c)?(_(We,n,o),p(Ke,o,c),p(We,We,c),g(We,We,Ke)):n}const qe=c(),Ke=c(),We=c(),Ye=k();function Xe(e,t={hasModelTransformation:!1,linearDepth:!1}){if(t.hasModelTransformation)return t.linearDepth?void e.vertex.code.add(P`vec4 transformPositionWithDepth(mat4 proj, mat4 view, mat4 model, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * (model * vec4(pos, 1.0));
depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;
return proj * eye;
}`):void e.vertex.code.add(P`vec4 transformPosition(mat4 proj, mat4 view, mat4 model, vec3 pos) {
return proj * (view * (model * vec4(pos, 1.0)));
}`);t.linearDepth?e.vertex.code.add(P`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;
return proj * eye;
}`):e.vertex.code.add(P`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function Qe(e){e.code.add(P`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}
const vec4 RGBA_2_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgba2float(vec4 rgba) {
return dot(rgba, RGBA_2_FLOAT_FACTORS);
}`)}function Ze(e,t){e.fragment.include(Qe),t.output===le.Shadow?(e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(P`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 2.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
float result = depth + SLOPE_SCALE * m + BIAS;
return clamp(result, .0, .999999);
}
void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));
}`)):t.output===le.Depth&&e.fragment.code.add(P`void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_linearDepth);
}`)}class Je extends Ue{constructor(e,t){super(e,"vec2",ue.Pass,((r,i,s)=>r.setUniform2fv(e,t(i,s))))}}class et extends Ue{constructor(e,t){super(e,"sampler2D",ue.Pass,((r,i,s)=>r.bindTexture(e,t(i,s))))}}function tt(e,t,i){const s=[new et(e,t)];if(i){const i=e+"Size";s.push(new Je(i,((e,i)=>{const s=t(e,i);return r(s)?K(rt,s.descriptor.width,s.descriptor.height):W})))}return s}const rt=Y(),it=q(1,1,0,1),st=q(1,0,1,1);function nt(e){e.fragment.uniforms.add(new et("depthTex",((e,t)=>t.highlightDepthTexture))),e.fragment.uniforms.add(new Je("highlightViewportPixelSz",((e,t)=>t.inverseViewport))),e.fragment.constants.add("occludedHighlightFlag","vec4",it).add("unoccludedHighlightFlag","vec4",st),e.fragment.code.add(P`void outputHighlight() {
vec4 fragCoord = gl_FragCoord;
float sceneDepth = texture2D(depthTex, fragCoord.xy * highlightViewportPixelSz.xy).r;
if (fragCoord.z > sceneDepth + 5e-7) {
gl_FragColor = occludedHighlightFlag;
}
else {
gl_FragColor = unoccludedHighlightFlag;
}
}`)}function at(e){e.include(Qe),e.code.add(P`float linearDepthFromFloat(float depth, vec2 nearFar) {
return -(depth * (nearFar[1] - nearFar[0]) + nearFar[0]);
}
float linearDepthFromTexture(sampler2D depthTex, vec2 uv, vec2 nearFar) {
return linearDepthFromFloat(rgba2float(texture2D(depthTex, uv)), nearFar);
}`)}function ot(e,t){t.hasMultipassTerrain&&(e.fragment.include(at),e.fragment.uniforms.add(new et("terrainDepthTexture",((e,t)=>t.multipassTerrain.linearDepthTexture))),e.fragment.uniforms.add(new Je("nearFar",((e,t)=>t.camera.nearFar))),e.fragment.uniforms.add(new Je("inverseViewport",((e,t)=>t.inverseViewport))),e.fragment.code.add(P`
    void terrainDepthTest(vec4 fragCoord, float fragmentDepth){
      float terrainDepth = linearDepthFromTexture(terrainDepthTexture, fragCoord.xy * inverseViewport, nearFar);
      if(fragmentDepth ${t.cullAboveGround?">":"<="} terrainDepth){
        discard;
      }
    }
  `))}class ct{constructor(){this.enabled=!1,this.cullAboveGround=!1}}const lt=.1,ut=.001;function ht(e){e.code.add(P`vec4 premultiplyAlpha(vec4 v) {
return vec4(v.rgb * v.a, v.a);
}
vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);
}
vec3 hsv2rgb(vec3 c) {
vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
float rgb2v(vec3 c) {
return max(c.x, max(c.y, c.z));
}`)}class ft extends Ue{constructor(e,t){super(e,"mat4",ue.Draw,((r,i,s)=>r.setUniformMatrix4fv(e,t(i,s))))}}class dt extends Ue{constructor(e,t){super(e,"mat4",ue.Pass,((r,i,s)=>r.setUniformMatrix4fv(e,t(i,s))))}}function mt(e,t){t.instancedDoublePrecision?e.constants.add("cameraPosition","vec3",d):e.uniforms.add(new Be("cameraPosition",((e,t)=>m(_t,t.camera.viewInverseTransposeMatrix[3]-e.origin[0],t.camera.viewInverseTransposeMatrix[7]-e.origin[1],t.camera.viewInverseTransposeMatrix[11]-e.origin[2]))))}function gt(e,t){if(e.vertex.uniforms.add(new dt("proj",((e,t)=>t.camera.projectionMatrix))),t.instancedDoublePrecision){const t=(e,t)=>m(_t,t.camera.viewInverseTransposeMatrix[3],t.camera.viewInverseTransposeMatrix[7],t.camera.viewInverseTransposeMatrix[11]);e.vertex.uniforms.add(new dt("view",((e,r)=>O(pt,r.camera.viewMatrix,t(e,r)))));const r=new Ne("localOrigin",t);return e.vertex.uniforms.add(r),r}e.vertex.uniforms.add(new ft("view",((e,t)=>O(pt,t.camera.viewMatrix,e.origin))));const r=new Be("localOrigin",(e=>e.origin));return e.vertex.uniforms.add(r),r}const pt=X(),_t=c();class vt extends Ue{constructor(e,t){super(e,"vec4",ue.Pass,((r,i,s)=>r.setUniform4fv(e,t(i,s))))}}const bt=Z.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class xt{constructor(){this.includedModules=new Map}include(e,t){if(this.includedModules.has(e)){const r=this.includedModules.get(e);if(r!==t){bt.error("Trying to include shader module multiple times with different sets of options.");const t=new Set;for(const i of Object.keys(r))r[i]!==e[i]&&t.add(i);for(const i of Object.keys(e))r[i]!==e[i]&&t.add(i);t.forEach((t=>console.error(`  ${t}: current ${r[t]} new ${e[t]}`)))}}else this.includedModules.set(e,t),e(this.builder,t)}}class Tt extends xt{constructor(){super(...arguments),this.vertex=new wt,this.fragment=new wt,this.attributes=new It,this.varyings=new yt,this.extensions=new At,this.constants=new Et}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate(e){const t=this.extensions.generateSource(e),r=this.attributes.generateSource(e),i=this.varyings.generateSource(),s="vertex"===e?this.vertex:this.fragment,n=s.uniforms.generateSource(),a=s.code.generateSource(),o="vertex"===e?Ft:Ot,c=this.constants.generateSource().concat(s.constants.generateSource());return`\n${t.join("\n")}\n\n${o}\n\n${c.join("\n")}\n\n${n.join("\n")}\n\n${r.join("\n")}\n\n${i.join("\n")}\n\n${a.join("\n")}`}generateBind(e,t){const i=new Map;this.vertex.uniforms.entries.forEach((t=>{const s=t.bind[e];r(s)&&i.set(t.name,s)})),this.fragment.uniforms.entries.forEach((t=>{const s=t.bind[e];r(s)&&i.set(t.name,s)}));const s=Array.from(i.values()),n=s.length;return(e,r)=>{for(let i=0;i<n;++i)s[i](t,e,r)}}}class Pt{constructor(){this._entries=new Map}add(e){if(!Array.isArray(e))return this._add(e);for(const t of e)this._add(t)}_add(e){if(this._entries.has(e.name)&&!this._entries.get(e.name).equals(e))throw new Q(`Duplicate uniform name ${e.name} for different uniform type`);this._entries.set(e.name,e)}generateSource(){return Array.from(this._entries.values()).map((e=>r(e.arraySize)?`uniform ${e.type} ${e.name}[${e.arraySize}];`:`uniform ${e.type} ${e.name};`))}get entries(){return Array.from(this._entries.values())}}class St{constructor(){this._entries=new Array}add(e){this._entries.push(e)}generateSource(){return this._entries}}class wt extends xt{constructor(){super(...arguments),this.uniforms=new Pt,this.code=new St,this.constants=new Et}get builder(){return this}}class It{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(e){return"fragment"===e?[]:this._entries.map((e=>`attribute ${e[1]} ${e[0]};`))}}class yt{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(){return this._entries.map((e=>`varying ${e[1]} ${e[0]};`))}}class At{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const t="vertex"===e?At.ALLOWLIST_VERTEX:At.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter((e=>t.includes(e))).map((e=>`#extension ${e} : enable`))}}At.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],At.ALLOWLIST_VERTEX=[];class Et{constructor(){this._entries=new Set}add(e,t,r){let i="ERROR_CONSTRUCTOR_STRING";switch(t){case"float":i=Et._numberToFloatStr(r);break;case"int":i=Et._numberToIntStr(r);break;case"bool":i=r.toString();break;case"vec2":i=`vec2(${Et._numberToFloatStr(r[0])},                            ${Et._numberToFloatStr(r[1])})`;break;case"vec3":i=`vec3(${Et._numberToFloatStr(r[0])},                            ${Et._numberToFloatStr(r[1])},                            ${Et._numberToFloatStr(r[2])})`;break;case"vec4":i=`vec4(${Et._numberToFloatStr(r[0])},                            ${Et._numberToFloatStr(r[1])},                            ${Et._numberToFloatStr(r[2])},                            ${Et._numberToFloatStr(r[3])})`;break;case"ivec2":i=`ivec2(${Et._numberToIntStr(r[0])},                             ${Et._numberToIntStr(r[1])})`;break;case"ivec3":i=`ivec3(${Et._numberToIntStr(r[0])},                             ${Et._numberToIntStr(r[1])},                             ${Et._numberToIntStr(r[2])})`;break;case"ivec4":i=`ivec4(${Et._numberToIntStr(r[0])},                             ${Et._numberToIntStr(r[1])},                             ${Et._numberToIntStr(r[2])},                             ${Et._numberToIntStr(r[3])})`;break;case"mat2":case"mat3":case"mat4":i=`${t}(${Array.prototype.map.call(r,(e=>Et._numberToFloatStr(e))).join(", ")})`}return this._entries.add(`const ${t} ${e} = ${i};`),this}static _numberToIntStr(e){return e.toFixed(0)}static _numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}}const Ot="#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif",Ft="precision highp float;\nprecision highp sampler2D;";class Mt extends te{}J([ee({constValue:!0})],Mt.prototype,"hasSliceHighlight",void 0),J([ee({constValue:!1})],Mt.prototype,"hasSliceInVertexProgram",void 0),J([ee({constValue:!1})],Mt.prototype,"instancedDoublePrecision",void 0),J([ee({constValue:!1})],Mt.prototype,"isGround",void 0),J([ee({constValue:ue.Pass})],Mt.prototype,"pbrTextureBindType",void 0);class Lt extends Ue{constructor(e,t){super(e,"float",ue.Pass,((r,i,s)=>r.setUniform1f(e,t(i,s))))}}new re(A.POSITION,3,R.FLOAT,0,12),new re(A.POSITION,3,R.FLOAT,0,20),new re(A.UV0,2,R.FLOAT,12,20),new re(A.POSITION,3,R.FLOAT,0,32),new re(A.NORMAL,3,R.FLOAT,12,32),new re(A.UV0,2,R.FLOAT,24,32),new re(A.POSITION,3,R.FLOAT,0,16),new re(A.COLOR,4,R.UNSIGNED_BYTE,12,16);const Dt=[new re(A.POSITION,2,R.FLOAT,0,8)],Ut=[new re(A.POSITION,2,R.FLOAT,0,16),new re(A.UV0,2,R.FLOAT,8,16)];function Bt(e,t=Dt,r=S,i=-1,s=1){let n=null;return n=t===Ut?new Float32Array([i,i,0,0,s,i,1,0,i,s,0,1,s,s,1,1]):new Float32Array([i,i,s,i,i,s,s,s]),new ie(e,r,{geometry:t},{geometry:se.createVertex(e,G.STATIC_DRAW,n)})}function Nt(e,t=Dt,r=S){const i=new Float32Array([-1,-1,3,-1,-1,3]);return new ie(e,r,{geometry:t},{geometry:se.createVertex(e,G.STATIC_DRAW,i)})}function Rt(e,t=4){return new V(e,{target:z.TEXTURE_2D,pixelFormat:C.RGBA,dataType:$.UNSIGNED_BYTE,samplingMode:j.NEAREST,width:t,height:t})}function zt(e,t,r=4){const i=new Uint8Array(r*r*4);for(let e=0;e<i.length;e+=4)i[e+0]=255*t[0],i[e+1]=255*t[1],i[e+2]=255*t[2],i[e+3]=255*t[3];return new V(e,{target:z.TEXTURE_2D,pixelFormat:C.RGBA,dataType:$.UNSIGNED_BYTE,samplingMode:j.NEAREST,width:r,height:r},i)}function Ct(e){return new V(e,{target:z.TEXTURE_2D,pixelFormat:C.RGBA,dataType:$.UNSIGNED_BYTE,samplingMode:j.NEAREST,width:1,height:1},new Uint8Array([255,255,255,255]))}export{Dt as $,ct as A,ue as B,ht as C,Mt as D,Bt as E,vt as F,he as G,Ct as H,Be as I,tt as J,_e as K,be as L,dt as M,ge as N,Ze as O,Se as P,Ut as Q,Te as R,Tt as S,Xe as T,Ue as U,zt as V,Rt as W,ft as X,Ee as Y,ze as Z,Oe as _,gt as a,st as a0,Nt as a1,ne as a2,fe as a3,Re as a4,Lt as b,Pe as c,le as d,oe as e,mt as f,Ce as g,Ne as h,pe as i,Je as j,nt as k,ye as l,ot as m,Me as n,Fe as o,et as p,lt as q,we as r,ut as s,Qe as t,Ie as u,De as v,xe as w,Ae as x,Le as y,at as z};
