/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"../geometry.js";import t from"../request.js";import i from"../core/Error.js";import{JSONSupport as n}from"../core/JSONSupport.js";import{L as o}from"./Logger.js";import{i as r,u as s,a}from"./maybe.js";import{EsriPromiseMixin as l}from"../core/Promise.js";import{onAbort as c}from"../core/promiseUtils.js";import{property as f}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./ensureType.js";import{subclass as m}from"../core/accessorSupport/decorators/subclass.js";import{a as u}from"./arcgisLayerUrl.js";import{u as h}from"./commonProperties.js";import{R as p}from"../layers/support/RasterInfo.js";import d from"../layers/support/TileInfo.js";import{i as x,a as g,c as y,b as I}from"./multidimensionalUtils.js";import{g as R,a as w,p as b,d as k,b as v}from"./RawBlockCache.js";import{d as S}from"./RasterCodec.js";import{m as T,d as B,g as P}from"./pixelUtils.js";import{l as W,g as C,p as M,s as _,a as j,b as E,c as H,d as L,e as D,f as z}from"./rasterProjectionHelper.js";import{d as A,u as O}from"./vectorFieldUtils.js";import N from"../geometry/Extent.js";import F from"../geometry/Point.js";let q=class extends(l(n)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=W();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:d.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=C(e.spatialReference);return r(t)&&e.extent.width>=t/2}set url(e){this._set("url",u(e,o.getLogger(this.declaredClass)))}async open(e){throw new i("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,i,n={}){const o=n.tileInfo||this.rasterInfo.storageInfo.tileInfo,r=this.getTileExtentFromTileInfo(e,t,i,o);return this.fetchPixels(r,o.size[0],o.size[1],n)}async identify(e,t={}){const{multidimensionalDefinition:i,timeExtent:n}=t,{hasMultidimensionalTranspose:o,multidimensionalInfo:l}=this.rasterInfo;let{transposedVariableName:c}=t;const f=r(l)&&o&&(null!=n||x(i));f&&!c&&(c=r(i)&&i.length>0?i[0].variableName:l.variables[0].name,t={...t,transposedVariableName:c}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:m,extent:u}=this.rasterInfo,{datumTransformation:h}=t;let p=M(e,m,h);if(!u.intersects(p))return{location:p,value:null};if(r(this.rasterInfo.transform)){const e=this.rasterInfo.transform.inverseTransform(p);if(!this.rasterInfo.nativeExtent.intersects(e))return{location:e,value:null};p=e}let d=0;const g=c&&r(l)&&this.rasterInfo.hasMultidimensionalTranspose;if(!g)if(t.srcResolution)d=_(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel;else if(d=await this.computeBestPyramidLevelForLocation(e,t),null==d)return{location:p,value:null};const y=this.identifyPixelLocation(p,d,null,g);if(null===y)return{location:p,value:null};const{row:I,col:k,rowOffset:v,colOffset:S,blockWidth:T}=y,B=c??s(t.sliceId),P=R(this.url,B),W=`${d}/${I}/${k}`;let C=w(P,null,W);a(C)&&(C=this.fetchRawTile(d,I,k,t),b(P,null,W,C));const j=await C;if(a(j)||!j.pixels?.length)return{location:p,value:null};const E=v*T+S;return this._processIdentifyResult(j,{srcLocation:p,position:E,pyramidLevel:d,useTransposedTile:g,requestSomeSlices:f,identifyOptions:t})}async fetchPixels(e,t,i,n={}){if(e=j(e),(n=this._getRequestOptionsWithSliceId(n)).requestRawData)return this._fetchPixels(e,t,i,n);const o=C(e.spatialReference),r=E(e);if(a(o)||0===r||1===r&&this._isGlobalWrappableSource)return this._fetchPixels(e,t,i,n);if(r>=3)return{extent:e,pixelBlock:null};const s=[],{xmin:l,xmax:c}=e,f=Math.round(o/(c-l)*t),m=f-Math.round((o/2-l)/(c-l)*t);let u=0;const h=[];for(let a=0;a<=r;a++){const p=new N({xmin:0===a?l:-o/2,xmax:a===r?c-o*a:o/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),d=0===a?f-m:a===r?t-u:f;u+=d,h.push(d);const x=n.disableWrapAround&&a>0?null:this._fetchPixels(p,d,i,n);s.push(x)}const p=(await Promise.all(s)).map((e=>e?.pixelBlock));let d=null;const x={width:t,height:i};return d=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:h},n)).pixelBlock:T(p,x,{blockWidths:h}),{extent:e,srcExtent:H(e,this.rasterInfo.spatialReference,n.datumTransformation),pixelBlock:d}}async fetchRawPixels(e,t,i,n={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const o=await this._fetchRawTiles(e,t,i,n),{nativeExtent:s,nativePixelSize:a,storageInfo:l}=this.rasterInfo,c=2**e,f=a.x*c,m=a.y*c,u=new N({xmin:s.xmin+f*t.x,xmax:s.xmin+f*(t.x+i.width-1),ymin:s.ymax-m*(t.y+i.height-1),ymax:s.ymax-m*t.y,spatialReference:s.spatialReference});if(!o)return{extent:u,srcExtent:u,pixelBlock:null};const{pixelBlocks:h,mosaicSize:p}=o;if(1===h.length&&r(h[0])&&h[0].width===i.width&&h[0].height===i.height)return{extent:u,srcExtent:u,pixelBlock:o.pixelBlocks[0]};const d=e>0?l.pyramidBlockWidth:l.blockWidth,x=e>0?l.pyramidBlockHeight:l.blockHeight,g={x:t.x%d,y:t.y%x};let y;return y=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:p,destDimension:i,clipOffset:g,clipSize:i,coefs:null,sampleSpacing:null,interpolation:n.interpolation,alignmentInfo:null,blockWidths:null},n)).pixelBlock:T(h,p,{clipOffset:g,clipSize:i}),{extent:u,srcExtent:u,pixelBlock:y}}fetchRawTile(e,t,n,o){throw new i("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return H(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?S(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,i,n){const{customFetchParameters:o}=this.ioConfig,{range:r,query:s,headers:a}=i;n=n??i.retryCount??this.ioConfig.retryCount;const l=r?{Range:`bytes=${r.from}-${r.to}`}:null;try{return await t(e,{...i,query:{...s,...o},headers:{...a,...l}})}catch(t){if(n>0)return n--,this.request(e,i,n);throw t}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return a(t)||a(e)||0===e.length?null:g(e,t)}getTileExtentFromTileInfo(e,t,i,n){const o=n.lodAt(e);return this.getTileExtent({x:o.resolution,y:o.resolution},t,i,n.origin,n.spatialReference,n.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:n}=this.rasterInfo;if(!e.tileInfo){const o=[],r=e.maximumPyramidLevel||0;let s=Math.max(n.x,n.y),a=1/.0254*96*s;for(let e=0;e<=r;e++)o.push({level:r-e,resolution:s,scale:a}),s*=2,a*=2;const l=new F({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new d({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:o}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,i=512,n){const{width:o,height:r,nativeExtent:s,pixelSize:a,spatialReference:l}=e,c=new F({x:s.xmin,y:s.ymax,spatialReference:l});null==n&&(n=Math.max(0,Math.round(Math.log(Math.max(o,r))/Math.LN2-8)));const f=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[a],n);e.storageInfo=new p({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:n,blockBoundary:f})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,i,n,o,r=0,s=2){if(1===o.length&&r>0){o=[...o];let{x:e,y:t}=o[0];for(let i=0;i<r;i++)e*=s,t*=s,o.push({x:e,y:t})}const a=[],{x:l,y:c}=n;for(let n=0;n<o.length;n++){const{x:r,y:s}=o[n];a.push({minCol:Math.floor((e.xmin-l+.1*r)/t/r),maxCol:Math.floor((e.xmax-l-.1*r)/t/r),minRow:Math.floor((c-e.ymax+.1*s)/i/s),maxRow:Math.floor((c-e.ymin-.1*s)/i/s)})}return a}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:n}=this.rasterInfo.storageInfo;if(0===e)return t;if(r(i)&&i.length)return i[e-1];const o=n**e;return{x:t.x*o,y:t.y*o}}identifyPixelLocation(e,t,i,n){const{spatialReference:o,nativeExtent:s,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:l,origin:c,transposeInfo:f}=a,m=n&&r(f)?f.tileSize[0]:a.blockWidth,u=n&&r(f)?f.tileSize[1]:a.blockHeight,h=M(e,o,i);if(!s.intersects(h))return null;if(t<0||t>l)return null;const p=this.getPyramidPixelSize(t),{x:d,y:x}=p,g=(c.y-h.y)/x/u,y=(h.x-c.x)/d/m,I=Math.min(u-1,Math.floor((g-Math.floor(g))*u)),R=Math.min(m-1,Math.floor((y-Math.floor(y))*m));return{pyramidLevel:t,row:Math.floor(g),col:Math.floor(y),rowOffset:I,colOffset:R,blockWidth:m,srcLocation:h}}getTileExtent(e,t,i,n,o,r){const[s,a]=r,l=n.x+i*s*e.x,c=l+s*e.x,f=n.y-t*a*e.y,m=f-a*e.y;return new N({xmin:l,xmax:c,ymin:m,ymax:f,spatialReference:o})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,i){const n=this.rasterInfo.storageInfo.blockBoundary[e];return!n||n.maxRow<t||n.maxCol<i||n.minRow>t||n.minCol>i}async _fetchPixels(e,t,i,n={}){let o=E(e);if(o>=2)return{extent:e,pixelBlock:null};const a=this._getSourceDataInfo(e,t,i,n),{pyramidLevel:l,pyramidResolution:c,srcResolution:f,srcExtent:m,srcWidth:u,srcHeight:h}=a;if(0===u||0===h)return{extent:e,srcExtent:m,pixelBlock:null};const p=s(this.rasterInfo.transform),d="gcs-shift"===p?.type,x=r(C(e.spatialReference));!d&&x||(o=E(a.srcExtent,d));const g=this.rasterInfo.storageInfo,y={x:Math.floor((m.xmin-g.origin.x)/c.x+.1),y:Math.floor((g.origin.y-m.ymax)/c.y+.1)},I=await this._fetchRawTiles(l,y,{width:u,height:h,wrapCount:o},n);if(!I)return{extent:e,srcExtent:m,pixelBlock:null};const R=l>0?g.pyramidBlockWidth:g.blockWidth,w=l>0?g.pyramidBlockHeight:g.blockHeight,b=R===u&&w===h&&y.x%R==0&&y.y%w==0,k=new F({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),v=!e.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:S}=n;if(!v&&b&&1===I.pixelBlocks.length&&R===t&&w===i&&f.x===k.x&&f.y===k.y)return{extent:e,srcExtent:m,pixelBlock:I.pixelBlocks[0]};const M=x&&r(C(m.spatialReference)),_=n.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");_&&!this.rasterJobHandler&&await W();const j=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:I.extent,pixelSize:k.toJSON(),datumTransformation:S,rasterTransform:p,hasWrapAround:o>0||M,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:_},n):L({projectedExtent:e,srcBufferExtent:I.extent,pixelSize:k,datumTransformation:S,rasterTransform:p,hasWrapAround:o>0||M,isAdaptive:!1,includeGCSGrid:_});let H;const D=!n.requestRawData,z={rows:j.spacing[0],cols:j.spacing[1]},O=s(this._getRasterTileAlignmentInfo(l,I.extent.xmin)),{pixelBlocks:N,mosaicSize:q,isPartiallyFilled:G}=I;let J=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:N,srcMosaicSize:q,destDimension:D?{width:t,height:i}:null,coefs:D?j.coefficients:null,sampleSpacing:D?z:null,projectDirections:_,gcsGrid:_?j.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:n.interpolation,alignmentInfo:O,blockWidths:null},n);({pixelBlock:H,localNorthDirections:J}=e)}else{const e=T(N,q,{alignmentInfo:O});H=D?B(e,{width:t,height:i},j.coefficients,z,n.interpolation):e,_&&j.gcsGrid&&(J=P({width:t,height:i},j.gcsGrid),H=A(H,this.rasterInfo.dataType,J))}return n.requestRawData||_?{srcExtent:m,pixelBlock:H,transformGrid:j,localNorthDirections:J,extent:e,isPartiallyFilled:G}:{srcExtent:m,extent:e,pixelBlock:H}}async _fetchRawTiles(e,t,i,n){const{origin:o,blockBoundary:s}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:l}=this.getBlockWidthHeight(e);let{x:c,y:f}=t,{width:m,height:u,wrapCount:h}=i;const p=this._getRasterTileAlignmentInfo(e,0);n.buffer&&(c-=n.buffer.cols,f-=n.buffer.rows,m+=2*n.buffer.cols,u+=2*n.buffer.rows);let d=0,x=0,g=0;h&&r(p)&&(({worldColumnCountFromOrigin:x,originColumnOffset:g,rightPadding:d}=p),x*p.blockWidth-d>=c+m&&(d=0));const y=Math.floor(c/a),I=Math.floor(f/l),R=Math.floor((c+m+d-1)/a),w=Math.floor((f+u+d-1)/l),b=s[e];if(!b)return null;const{minRow:k,minCol:v,maxCol:S,maxRow:T}=b;if(0===h&&(w<k||R<v||I>T||y>S))return null;const B=new Array;let P=!1;const W=null==this.ioConfig.allowPartialFill?n.allowPartialFill:this.ioConfig.allowPartialFill;for(let t=I;t<=w;t++)for(let i=y;i<=R;i++){let o=i;if(!n.disableWrapAround&&h&&r(p)&&x<=i&&(o=i-x-g),t>=k&&o>=v&&T>=t&&S>=o){const i=this._fetchRawTile(e,t,o,n);W?B.push(new Promise((e=>{i.then((t=>e(t))).catch((()=>{P=!0,e(null)}))}))):B.push(i)}else B.push(null)}if(0===B.length)return null;const C=await Promise.all(B),M={height:(w-I+1)*l,width:(R-y+1)*a},{spatialReference:_}=this.rasterInfo,j=this.getPyramidPixelSize(e),{x:E,y:H}=j;return{extent:new N({xmin:o.x+y*a*E,xmax:o.x+(R+1)*a*E,ymin:o.y-(w+1)*l*H,ymax:o.y-I*l*H,spatialReference:_}),pixelBlocks:C,mosaicSize:M,isPartiallyFilled:P}}_fetchRawTile(e,t,i,n){const o=this.rasterInfo.storageInfo.blockBoundary[e];if(!o)return Promise.resolve(null);const{minRow:r,minCol:s,maxCol:l,maxRow:f}=o;if(t<r||i<s||t>f||i>l)return Promise.resolve(null);const m=R(this.url,n.sliceId),u=`${e}/${t}/${i}`;let h=w(m,n.registryId,u);if(a(h)){const o=new AbortController;h=this.fetchRawTile(e,t,i,{...n,signal:o.signal}),b(m,n.registryId,u,h,o),h.catch((()=>k(m,n.registryId,u)))}return n.signal&&c(n,(()=>{v(m,n.registryId,u)})),h}_computeMagDirValues(e){const{bandCount:t,dataType:i}=this.rasterInfo;if((2!==t||"vector-magdir"!==i)&&"vector-uv"!==i||2!==e?.length||!e[0]?.length)return null;const n=e[0].length;if("vector-magdir"===i){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[o,r]=e,s=[],a=[];for(let e=0;e<n;e++){const[t,i]=O([o[e],r[e]]);s.push(t),a.push(i)}return[s,a]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=D(this.rasterInfo)),a(this._rasterTileAlighmentInfo.pyramidsInfo)?null:{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,i,n={}){const o={datumTransformation:n.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};n.srcResolution&&(o.srcResolution=n.srcResolution,this._updateSourceDataInfo(e,o));const r=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:a,pyramidLevel:l}=o,c=s/t,f=a/i,m=l<r&&c*f>=16;if(m||l===r&&(c>8||f>8)||0===s||0===a){const s=new F({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let a=z(s,this.rasterInfo.spatialReference,e,o.datumTransformation);const u=!a||n.srcResolution&&a.x+a.y<n.srcResolution.x+n.srcResolution.y;if(m&&n.srcResolution&&u){const e=Math.round(Math.log(Math.max(c,f))/Math.LN2)-1;if(r-l+3>=e){const t=2**e;a={x:n.srcResolution.x*t,y:n.srcResolution.y*t}}}a&&(o.srcResolution=a,this._updateSourceDataInfo(e,o))}return(o.srcWidth/t>8||o.srcHeight/i>8)&&(o.srcWidth=0,o.srcHeight=0),o}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const i=this.rasterInfo.spatialReference,{srcResolution:n,datumTransformation:o}=t,{pyramidLevel:r,pyramidResolution:a,excessiveReading:l}=_(n,this.rasterInfo,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||H(e,i,o);if(null==c)return;const f=s(this.rasterInfo.transform);f&&(c=f.inverseTransform(c)),t.srcExtent=c;const m=Math.ceil((c.xmax-c.xmin)/a.x-.1),u=Math.ceil((c.ymax-c.ymin)/a.y-.1);t.pyramidLevel=r,t.pyramidResolution=a,t.srcWidth=m,t.srcHeight=u}_getRequestOptionsWithSliceId(e){return r(this.rasterInfo.multidimensionalInfo)&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:i,position:n,pyramidLevel:o,useTransposedTile:r}=t,l=e.pixels[0].length/e.width/e.height;if(e.mask&&!e.mask[n])return{location:i,value:null};const{multidimensionalInfo:c}=this.rasterInfo;if(a(c)||!r){const t=e.pixels.map((e=>e[n])),r={location:i,value:t,pyramidLevel:o},s=this._computeMagDirValues(t.map((e=>[e])));return s?.length&&(r.magdirValue=s.map((e=>e[0]))),r}let f=e.pixels.map((e=>Array.prototype.slice.call(e,n*l,n*l+l))),m=this._computeMagDirValues(f);const{requestSomeSlices:u,identifyOptions:h}=t;let p=y(c,h.transposedVariableName);if(u){const e=I(p,s(h.multidimensionalDefinition),s(h.timeExtent));f=f.map((t=>e.map((e=>t[e])))),m=m?.map((t=>e.map((e=>t[e])))),p=e.map((e=>p[e]))}return{location:i,value:null,dataSeries:p.map(((e,t)=>{const i={value:f.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition,variableName:e.multidimensionalDefinition[0].variableName,dimensionValues:{}};return m?.length&&(i.magdirValue=[m[0][t],m[1][t]]),e.multidimensionalDefinition.forEach((e=>i.dimensionValues[e.dimensionName]=e.values[0])),i})),pyramidLevel:o}}};e([f()],q.prototype,"_rasterTileAlighmentInfo",void 0),e([f({readOnly:!0})],q.prototype,"_isGlobalWrappableSource",null),e([f(h)],q.prototype,"url",null),e([f({type:String,json:{write:!0}})],q.prototype,"datasetName",void 0),e([f({type:String,json:{write:!0}})],q.prototype,"datasetFormat",void 0),e([f()],q.prototype,"rasterInfo",void 0),e([f()],q.prototype,"ioConfig",void 0),e([f()],q.prototype,"sourceJSON",void 0),q=e([m("esri.layers.support.rasterDatasets.BaseRaster")],q);const G=q;function J(e,t){if(!e||!t)return[];let i=t;t.includes("/")?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const n=[];if(t){const o=J(e,i);for(let e=0;e<o.length;e++)J(o[e],t).forEach((e=>n.push(e)));return n}const o=e.getElementsByTagNameNS("*",i);if(!o||0===o.length)return[];for(let e=0;e<o.length;e++)n.push(o[e]||o.item[e]);return n}function V(e,t){if(!e||!t)return null;let i=t;t.includes("/")?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const n=J(e,i);return n.length>0?t?V(n[0],t):n[0]:null}function $(e,t=null){const i=t?V(e,t):e;let n;return i?(n=i.textContent||i.nodeValue,n?n.trim():null):null}function U(e,t){const i=J(e,t),n=[];let o;for(let e=0;e<i.length;e++)o=i[e].textContent||i[e].nodeValue,o&&(o=o.trim(),""!==o&&n.push(o));return n}function X(e,t=null){return $(e,t)?.split(" ").map((e=>Number(e)))}function K(e,t){return U(e,t).map((e=>Number(e)))}function Q(e,t){const i=$(e,t);return Number(i)}function Y(e,t){const i=e?.nodeName?.toLowerCase(),n=t.toLowerCase();return i.slice(i.lastIndexOf(":")+1)===n}function Z(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}export{G as B,J as a,V as b,Q as c,K as d,X as e,U as f,$ as g,Z as h,Y as i};
