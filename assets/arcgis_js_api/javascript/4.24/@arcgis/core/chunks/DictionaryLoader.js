/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import t from"../Color.js";import e from"../request.js";import s from"../core/Error.js";import{L as o}from"./Logger.js";import{L as r}from"./LRUCache.js";import{i}from"./maybe.js";import{isAbortError as n}from"../core/promiseUtils.js";import{n as l}from"./string.js";import{l as m,c as a}from"./arcadeOnDemand.js";import c from"../symbols/CIMSymbol.js";import"./colorUtils.js";import"./mathUtils.js";import"./common.js";import"./ensureType.js";import"../core/lang.js";import"../config.js";import"./object.js";import"../kernel.js";import"../core/urlUtils.js";import"./MemCache.js";import"../core/scheduling.js";import"./nextTick.js";import"../geometry.js";import"../geometry/Extent.js";import"./tslib.es6.js";import"../core/accessorSupport/decorators/property.js";import"./get.js";import"./utils.js";import"./handleUtils.js";import"./metadata.js";import"../core/accessorSupport/decorators/subclass.js";import"./tracking.js";import"../geometry/Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"./ArrayPool.js";import"./watch.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"./Ellipsoid.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./extentUtils.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"./jsonMap.js";import"../geometry/support/jsonUtils.js";import"./enumeration.js";import"../layers/support/fieldUtils.js";import"../symbols/Symbol.js";const p=o.getLogger("esri.renderers.support.DictionaryLoader"),y={type:"CIMSimpleLineCallout",lineSymbol:{type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",width:.5,color:[0,0,0,255]}]}};class f{constructor(t,e,s){this.config=null,this.fieldMap=null,this.url=null,this._ongoingRequests=new Map,this._symbolCache=new r(100),this.url=t,this.config=e,this.fieldMap=s}getSymbolFields(){return this._symbolFields}async getSymbolAsync(e,s){let o;this._dictionaryPromise||(this._dictionaryPromise=this.fetchResources(s));try{o=await this._dictionaryPromise}catch(t){if(n(t))return this._dictionaryPromise=null,null}const r={};if(this.fieldMap)for(const t of this._symbolFields){const s=this.fieldMap[t];if(s&&null!=e.attributes[s]){const o=""+e.attributes[s];r[t]=o}else r[t]=""}const m=o(r,s);if(!m||"string"!=typeof m)return null;const a=l(m).toString(),c=this._symbolCache.get(a);if(c)return c.catch((()=>{this._symbolCache.pop(a)})),c;const p=m.split(";"),y=[],f=[];for(const e of p)if(e)if(e.includes("po:")){const s=e.substr(3).split("|");if(3===s.length){const e=s[0],o=s[1];let r=s[2];if("DashTemplate"===o)r=r.split(" ").map((t=>Number(t)));else if("Color"===o){const e=new t(r).toRgba();r=[e[0],e[1],e[2],255*e[3]]}else r=Number(r);f.push({primitiveName:e,propertyName:o,value:r})}}else if(e.includes("|")){for(const t of e.split("|"))if(this._itemNames.has(t)){y.push(t);break}}else this._itemNames.has(e)&&y.push(e);const u=!i(e.geometry)||!e.geometry.hasZ&&"point"===e.geometry.type,h=this._cimPartsToCIMSymbol(y,f,u,s);return this._symbolCache.put(a,h,1),h}async fetchResources(t){if(this._dictionaryPromise)return this._dictionaryPromise;if(!this.url)return void p.error("no valid URL!");const o=e(this.url+"/resources/styles/dictionary-info.json",{responseType:"json",query:{f:"json"},signal:i(t)?t.signal:null}),[{data:r}]=await Promise.all([o,m()]);if(!r)throw this._dictionaryPromise=null,new s("esri.renderers.DictionaryRenderer","Bad dictionary data!");const n=r.expression,l=r.authoringInfo;this._refSymbolUrlTemplate=this.url+"/"+r.cimRefTemplateUrl,this._itemNames=new Set(r.itemsNames),this._symbolFields=l.symbol;const c={};if(this.config){const t=this.config;for(const e in t)c[e]=t[e]}if(l.configuration)for(const t of l.configuration)c.hasOwnProperty(t.name)||(c[t.name]=t.value);const y=[];if(i(t)&&t.fields&&this.fieldMap)for(const e of this._symbolFields){const s=this.fieldMap[e],o=t.fields.filter((t=>t.name===s));o.length>0&&y.push({...o[0],name:e})}return this._dictionaryPromise=a(n,i(t)?t.spatialReference:null,y,c).then((t=>{const e={scale:0};return(s,o)=>{const r=t.repurposeFeature({geometry:null,attributes:s});return e.scale=i(o)?o.scale:void 0,t.evaluate({$feature:r,$view:e})}})).catch((t=>(p.error("Creating dictinoary expression failed:",t),null))),this._dictionaryPromise}async _cimPartsToCIMSymbol(t,e,s,o){const r=new Array(t.length);for(let e=0;e<t.length;e++)r[e]=this._getSymbolPart(t[e],o);const i=await Promise.all(r),n=this.fieldMap;for(const t of i)u(t,n);return new c({data:this._combineSymbolParts(i,e,s)})}async _getSymbolPart(t,s){if(this._ongoingRequests.has(t))return this._ongoingRequests.get(t).then((t=>t.data));const o=this._refSymbolUrlTemplate.replace(/\{itemName\}/gi,t),r=e(o,{responseType:"json",query:{f:"json"},...s});this._ongoingRequests.set(t,r);try{return(await r).data}catch(e){throw this._ongoingRequests.delete(t),e}}_combineSymbolParts(t,e,s){if(!t||0===t.length)return null;const o={...t[0]};if(t.length>1){o.symbolLayers=[];for(const e of t){const t=e;o.symbolLayers.unshift(...t.symbolLayers)}}return s&&(o.callout=y),{type:"CIMSymbolReference",symbol:o,primitiveOverrides:e}}}function u(t,e){if(!t)return;const s=t.symbolLayers;if(!s)return;let o=s.length;for(;o--;){const t=s[o];t&&!1!==t.enable&&"CIMVectorMarker"===t.type&&h(t,e)}}function h(t,e){const s=t.markerGraphics;if(s)for(const t of s){if(!t)continue;const s=t.symbol;if(s)switch(s.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":u(s,e);break;case"CIMTextSymbol":s.fieldMap=e}}}export{f as DictionaryLoader};
