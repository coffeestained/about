/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{t}from"./colorUtils2.js";import{JSONSupport as r}from"../core/JSONSupport.js";import{L as s}from"./Logger.js";import{u as a,i as o,a as n}from"./maybe.js";import{property as i}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./ensureType.js";import{subclass as l}from"../core/accessorSupport/decorators/subclass.js";import u from"../layers/support/RasterInfo.js";import{i as c,e as p,c as d,r as h,l as m,a as f}from"./pixelUtils.js";import{s as y,g as b,c as g,a as S,b as k}from"./stretchUtils.js";import x from"../layers/support/PixelBlock.js";import{c as I}from"./colorRampUtils.js";function R(e){let{altitude:t,azimuth:r}=e;const{hillshadeType:s,pixelSizePower:a,pixelSizeFactor:o,scalingType:n,isGCS:i,resolution:l}=e,u="multi-directional"===s?2*e.zFactor:e.zFactor,{x:c,y:p}=l;let d=u/(8*c),h=u/(8*p);if(i&&u>.001&&(d/=111e3,h/=111e3),"adjusted"===n)if(i){const e=111e3*c,t=111e3*p;d=(u+e**a*o)/(8*e),h=(u+t**a*o)/(8*t)}else d=(u+c**a*o)/(8*c),h=(u+p**a*o)/(8*p);let m=(90-t)*Math.PI/180,f=Math.cos(m),y=(360-r+90)*Math.PI/180,b=Math.sin(m)*Math.cos(y),g=Math.sin(m)*Math.sin(y);const S=[315,270,225,360,180,0],k=[60,60,60,60,60,90],x=new Float32Array([3,5,3,2,1,4]),I=x.reduce(((e,t)=>e+t)),R=x.map((e=>e/I)),C="multi-directional"===s?S.length:1,L=new Float32Array(6),_=new Float32Array(6),V=new Float32Array(6);if("multi-directional"===s)for(let e=0;e<C;e++)t=k[e],r=S[e],m=(90-t)*Math.PI/180,f=Math.cos(m),y=(360-r+90)*Math.PI/180,b=Math.sin(m)*Math.cos(y),g=Math.sin(m)*Math.sin(y),L[e]=f,_[e]=b,V[e]=g;else L.fill(f),_.fill(b),V.fill(g);return{resolution:l,factor:[d,h],sinZcosA:b,sinZsinA:g,cosZ:f,sinZcosAs:_,sinZsinAs:V,cosZs:L,weights:R,hillshadeType:["traditional","multi-directional"].indexOf(s)}}const C=s.getLogger("esri.renderers.support.RasterSymbolizer");let L=class extends r{constructor(e){super(e)}bind(){const{rendererJSON:e}=this;if(!e)return{success:!1};let t;switch(this.lookup={rendererJSON:{}},e.type){case"uniqueValue":t=this._updateUVRenderer(e);break;case"rasterColormap":t=this._updateColormapRenderer(e);break;case"rasterStretch":t=this._updateStretchRenderer(e);break;case"classBreaks":t=this._updateClassBreaksRenderer(e);break;case"rasterShadedRelief":t=this._updateShadedReliefRenderer(e);break;case"vectorField":t=this._updateVectorFieldRenderer();break;case"flowRenderer":t=this._updateFlowRenderer()}return t}symbolize(e){let t=e&&e.pixelBlock;if(!_(t))return t;if(e.simpleStretchParams&&"rasterStretch"===this.rendererJSON.type)return this.simpleStretch(t,e.simpleStretchParams);try{let r;switch(t.pixels.length>3&&(t=p(t,[0,1,2])),this.rendererJSON.type){case"uniqueValue":case"rasterColormap":r=this._symbolizeColormap(t);break;case"classBreaks":r=this._symbolizeClassBreaks(t);break;case"rasterStretch":r=this._symbolizeStretch(t,e.bandIds);break;case"rasterShadedRelief":{const{extent:s}=e,a=s.spatialReference.isGeographic,o={x:(s.xmax-s.xmin)/t.width,y:(s.ymax-s.ymin)/t.height};r=this._symbolizeShadedRelief(t,{isGCS:a,resolution:o});break}}return r}catch(e){return C.error("symbolize",e.message),t}}simpleStretch(e,t){if(!_(e))return e;try{return e.pixels.length>3&&(e=p(e,[0,1,2])),y(e,t)}catch(t){return C.error("symbolize",t.message),e}}generateWebGLParameters(e){if(["uniqueValue","rasterColormap","classBreaks"].includes(this.rendererJSON.type)){const{indexedColormap:e,offset:t}=this.lookup?.colormapLut||{};return{colormap:e,colormapOffset:t,type:"lut"}}const{pixelBlock:t,isGCS:r,resolution:s,bandIds:a}=e,{rendererJSON:o}=this;return"rasterStretch"===o.type?this._generateStretchWebGLParams(t,o,a):"rasterShadedRelief"===o.type?this._generateShadedReliefWebGLParams(o,r,s):"vectorField"===o.type?this._generateVectorFieldWebGLParams(o):null}_isLUTChanged(e){if(!this.lookup||!this.lookup.rendererJSON)return!0;if("colorRamp"in this.rendererJSON){const t=this.rendererJSON.colorRamp;return e?JSON.stringify(t)!==JSON.stringify(this.lookup.rendererJSON.colorRamp):(this.rendererJSON,this.lookup.rendererJSON,JSON.stringify(this.rendererJSON)!==JSON.stringify(this.lookup.rendererJSON))}return JSON.stringify(this.rendererJSON)!==JSON.stringify(this.lookup.rendererJSON)}_symbolizeColormap(e){return this._isLUTChanged()&&!this.bind().success?e:d(e,this.lookup.colormapLut)}_symbolizeClassBreaks(e){const{canUseIndexedLUT:t}=this._analyzeClassBreaks(this.rendererJSON);return this._isLUTChanged()&&!this.bind().success?e:t?d(e,this.lookup.colormapLut):h(e,this.lookup.remapLut)}_symbolizeStretch(e,t){const{rasterInfo:r}=this,{pixelType:s,bandCount:o}=r,n=this.rendererJSON,i=["u8","u16","s8","s16"].includes(s);let l,u;const{dra:c}=n,{gamma:p}=this.lookup;if("histogramEqualization"===n.stretchType){const s=c?null:this.lookup.histogramLut,a=b(n,{rasterInfo:r,pixelBlock:e,bandIds:t,returnHistogramLut:!s}),o=y(e,{...a,gamma:p});u=m(o,{lut:c?a.histogramLut:s,offset:0})}else if(i){if(c){const a=b(n,{rasterInfo:r,pixelBlock:e,bandIds:t});l=g({pixelType:s,...a,gamma:p})}else if(this._isLUTChanged()){if(!this.bind().success)return e;l=this.lookup?this.lookup.stretchLut:null}else l=this.lookup?this.lookup.stretchLut:null;if(!l)return e;o>1&&t?.length===a(e)?.pixels.length&&l?.lut.length===o&&(l={lut:t.map((e=>l.lut[e])),offset:l.offset}),u=m(e,l)}else{const s=b(n,{rasterInfo:r,pixelBlock:e,bandIds:t});u=y(e,{...s,gamma:p})}if(n.colorRamp){if(this._isLUTChanged(!0)&&!this.bind().success)return e;u=d(u,this.lookup.colormapLut)}return u}_symbolizeShadedRelief(e,t){const r=this.rendererJSON,s=function(e,t){if(!c(e))return e;const{width:r,height:s,mask:a}=e,o=new Uint8Array(r*s);a&&o.set(a);const{factor:n,sinZcosA:i,sinZsinA:l,cosZ:u,sinZcosAs:p,sinZsinAs:d,cosZs:h,weights:m}=R(t),[f,y]=n,{hillshadeType:b}=t,g=e.pixels[0],S=new Uint8Array(r*s);let k,I,C,L,_,V,T,v;for(let e=1;e<s-1;e++){const t=e*r;for(let e=1;e<r-1;e++){if(a&&!a[t+e]){S[t+e]=0;continue}let s=8;if(a&&(s=a[t-r+e-1]+a[t-r+e]+a[t-r+e+1]+a[t+e-1]+a[t+e+1]+a[t+r+e-1]+a[t+r+e]+a[t+r+e+1],s<7)){S[t+e]=0,o[t+e]=0;continue}7===s?(k=a[t-r+e-1]?g[t-r+e-1]:g[t+e],I=a[t-r+e]?g[t-r+e]:g[t+e],C=a[t-r+e+1]?g[t-r+e+1]:g[t+e],L=a[t+e-1]?g[t+e-1]:g[t+e],_=a[t+e+1]?g[t+e+1]:g[t+e],V=a[t+r+e-1]?g[t+r+e-1]:g[t+e],T=a[t+r+e]?g[t+r+e]:g[t+e],v=a[t+r+e+1]?g[t+r+e+1]:g[t+e]):(k=g[t-r+e-1],I=g[t-r+e],C=g[t-r+e+1],L=g[t+e-1],_=g[t+e+1],V=g[t+r+e-1],T=g[t+r+e],v=g[t+r+e+1]);const n=(C+_+_+v-(k+L+L+V))*f,c=(V+T+T+v-(k+I+I+C))*y,x=Math.sqrt(1+n*n+c*c);let R=0;if("traditional"===b){let e=255*(u+l*c-i*n)/x;e<0&&(e=0),R=e}else{const e=d.length;for(let t=0;t<e;t++){let e=255*(h[t]+d[t]*c-p[t]*n)/x;e<0&&(e=0),R+=e*m[t]}}S[t+e]=255&R}}for(let e=0;e<s;e++)S[e*r]=S[e*r+1],S[(e+1)*r-1]=S[(e+1)*r-2];for(let e=1;e<r-1;e++)S[e]=S[e+r],S[e+(s-1)*r]=S[e+(s-2)*r];return new x({width:r,height:s,pixels:[S],mask:a?o:null,pixelType:"u8",validPixelCount:e.validPixelCount,statistics:[{minValue:0,maxValue:255}]})}(e,{...r,...t});if(!r.colorRamp)return s;let o;if(this._isLUTChanged(!0)){if(!this.bind().success)return s;o=this.lookup?this.lookup.hsvMap:null}else o=this.lookup?this.lookup.hsvMap:null;return o?(function(e,t,r,s){if(!c(e)||!c(t))return;const{min:a,max:o}=s,n=e.pixels[0],{pixels:i,mask:l}=t,u=i[0],p=255.00001/(o-a),d=new Uint8ClampedArray(u.length),h=new Uint8ClampedArray(u.length),m=new Uint8ClampedArray(u.length),f=r.length-1;for(let e=0;e<u.length;e++){if(l&&0===l[e])continue;const t=Math.floor((u[e]-a)*p),[s,o]=r[t<0?0:t>f?f:t],i=n[e],c=i*o,y=c*(1-Math.abs(s%2-1)),b=i-c;switch(Math.floor(s)){case 0:d[e]=c+b,h[e]=y+b,m[e]=b;break;case 1:d[e]=y+b,h[e]=c+b,m[e]=b;break;case 2:d[e]=b,h[e]=c+b,m[e]=y+b;break;case 3:d[e]=b,h[e]=y+b,m[e]=c+b;break;case 4:d[e]=y+b,h[e]=b,m[e]=c+b;break;case 5:case 6:d[e]=c+b,h[e]=b,m[e]=y+b}}e.pixels=[d,h,m],e.updateStatistics()}(s,e,o,a(this.rasterInfo.statistics)?.[0]??{min:0,max:8e3}),s):s}_isVectorFieldData(){const{bandCount:e,dataType:t}=this.rasterInfo;return 2===e&&("vector-magdir"===t||"vector-uv"===t)}_updateVectorFieldRenderer(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".`}}_updateFlowRenderer(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".`}}_updateUVRenderer(e){const{bandCount:t,attributeTable:r,pixelType:s}=this.rasterInfo,a=e.field1;if(!a)return{success:!1,error:"Unsupported renderer; missing UniqueValueRenderer.field."};const o=e.defaultSymbol,i=1===t&&["u8","s8"].includes(s);if(!function(e,t){const{attributeTable:r,bandCount:s}=e;return!(n(r)||s>1||t&&null==r.fields.find((e=>e.name.toLowerCase()===t.toLowerCase())))}(this.rasterInfo,a)&&!i)return{success:!1,error:"Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table."};const l=[];if(r){const t=r.fields.find((e=>"value"===e.name.toLowerCase()));if(!t)return{success:!1,error:"Unsupported data; the data's raster attribute table does not have a value field."};r.features.forEach((r=>{const s=e.uniqueValueInfos.find((e=>String(e.value)===String(r.attributes[a])))?.symbol?.color;s?l.push([r.attributes[t.name]].concat(s)):o&&l.push([r.attributes[t.name]].concat(o.color))}))}else{if("value"!==a.toLowerCase())return{success:!1,error:'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not availalbe.'};e.uniqueValueInfos.forEach((e=>{const t=e?.symbol?.color;t?l.push([parseInt(""+e.value,10)].concat(t)):o&&l.push([parseInt(""+e.value,10)].concat(o.color))}))}if(0===l.length)return{success:!1,error:"Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table."};const u=f({colormap:l});return this.lookup={rendererJSON:e,colormapLut:u},this.canRenderInWebGL=!0,{success:!0}}_updateColormapRenderer(e){if(!function(e){const{bandCount:t,colormap:r}=e;return o(r)&&r.length&&1===t}(this.rasterInfo))return{success:!1,error:"Unsupported data; the data source does not have a colormap."};const t=e.colormapInfos.map((e=>[e.value].concat(e.color))).sort(((e,t)=>e[0]-t[0]));if(!t||0===t.length)return{success:!1,error:"Unsupported renderer; ColormapRenderer must have meaningful colormapInfos."};const r=f({colormap:t});return this.lookup={rendererJSON:e,colormapLut:r},this.canRenderInWebGL=!0,{success:!0}}_updateShadedReliefRenderer(e){if(!function(e){const{bandCount:t,dataType:r,pixelType:s}=e;return"elevation"===r||"generic"===r&&1===t&&("s16"===s||"f32"===s||"f64"===s)}(this.rasterInfo))return{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.`};if(e.colorRamp){const r=I(e.colorRamp,256,!0),s=f({colormap:r}),a=[],o=s.indexedColormap;for(let e=0;e<o.length;e+=4){const r=t({r:o[e],g:o[e+1],b:o[e+2]});a.push([r.h/60,r.s/100,255*r.v/100])}this.lookup={rendererJSON:e,colormapLut:s,hsvMap:a}}else this.lookup=null;return this.canRenderInWebGL=!0,{success:!0}}_analyzeClassBreaks(e){const{attributeTable:t,pixelType:r}=this.rasterInfo,s=o(t)?t.fields.find((e=>"value"===e.name.toLowerCase())):null,a=o(t)?t.fields.find((t=>t.name.toLowerCase()===e.field.toLowerCase())):null,n=null!=s&&null!==a;return{canUseIndexedLUT:["u8","u16","s8","s16"].includes(r)||n,tableValueField:s,tableBreakField:a}}_updateClassBreaksRenderer(e){const{attributeTable:t}=this.rasterInfo,{canUseIndexedLUT:r,tableValueField:s,tableBreakField:a}=this._analyzeClassBreaks(e),o=e.classBreakInfos;if(!o?.length)return{success:!1,error:"Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos."};const n=o.sort(((e,t)=>e.classMaxValue-t.classMaxValue)),i=n[n.length-1];let l=e.minValue;if(!r){const t=[];for(let e=0;e<n.length;e++)t.push({value:n[e].classMinValue??l,mappedColor:n[e].symbol.color}),l=n[e].classMaxValue;return t.push({value:i.classMaxValue,mappedColor:i.symbol.color}),this.lookup={rendererJSON:e,remapLut:t},this.canRenderInWebGL=!1,{success:!0}}const u=[];if(null!=s&&null!==a&&s!==a){const r=s.name,o=a.name,i=n[n.length-1],{classMaxValue:c}=i;l=e.minValue;for(const e of t.features){const t=e.attributes[r],s=e.attributes[o],a=s===c?i:s<l?null:n.find((({classMaxValue:e})=>e>s));a&&u.push([t].concat(a.symbol.color))}}else{l=Math.floor(e.minValue);for(let e=0;e<n.length;e++){const t=n[e];for(let e=l;e<t.classMaxValue;e++)u.push([e].concat(t.symbol.color));l=Math.ceil(t.classMaxValue)}i.classMaxValue===l&&u.push([i.classMaxValue].concat(i.symbol.color))}const c=f({colormap:u,fillUnspecified:!1});return this.lookup={rendererJSON:e,colormapLut:c},this.canRenderInWebGL=!0,{success:!0}}_isHistogramRequired(e){return"percentClip"===e||"histogramEqualization"===e}_isValidRasterStatistics(e){return o(e)&&e.length>0&&null!=e[0].min&&null!=e[0].max}_updateStretchRenderer(e){let{stretchType:t,dra:r}=e;if(!("none"===t||e.statistics?.length||this._isValidRasterStatistics(this.rasterInfo.statistics)||r))return{success:!1,error:"Unsupported renderer; StretchRenderer.statistics is required when dynamic range adjustment is not used."};const s=a(e.histograms||this.rasterInfo.histograms);!this._isHistogramRequired(e.stretchType)||s?.length||r||(t="minMax");const{computeGamma:o,useGamma:n,colorRamp:i}=e;let{gamma:l}=e;if(n&&o&&!l?.length){const t=e.statistics?.length?e.statistics:a(this.rasterInfo.statistics);l=S(this.rasterInfo.pixelType,t)}const u=this.rasterInfo.pixelType,c=!r&&["u8","u16","s8","s16"].includes(u);if("histogramEqualization"===t){const t=s.map((e=>k(e)));this.lookup={rendererJSON:e,histogramLut:t}}else if(c){const t=b(e,{rasterInfo:this.rasterInfo}),r=g({pixelType:u,...t,gamma:n?l:null});this.lookup={rendererJSON:e,stretchLut:r}}if(i){const t=I(i,256,!0);this.lookup||(this.lookup={rendererJSON:e}),this.lookup.colormapLut=f({colormap:t}),this.lookup.rendererJSON=e}return this.lookup.gamma=n&&l?.length?l:null,this.canRenderInWebGL=!0,{success:!0}}_generateStretchWebGLParams(e,t,r){let s=null,a=null;const n=this.lookup&&this.lookup.colormapLut;t.colorRamp&&n&&(s=n.indexedColormap,a=n.offset),"histogramEqualization"===t.stretchType&&(t={...t,stretchType:"minMax"});const{gamma:i}=this.lookup,l=!!(t.useGamma&&i&&i.some((e=>1!==e))),{minCutOff:u,maxCutOff:c,outMin:p,outMax:d}=b(t,{rasterInfo:this.rasterInfo,pixelBlock:e,bandIds:r});let h=0;o(e)&&(h=e.getPlaneCount(),2===h&&((e=e.clone()).statistics=[e.statistics[0]],e.pixels=[e.pixels[0]]));const m=Math.min(3,r?.length||h||this.rasterInfo.bandCount),f=new Float32Array(m),y=s||l?1:255;let g;for(g=0;g<m;g++)f[g]=(d-p)/(c[g]-u[g])/y;const S=new Float32Array(m);if(l)for(g=0;g<m;g++)i[g]>1?i[g]>2?S[g]=6.5+(i[g]-2)**2.5:S[g]=6.5+100*(2-i[g])**4:S[g]=1;return{bandCount:m,outMin:p/y,outMax:d/y,minCutOff:u,maxCutOff:c,factor:f,useGamma:l,gamma:l?i:[1,1,1],gammaCorrection:l?S:[1,1,1],colormap:s,colormapOffset:a,stretchType:t.stretchType,type:"stretch"}}_generateShadedReliefWebGLParams(e,t,r){let s=null,o=null;const n=this.lookup&&this.lookup.colormapLut;e.colorRamp&&n&&(s=n.indexedColormap,o=n.offset);const i=R({...e,isGCS:t,resolution:r}),l=a(this.rasterInfo.statistics)?.[0];return{...i,minValue:l?.min??0,maxValue:l?.max??8e3,hillshadeType:"traditional"===e.hillshadeType?0:1,type:"hillshade",colormap:s,colormapOffset:o}}_generateVectorFieldWebGLParams(e){const{style:t,inputUnit:r,outputUnit:s,visualVariables:a,symbolTileSize:n,flowRepresentation:i}=e;let l;const u=this.rasterInfo.statistics?.[0].min??0,c=this.rasterInfo.statistics?.[0].max??50,p=a?.find((e=>"sizeInfo"===e.type))??{type:"sizeInfo",field:"Magnitude",maxDataValue:c,maxSize:.8*n,minDataValue:u,minSize:.2*n},d=p.minDataValue??u,h=p.maxDataValue??c,m=o(p.maxSize)&&o(p.minSize)?[p.minSize/n,p.maxSize/n]:[.2,.8];if("wind_speed"===t){const e=(m[0]+m[1])/2;m[0]=m[1]=e}const f=o(d)&&o(h)?[d,h]:null;if("classified_arrow"===t)if(o(d)&&o(h)&&o(p)){l=[];const e=(p.maxDataValue-p.minDataValue)/5;for(let t=0;t<6;t++)l.push(p.minDataValue+e*t)}else l=[0,1e-6,3.5,7,10.5,14];const y="flow_to"===i==("ocean_current_kn"===t||"ocean_current_m"===t)?0:Math.PI,b=a?.find((e=>"rotationInfo"===e.type));return{breakValues:l,dataRange:f,inputUnit:r,outputUnit:s,symbolTileSize:n,symbolPercentRange:m,style:t||"single_arrow",rotation:y,rotationType:this.rasterInfo.storageInfo?.tileInfo&&"vector-uv"===this.rasterInfo.dataType?"geographic":b?.rotationType||e.rotationType,type:"vectorField"}}};function _(e){return c(e)&&0!==e.validPixelCount}e([i({json:{write:!0}})],L.prototype,"rendererJSON",void 0),e([i({type:u,json:{write:!0}})],L.prototype,"rasterInfo",void 0),e([i({json:{write:!0}})],L.prototype,"lookup",void 0),e([i()],L.prototype,"canRenderInWebGL",void 0),L=e([l("esri.renderers.support.RasterSymbolizer")],L);const V=L;export{V as R};
