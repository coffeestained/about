/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{g as e,j as t,k as s}from"../core/lang.js";import{L as i}from"./Logger.js";import{i as r,a as n,j as a}from"./maybe.js";import{c as o}from"./Texture.js";import{C as c}from"./context-util.js";import{l as u,R as _,U as f,D as h,j as b,k as l,m as E,a as R}from"./enums.js";const A=i.getLogger("esri.views.webgl.BufferObject");class d{constructor(e,t,s,i){this._context=e,this.bufferType=t,this.usage=s,this._glName=null,this._size=-1,this._indexType=void 0,e.instanceCounter.increment(_.BufferObject,this),this._glName=this._context.gl.createBuffer(),o(this._context.gl),i&&this.setData(i)}static createIndex(e,t,s){return new d(e,u.ELEMENT_ARRAY_BUFFER,t,s)}static createVertex(e,t,s){return new d(e,u.ARRAY_BUFFER,t,s)}static createUniform(e,t,s){if(e.type!==c.WEBGL2)throw new Error("Uniform buffers are supported in WebGL2 only!");return new d(e,u.UNIFORM_BUFFER,t,s)}static createPixelPack(e,t=f.STREAM_READ,s){if(e.type!==c.WEBGL2)throw new Error("Pixel pack buffers are supported in WebGL2 only!");const i=new d(e,u.PIXEL_PACK_BUFFER,t);return s&&i.setSize(s),i}static createPixelUnpack(e,t=f.STREAM_DRAW,s){if(e.type!==c.WEBGL2)throw new Error("Pixel unpack buffers are supported in WebGL2 only!");return new d(e,u.PIXEL_UNPACK_BUFFER,t,s)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get byteSize(){return this.bufferType===u.ELEMENT_ARRAY_BUFFER?this._indexType===h.UNSIGNED_INT?4*this._size:2*this._size:this._size}get _isVAOAware(){return this.bufferType===u.ELEMENT_ARRAY_BUFFER||this.bufferType===u.ARRAY_BUFFER}dispose(){this._context?.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(_.BufferObject,this),this._context=null):this._glName&&A.warn("Leaked WebGL buffer object")}setSize(e,t=null){if(e<=0&&A.error("Buffer size needs to be positive!"),this.bufferType===u.ELEMENT_ARRAY_BUFFER&&r(t))switch(this._indexType=t,t){case h.UNSIGNED_SHORT:e*=2;break;case h.UNSIGNED_INT:e*=4}this._setBufferData(e)}setData(s){if(!s)return;let i=s.byteLength;this.bufferType===u.ELEMENT_ARRAY_BUFFER&&(e(s)&&(i/=2,this._indexType=h.UNSIGNED_SHORT),t(s)&&(i/=4,this._indexType=h.UNSIGNED_INT)),this._setBufferData(i,s)}_setBufferData(e,t=null){this._size=e;const s=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const i=this._context.gl;r(t)?i.bufferData(this.bufferType,t,this.usage):i.bufferData(this.bufferType,e,this.usage),o(i),this._isVAOAware&&this._context.bindVAO(s)}setSubData(s,i=0,r=0,n=s.byteLength){if(!s)return;(i<0||i>=this._size)&&A.error("offset is out of range!");let a=i,c=r,_=n,f=s.byteLength;this.bufferType===u.ELEMENT_ARRAY_BUFFER&&(e(s)?(f/=2,a*=2,c*=2,_*=2):t(s)&&(f/=4,a*=4,c*=4,_*=4)),void 0===n&&(n=f-1),r>=n&&A.error("end must be bigger than start!"),i+r-n>this._size&&A.error("An attempt to write beyond the end of the buffer!");const h=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const b=this._context.gl,l=ArrayBuffer.isView(s)?s.buffer:s,E=0===c&&_===s.byteLength?l:l.slice(c,_);b.bufferSubData(this.bufferType,a,E),o(b),this._isVAOAware&&this._context.bindVAO(h)}setSubDataFromView(e,t,s,i){if(!e)return;(t<0||t>=this._size)&&A.error("offset is out of range!"),s>=i&&A.error("end must be bigger than start!"),t+s-i>this._size&&A.error("An attempt to write beyond the end of the buffer!");const r=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const n=this._context.gl;if(this._context.type===c.WEBGL2)n.bufferSubData(this.bufferType,t*e.BYTES_PER_ELEMENT,e,s,i-s);else{const r=0===s&&i===e.length?e:e.subarray(s,i);n.bufferSubData(this.bufferType,t*e.BYTES_PER_ELEMENT,r)}o(n),this._isVAOAware&&this._context.bindVAO(r)}getSubData(e,t=0,i,r){if(this._context.type!==c.WEBGL2)return void A.error("Get buffer subdata is supported in WebGL2 only!");if(i<0||r<0)return void A.error("Problem getting subdata: offset and length were less than zero!");const n=s(e)?e.BYTES_PER_ELEMENT:1;if(n*((i??0)+(r??0))>e.byteLength)return void A.error("Problem getting subdata: offset and length exceeded destination size!");t+n*(r??0)>this.byteSize&&A.warn("Potential problem getting subdata: requested data exceeds buffer size!");const a=this._context.gl;this._context.bindBuffer(this,u.COPY_READ_BUFFER),a.getBufferSubData(u.COPY_READ_BUFFER,t,e,i,r),this._context.unbindBuffer(u.COPY_READ_BUFFER)}async getSubDataAsync(e,t=0,s,i){this._context.type===c.WEBGL2?(await this._context.clientWaitAsync(),this.getSubData(e,t,s,i)):A.error("Get buffer subdata is supported in WebGL2 only!")}}function x(e){const t=e.gl;switch(t.getError()){case t.NO_ERROR:return null;case t.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case t.INVALID_VALUE:return"A numeric argument is out of range";case t.INVALID_OPERATION:return"The specified command is not allowed for the current state";case t.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case t.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case t.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function B(e,t){return e.vertexBuffers[t].size/e.layout[t][0].stride}function g(e,t,s,i,r=0){const n=e.gl,a=e.capabilities.instancing;e.bindBuffer(s);for(const e of i){const s=t.get(e.name);void 0===s&&console.error(`There is no location for vertex attribute '${e.name}' defined.`);const i=r*e.stride;if(e.count<=4)n.vertexAttribPointer(s,e.count,e.type,e.normalized,e.stride,e.offset+i),n.enableVertexAttribArray(s),e.divisor>0&&a&&a.vertexAttribDivisor(s,e.divisor);else if(9===e.count)for(let t=0;t<3;t++)n.vertexAttribPointer(s+t,3,e.type,e.normalized,e.stride,e.offset+12*t+i),n.enableVertexAttribArray(s+t),e.divisor>0&&a&&a.vertexAttribDivisor(s+t,e.divisor);else if(16===e.count)for(let t=0;t<4;t++)n.vertexAttribPointer(s+t,4,e.type,e.normalized,e.stride,e.offset+16*t+i),n.enableVertexAttribArray(s+t),e.divisor>0&&a&&a.vertexAttribDivisor(s+t,e.divisor);else console.error("Unsupported vertex attribute element count: "+e.count)}}function T(e,t,s,i){const r=e.gl,n=e.capabilities.instancing;e.bindBuffer(s);for(const e of i){const s=t.get(e.name);if(e.count<=4)r.disableVertexAttribArray(s),e.divisor&&e.divisor>0&&n&&n.vertexAttribDivisor(s,0);else if(9===e.count)for(let t=0;t<3;t++)r.disableVertexAttribArray(s+t),e.divisor&&e.divisor>0&&n&&n.vertexAttribDivisor(s+t,0);else if(16===e.count)for(let t=0;t<4;t++)r.disableVertexAttribArray(s+t),e.divisor&&e.divisor>0&&n&&n.vertexAttribDivisor(s+t,0);else console.error("Unsupported vertex attribute element count: "+e.count)}e.unbindBuffer(u.ARRAY_BUFFER)}function G(e){switch(e){case R.ALPHA:case R.LUMINANCE:case R.RED:case R.RED_INTEGER:case l.R8:case l.R8I:case l.R8UI:case l.R8_SNORM:case E.STENCIL_INDEX8:return 1;case R.LUMINANCE_ALPHA:case R.RG:case R.RG_INTEGER:case l.RGBA4:case l.R16F:case l.R16I:case l.R16UI:case l.RG8:case l.RG8I:case l.RG8UI:case l.RG8_SNORM:case l.RGB565:case l.RGB5_A1:case E.DEPTH_COMPONENT16:return 2;case R.DEPTH_COMPONENT:case R.RGB:case R.RGB_INTEGER:case l.RGB8:case l.RGB8I:case l.RGB8UI:case l.RGB8_SNORM:case l.SRGB8:case E.DEPTH_COMPONENT24:return 3;case R.DEPTH_STENCIL:case R.RGBA:case R.RGBA_INTEGER:case l.RGBA8:case l.R32F:case l.R11F_G11F_B10F:case l.RG16F:case l.R32I:case l.R32UI:case l.RG16I:case l.RG16UI:case l.RGBA8I:case l.RGBA8UI:case l.RGBA8_SNORM:case l.SRGB8_ALPHA8:case l.RGB9_E5:case l.RGB10_A2UI:case l.RGB10_A2:case E.DEPTH_STENCIL:case E.DEPTH_COMPONENT32F:case E.DEPTH24_STENCIL8:return 4;case E.DEPTH32F_STENCIL8:return 5;case l.RGB16F:case l.RGB16I:case l.RGB16UI:return 6;case l.RG32F:case l.RG32I:case l.RG32UI:case l.RGBA16F:case l.RGBA16I:case l.RGBA16UI:return 8;case l.RGB32F:case l.RGB32I:case l.RGB32UI:return 12;case l.RGBA32F:case l.RGBA32I:case l.RGBA32UI:return 16;case b.COMPRESSED_RGB_S3TC_DXT1_EXT:case b.COMPRESSED_RGBA_S3TC_DXT1_EXT:return.5;case b.COMPRESSED_RGBA_S3TC_DXT3_EXT:case b.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case b.COMPRESSED_R11_EAC:case b.COMPRESSED_SIGNED_R11_EAC:case b.COMPRESSED_RGB8_ETC2:case b.COMPRESSED_SRGB8_ETC2:case b.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case b.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return.5;case b.COMPRESSED_RG11_EAC:case b.COMPRESSED_SIGNED_RG11_EAC:case b.COMPRESSED_RGBA8_ETC2_EAC:case b.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}function N(e){if(n(e))return 0;if("descriptor"in e)return e.glName?N(e.descriptor):0;const t=e.internalFormat||"pixelFormat"in e&&e.pixelFormat;if(!t)return 0;const s="hasMipmap"in e&&e.hasMipmap?1.3:1,i=e.width*e.height;return G(t)*i*s}const p=i.getLogger("esri.views.webgl.VertexArrayObject");class y{constructor(e,t,s,i,r=null){this._context=e,this._locations=t,this._layout=s,this._buffers=i,this._indexBuffer=r,this._glName=null,this._initialized=!1,e.instanceCounter.increment(_.VertexArrayObject,this)}get glName(){return this._glName}get context(){return this._context}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}get size(){return Object.keys(this._buffers).reduce(((e,t)=>e+this._buffers[t].size),r(this._indexBuffer)?this._indexBuffer.size:0)}get layout(){return this._layout}get locations(){return this._locations}dispose(e=!0){if(this._context){if(this._glName){const e=this._context?.capabilities?.vao;e?(e.deleteVertexArray(this._glName),this._glName=null):p.warn("Leaked WebGL VAO")}if(this._context.getBoundVAO()===this&&this._context.bindVAO(null),e){for(const e in this._buffers)this._buffers[e].dispose(),delete this._buffers[e];this._indexBuffer=a(this._indexBuffer)}this._context.instanceCounter.decrement(_.VertexArrayObject,this),this._context=null}else(this._glName||e&&Object.getOwnPropertyNames(this._buffers).length>0)&&p.warn("Leaked WebGL VAO")}initialize(){if(this._initialized)return;const e=this._context.capabilities.vao;if(e){const t=e.createVertexArray();e.bindVertexArray(t),this._bindLayout(),e.bindVertexArray(null),this._glName=t}this._initialized=!0}bind(){this.initialize();const e=this._context.capabilities.vao;e?e.bindVertexArray(this.glName):(this._context.bindVAO(null),this._bindLayout())}_bindLayout(){const{_buffers:e,_layout:t,_indexBuffer:s}=this;e||p.error("Vertex buffer dictionary is empty!");const i=this._context.gl;for(const s in e){const i=e[s];i||p.error("Vertex buffer is uninitialized!");const r=t[s];r||p.error("Vertex element descriptor is empty!"),g(this._context,this._locations,i,r)}r(s)&&(this._context.capabilities.vao?i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,s.glName):this._context.bindBuffer(s))}unbind(){this.initialize();const e=this._context.capabilities.vao;e?e.bindVertexArray(null):this._unbindLayout()}_unbindLayout(){const{_buffers:e,_layout:t}=this;e||p.error("Vertex buffer dictionary is empty!");for(const s in e){const i=e[s];i||p.error("Vertex buffer is uninitialized!");const r=t[s];T(this._context,this._locations,i,r)}r(this._indexBuffer)&&this._context.unbindBuffer(this._indexBuffer.bufferType)}}export{d as B,y as V,G as a,g as b,x as c,N as g,T as u,B as v};
