/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import e from"../request.js";import r from"../core/Error.js";import{a,i as t}from"./maybe.js";import{getFilename as s,urlToObject as n}from"../core/urlUtils.js";import{p as l,f as o}from"./arcgisLayerUrl.js";import{l as i}from"./lazyLayerLoader.js";import"../config.js";import"../core/lang.js";import"./object.js";import"../kernel.js";import"./Logger.js";import"./string.js";import"../core/promiseUtils.js";import"./persistableUrlUtils.js";async function u(e){const u=e.properties?.customParameters,p=await async function(e,u){let y=l(e);if(a(y)&&(y=await async function(e,r){const a=await f(e,{customParameters:r});let l=null,i=null;const u=a.type;if("Feature Layer"===u||"Table"===u?(l="FeatureServer",i=a.id):"indexedVector"===u?l="VectorTileServer":a.hasOwnProperty("mapName")?l="MapServer":a.hasOwnProperty("bandCount")&&a.hasOwnProperty("pixelSizeX")?l="ImageServer":a.hasOwnProperty("maxRecordCount")&&a.hasOwnProperty("allowGeometryUpdates")?l="FeatureServer":a.hasOwnProperty("streamUrls")?l="StreamServer":c(a)?(l="SceneServer",i=a.id):a.hasOwnProperty("layers")&&c(a.layers?.[0])&&(l="SceneServer"),!l)return null;const y=null!=i?o(e):null;return{title:t(y)&&a.name||s(e),serverType:l,sublayer:i,url:{path:t(y)?y.serviceUrl:n(e).path}}}(e,u)),a(y))throw new r("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:e});const{serverType:p,sublayer:d}=y;let I;const b={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(p){case"MapServer":I=null!=d?"FeatureLayer":async function(e,r){return(await f(e,{customParameters:r})).tileInfo}(e,u).then((e=>e?"TileLayer":"MapImageLayer"));break;case"ImageServer":I=f(e,{customParameters:u}).then((e=>{const r=e.tileInfo&&e.tileInfo.format;return e.tileInfo?"LERC"!==r?.toUpperCase()||e.cacheType&&"elevation"!==e.cacheType.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer"}));break;case"SceneServer":I=f(y.url.path,{customParameters:u}).then((e=>{if(e){if("Voxel"===e?.layerType)return"VoxelLayer";if(e?.layers&&Array.isArray(e.layers)&&e.layers.length>0){const r={Point:"SceneLayer","3DObject":"SceneLayer",IntegratedMesh:"IntegratedMeshLayer",PointCloud:"PointCloudLayer",Building:"BuildingSceneLayer"},a=e.layers[0]?.layerType;if(null!=r[a])return r[a]}}return"SceneLayer"}));break;default:I=b[p]}const S="FeatureServer"===p,w={parsedUrl:y,Constructor:null,layerOrTableId:S?d:null,sublayerIds:null,tableIds:null},h=await I;if({FeatureLayer:!0,SceneLayer:!0}[h]&&null==d){const r=await async function(e,r,a){let t,s=!1;if("FeatureServer"===r){const r=await m(e,{customParameters:a});s=!!r.layersJSON,t=r.layersJSON||r.serviceJSON}else t=await f(e,{customParameters:a});const n=t?.layers,l=t?.tables;return{layerIds:n?.map((e=>e.id)).reverse()||[],tableIds:l?.map((e=>e.id)).reverse()||[],layerInfos:s?n:[],tableInfos:s?l:[]}}(e,p,u);S&&(w.sublayerInfos=r.layerInfos,w.tableInfos=r.tableInfos),1!==r.layerIds.length+r.tableIds.length?(w.sublayerIds=r.layerIds,w.tableIds=r.tableIds):S&&(w.layerOrTableId=r.layerIds[0]??r.tableIds[0],w.sourceJSON=r.layerInfos[0]??r.tableInfos[0])}return w.Constructor=await async function(e){return(0,i[e])()}(h),w}(e.url,u),d={...e.properties,url:e.url};if(!p.sublayerIds)return null!=p.layerOrTableId&&(d.layerId=p.layerOrTableId,d.sourceJSON=p.sourceJSON),new p.Constructor(d);const I=new(0,(await import("../layers/GroupLayer.js")).default)({title:p.parsedUrl.title});return function(e,r,a){function s(e,s){const n={...a,layerId:e,sublayerTitleMode:"service-name"};return t(s)&&(n.sourceJSON=s),new r.Constructor(n)}r.sublayerIds.forEach((a=>{const t=s(a,y(r.sublayerInfos,a));e.add(t)})),r.tableIds.forEach((a=>{const t=s(a,y(r.tableInfos,a));e.tables.add(t)}))}(I,p,d),I}function y(e,r){return e?e.find((e=>e.id===r)):null}function c(e){return e?.hasOwnProperty("store")&&e.hasOwnProperty("id")&&"number"==typeof e.id}function p(e){return!e.type||"Feature Layer"===e.type}async function m(e,r){let a=await f(e,r);a=a||{},a.layers=a.layers?.filter(p)||[];const t={serviceJSON:a};if(a.currentVersion<10.5)return t;const s=await f(e+"/layers",r);return t.layersJSON={layers:s?.layers?.filter(p)||[],tables:s?.tables||[]},t}async function f(r,a){return(await e(r,{responseType:"json",query:{f:"json",...a?.customParameters,token:a?.apiKey}})).data}export{m as fetchFeatureService,u as fromUrl};
