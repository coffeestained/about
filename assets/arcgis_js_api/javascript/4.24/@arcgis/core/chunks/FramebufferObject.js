/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{L as t}from"./Logger.js";import{i as e,a as i}from"./maybe.js";import{g as r,B as s}from"./VertexArrayObject.js";import{T as h,w as n,a as c}from"./Texture.js";import{C as o}from"./context-util.js";import{R as a,n as _,e as l,a as E,b as T,o as d,m as u,p as f,T as m,U as R,l as p,d as A,c as g,f as F,k as x}from"./enums.js";class b{constructor(t,e){this._context=t,this._desc=e,this.type="renderbuffer",this._context.instanceCounter.increment(a.Renderbuffer,this);const i=this._context.gl;this.glName=i.createRenderbuffer(),this._context.bindRenderbuffer(this);const{width:r,height:s,internalFormat:h,multisampled:n}=e;if(n){if(this._context.type!==o.WEBGL2)throw new Error("Multisampled renderbuffers are not supported in WebGL1!");i.renderbufferStorageMultisample(i.RENDERBUFFER,this.samples,h,r,s)}else i.renderbufferStorage(i.RENDERBUFFER,h,r,s)}get descriptor(){return this._desc}get samples(){const t=this._desc.samples,e=this._context.parameters.maxSamples;return t?Math.min(t,e):e}resize(t,e){const i=this._desc;if(i.width===t&&i.height===e)return;i.width=t,i.height=e;const r=this._context.gl;this._context.bindRenderbuffer(this),i.multisampled?r.renderbufferStorageMultisample(r.RENDERBUFFER,this.samples,i.internalFormat,i.width,i.height):r.renderbufferStorage(r.RENDERBUFFER,i.internalFormat,i.width,i.height)}dispose(){this._context&&(this._context.gl.deleteRenderbuffer(this.glName),this._context.instanceCounter.decrement(a.Renderbuffer,this),this._context=null)}}const N=t.getLogger("esri.views.webgl.FrameBufferObject");class D{constructor(t,i,r=null,s=null){if(this._context=t,this._glName=null,this._depthAttachment=null,this._stencilAttachment=null,this._colorAttachments=new Map,this._initialized=!1,this._desc={...i},t.instanceCounter.increment(a.FramebufferObject,this),e(r)){Array.isArray(r)||(r=[r]);for(let t=0;t<r.length;++t){const e=r[t],i=_.COLOR_ATTACHMENT0+t;let s;U(e)?(C(e)?(s=e.descriptor,this._colorAttachments.set(i,e)):(s=e,this._colorAttachments.set(i,new h(this._context,s))),B(s,this._desc)):(S(e)?(s=e.descriptor,this._colorAttachments.set(i,e)):(s=e,this._colorAttachments.set(i,new b(this._context,s))),M(s,this._desc)),this._validateColorAttachmentPoint(i)}}if(e(s)){let t,e;if(U(s))this._context.capabilities.depthTexture||console.error("Setting the depth/stencil texture as an attachment requires WEBGL_depth_texture or WebGL2"),C(s)?(e=s.descriptor,this._depthStencilTexture=s):(e=s,this._depthStencilTexture=new h(this._context,e)),B(e,this._desc);else{S(s)?(e=s.descriptor,t=s):(e=s,t=new b(this._context,e));const i=this._desc.depthStencilTarget??l.DEPTH_STENCIL_RENDER_BUFFER;i===l.STENCIL_RENDER_BUFFER?this._stencilAttachment=t:i===l.DEPTH_RENDER_BUFFER||i===l.DEPTH_STENCIL_RENDER_BUFFER?this._depthAttachment=t:console.error('If a Renderbuffer is provided, "depthStencilTarget" must be one of STENCIL_RENDER_BUFFER, DEPTH_RENDER_BUFFER or DEPTH_STENCIL_RENDER_BUFFER'),M(e,this._desc)}}}dispose(){if(!this._desc)return;const t=this._context.getBoundFramebufferObject();this._disposeColorAttachments(),this._disposeDepthStencilAttachments(),this._glName&&(this._context.gl.deleteFramebuffer(this._glName),this._glName=null),this._context.bindFramebuffer(t),this._context.instanceCounter.decrement(a.FramebufferObject,this),this._desc=null}get glName(){return this._glName}get descriptor(){return this._desc}get colorTexture(){const t=this._colorAttachments.get(_.COLOR_ATTACHMENT0);return t&&C(t)?t:null}get colorAttachment(){return this._colorAttachments.get(_.COLOR_ATTACHMENT0)}get depthStencilAttachment(){return this._depthStencilTexture||this._depthAttachment||this._stencilAttachment}get depthStencilTexture(){return this._depthStencilTexture}get width(){return this._desc.width}get height(){return this._desc.height}get gpuMemoryUsage(){return[...this._colorAttachments].reduce(((t,[e,i])=>t+r(i)),0)+r(this.depthStencilAttachment)}getColorTexture(t){const e=this._colorAttachments.get(t);return e&&C(e)?e:null}attachColorTexture(t,e=_.COLOR_ATTACHMENT0){t&&(this._validateColorAttachmentPoint(e),B(t.descriptor,this._desc),this._disposeColorAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,e)),this._colorAttachments.set(e,t))}detachColorTexture(t=_.COLOR_ATTACHMENT0){const e=this._colorAttachments.get(t);if(C(e)){const i=e;return this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t)),this._colorAttachments.delete(t),i}}setColorTextureTarget(t,e=_.COLOR_ATTACHMENT0){const i=this._colorAttachments.get(e);C(i)&&this._framebufferTexture2D(i.glName,e,t)}attachDepthStencilTexture(t){if(i(t))return;const e=t.descriptor;e.pixelFormat!==E.DEPTH_STENCIL&&console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"),e.dataType!==T.UNSIGNED_INT_24_8&&console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"),this._context.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"),B(e,this._desc),this._desc.depthStencilTarget&&this._desc.depthStencilTarget!==l.DEPTH_STENCIL_TEXTURE&&(this._desc.depthStencilTarget=l.DEPTH_STENCIL_TEXTURE),this._disposeDepthStencilAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,d)),this._depthStencilTexture=t}detachDepthStencilTexture(){const t=this._depthStencilTexture;return t&&this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,d)),this._depthStencilTexture=null,t}attachDepthStencilBuffer(t){if(i(t))return;const e=t.descriptor;if(e.internalFormat!==u.DEPTH_STENCIL&&e.internalFormat!==u.DEPTH_COMPONENT16&&console.error("Depth/Stencil buffer must have correct internalFormat"),M(e,this._desc),this._disposeDepthStencilAttachments(),this._desc.depthStencilTarget=e.internalFormat===u.DEPTH_STENCIL?l.DEPTH_STENCIL_RENDER_BUFFER:l.DEPTH_RENDER_BUFFER,this._initialized){this._context.bindFramebuffer(this);const e=this._context.gl,i=this._desc.depthStencilTarget===l.DEPTH_RENDER_BUFFER?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT;e.framebufferRenderbuffer(f.FRAMEBUFFER,i,e.RENDERBUFFER,t.glName)}this._depthAttachment=t}detachDepthStencilBuffer(){const t=this._context.gl,e=this._depthAttachment;if(e&&this._initialized){this._context.bindFramebuffer(this);const e=this._desc.depthStencilTarget===l.DEPTH_RENDER_BUFFER?t.DEPTH_ATTACHMENT:t.DEPTH_STENCIL_ATTACHMENT;t.framebufferRenderbuffer(f.FRAMEBUFFER,e,t.RENDERBUFFER,null)}return this._depthAttachment=null,e}detachAll(){this._colorAttachments.forEach(((t,e)=>this._detachColorAttachment(e))),this.detachDepthStencilBuffer(),this.detachDepthStencilTexture()}copyToTexture(t,e,i,r,s,n,c){(t<0||e<0||s<0||n<0)&&console.error("Offsets cannot be negative!"),(i<=0||r<=0)&&console.error("Copy width and height must be greater than zero!");const o=this._desc,a=c.descriptor;c.descriptor.target!==m.TEXTURE_2D&&console.error("Texture target must be TEXTURE_2D!"),(t+i>o.width||e+r>o.height||s+i>a.width||n+r>a.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");const _=this._context,l=_.bindTexture(c,h.TEXTURE_UNIT_FOR_UPDATES);_.setActiveTexture(h.TEXTURE_UNIT_FOR_UPDATES),_.bindFramebuffer(this),_.gl.copyTexSubImage2D(m.TEXTURE_2D,0,s,n,t,e,i,r),_.bindTexture(l,h.TEXTURE_UNIT_FOR_UPDATES)}readPixels(t,e,i,r,s,h,n){(i<=0||r<=0)&&console.error("Copy width and height must be greater than zero!"),n||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(t,e,i,r,s,h,n)}async readPixelsAsync(t,e,i,r,h,c,a){if(this._context.type!==o.WEBGL2)return n()&&console.warn("Attempting to read pixels using pixel buffer object without WebGL2"),void this.readPixels(t,e,i,r,h,c,a);const _=this._context.gl,l=s.createPixelPack(this._context,R.STREAM_READ,a.byteLength);this._context.bindBuffer(l),this._context.bindFramebuffer(this),_.readPixels(t,e,i,r,h,c,0),this._context.unbindBuffer(p.PIXEL_PACK_BUFFER),await l.getSubDataAsync(a),l.dispose()}resize(t,e){const i=this._desc;if(i.width!==t||i.height!==e){if(!this._initialized)return i.width=t,i.height=e,this._colorAttachments.forEach((i=>{i&&i.resize(t,e)})),void(this._depthStencilTexture&&this._depthStencilTexture.resize(t,e));i.width=t,i.height=e,this._colorAttachments.forEach((i=>{i&&i.resize(t,e)})),null!=this._depthStencilTexture?this._depthStencilTexture.resize(t,e):(this._depthAttachment||this._stencilAttachment)&&(this._depthAttachment&&this._depthAttachment.resize(t,e),this._stencilAttachment&&this._stencilAttachment.resize(t,e)),this._context.getBoundFramebufferObject()===this&&this._context.bindFramebuffer(null),this._initialized=!1}}initializeAndBind(t=f.FRAMEBUFFER){const e=this._context.gl;if(this._initialized)return void e.bindFramebuffer(t,this.glName);this._glName&&e.deleteFramebuffer(this._glName);const i=this._context,r=e.createFramebuffer(),s=this._desc,n=s.colorTarget??A.RENDER_BUFFER,o=s.width??1,a=s.height??1;if(e.bindFramebuffer(t,r),0===this._colorAttachments.size)if(n===A.TEXTURE||n===A.CUBEMAP)this._colorAttachments.set(_.COLOR_ATTACHMENT0,function(t,e,i){return new h(t,{target:i,pixelFormat:E.RGBA,dataType:T.UNSIGNED_BYTE,samplingMode:g.NEAREST,wrapMode:F.CLAMP_TO_EDGE,width:e.width,height:e.height})}(i,s,this.descriptor.colorTarget===A.CUBEMAP?m.TEXTURE_CUBE_MAP:m.TEXTURE_2D));else{const t=new b(i,{internalFormat:x.RGBA4,width:o,height:a});this._colorAttachments.set(_.COLOR_ATTACHMENT0,t)}this._colorAttachments.forEach(((i,r)=>{i&&(C(i)?this._framebufferTexture2D(i.glName,r,H(i),t):e.framebufferRenderbuffer(t,r,e.RENDERBUFFER,i.glName))}));const d=s.depthStencilTarget??l.NONE;switch(d){case l.DEPTH_RENDER_BUFFER:case l.DEPTH_STENCIL_RENDER_BUFFER:{this._depthAttachment||(this._depthAttachment=new b(i,{internalFormat:s.depthStencilTarget===l.DEPTH_RENDER_BUFFER?u.DEPTH_COMPONENT16:u.DEPTH_STENCIL,width:o,height:a}));const r=d===l.DEPTH_RENDER_BUFFER?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT;e.framebufferRenderbuffer(t,r,e.RENDERBUFFER,this._depthAttachment.glName);break}case l.STENCIL_RENDER_BUFFER:this._stencilAttachment||(this._stencilAttachment=new b(i,{internalFormat:u.STENCIL_INDEX8,width:o,height:a})),e.framebufferRenderbuffer(t,e.STENCIL_ATTACHMENT,e.RENDERBUFFER,this._stencilAttachment.glName);break;case l.DEPTH_STENCIL_TEXTURE:if(!this._depthStencilTexture){i.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!");const t={target:m.TEXTURE_2D,pixelFormat:E.DEPTH_STENCIL,dataType:T.UNSIGNED_INT_24_8,samplingMode:g.NEAREST,wrapMode:F.CLAMP_TO_EDGE,width:o,height:a};this._depthStencilTexture=new h(i,t)}this._framebufferTexture2D(this._depthStencilTexture.glName,e.DEPTH_STENCIL_ATTACHMENT,H(this._depthStencilTexture),t)}c()&&e.checkFramebufferStatus(t)!==e.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=r,this._initialized=!0}_framebufferTexture2D(t,e=_.COLOR_ATTACHMENT0,i=m.TEXTURE_2D,r=f.FRAMEBUFFER,s=0){this._context.gl.framebufferTexture2D(r,e,i,t,s)}_detachColorAttachment(t){n()&&console.warn("Detaching an FBO attachment can be a slow due to invalidating framebuffer completeness!");const e=this._context.gl,i=this._colorAttachments.get(t);return C(i)?this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t)):this._initialized&&(this._context.bindFramebuffer(this),e.framebufferRenderbuffer(f.FRAMEBUFFER,t,e.RENDERBUFFER,null)),this._colorAttachments.delete(t),i}_disposeColorAttachments(){this._colorAttachments.forEach(((t,e)=>{this._detachColorAttachment(e),t.dispose()})),this._colorAttachments.clear()}_disposeDepthStencilAttachments(){const t=this._context.gl;if(this._depthAttachment){if(this._initialized){this._context.bindFramebuffer(this);const e=this._desc.depthStencilTarget===l.DEPTH_RENDER_BUFFER?t.DEPTH_ATTACHMENT:t.DEPTH_STENCIL_ATTACHMENT;t.framebufferRenderbuffer(f.FRAMEBUFFER,e,t.RENDERBUFFER,null)}this._depthAttachment.dispose(),this._depthAttachment=null}this._stencilAttachment&&(this._initialized&&(this._context.bindFramebuffer(this),t.framebufferRenderbuffer(f.FRAMEBUFFER,t.STENCIL_ATTACHMENT,t.RENDERBUFFER,null)),this._stencilAttachment.dispose(),this._stencilAttachment=null),this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t.DEPTH_STENCIL_ATTACHMENT)),this._depthStencilTexture.dispose(),this._depthStencilTexture=null)}_validateColorAttachmentPoint(t){if(-1===D._MAX_COLOR_ATTACHMENTS){const t=this._context.capabilities.drawBuffers;if(t){const e=this._context.gl;D._MAX_COLOR_ATTACHMENTS=e.getParameter(t.MAX_COLOR_ATTACHMENTS)}else D._MAX_COLOR_ATTACHMENTS=1}const e=t-_.COLOR_ATTACHMENT0;e+1>D._MAX_COLOR_ATTACHMENTS&&N.error("esri.FrameBufferObject",`illegal attachment point for color attachment: ${e+1}. Implementation supports up to ${D._MAX_COLOR_ATTACHMENTS} color attachments`)}}function C(t){return"type"in t&&"texture"===t.type}function S(t){return"type"in t&&"renderbuffer"===t.type}function U(t){return C(t)||"pixelFormat"in t}function B(t,e){t.target!==m.TEXTURE_2D&&t.target!==m.TEXTURE_CUBE_MAP&&console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"),void 0!==e.width&&e.width>=0&&void 0!==e.height&&e.height>=0?e.width===t.width&&e.height===t.height||console.error("Color attachment texture must match the framebuffer's!"):(e.width=t.width,e.height=t.height)}function M(t,e){void 0!==e.width&&e.width>=0&&void 0!==e.height&&e.height>=0?e.width===t.width&&e.height===t.height||console.error("Renderbuffer dimensions must match the framebuffer's!"):(e.width=t.width,e.height=t.height)}function H(t){return t.descriptor.target===m.TEXTURE_CUBE_MAP?m.TEXTURE_CUBE_MAP_POSITIVE_X:m.TEXTURE_2D}D._MAX_COLOR_ATTACHMENTS=-1;export{D as F,b as R};
