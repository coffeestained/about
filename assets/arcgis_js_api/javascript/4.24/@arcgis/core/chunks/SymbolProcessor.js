/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{b as t}from"./shapingUtils.js";import"../core/Error.js";import"../core/lang.js";import{L as r}from"./Logger.js";import{f as s,a as i,i as o,c as a,u as n}from"./maybe.js";import{isAbortError as l,throwIfAborted as m}from"../core/promiseUtils.js";import"./ensureType.js";import"../core/accessorSupport/decorators/property.js";import{subclass as p}from"../core/accessorSupport/decorators/subclass.js";import{d as c,h as u}from"./diffUtils.js";import d from"../geometry/SpatialReference.js";import{j as h}from"./visualVariablesUtils.js";import{a as f,c as j,b as y,M as g,d as _}from"./Matcher.js";import{B as b}from"./BaseProcessor.js";import"./Rect.js";import"./mat2df32.js";import"./vec2.js";import"./vec2f32.js";import"./alignmentUtils.js";import"./number3.js";import"./object.js";import"../config.js";import"./string.js";import"./get.js";import"./utils.js";import"./handleUtils.js";import"./metadata.js";import"./tracking.js";import"../core/Accessor.js";import"./ArrayPool.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"../core/Collection.js";import"../core/Evented.js";import"./shared.js";import"./SimpleObservable.js";import"../core/JSONSupport.js";import"./writer.js";import"./screenUtils.js";import"./Utils16.js";import"./mathUtils.js";import"./common.js";import"./enums2.js";import"./enums4.js";import"./enums.js";import"./Texture.js";import"./context-util.js";import"./VertexElementDescriptor.js";import"./definitions.js";import"./visualVariablesUtils2.js";import"./TileStrategy.js";import"./QueueProcessor.js";import"./Queue.js";import"./aaBoundingRect.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"./reader.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"./Ellipsoid.js";import"./TileInfoView.js";import"./TileKey.js";import"./tileUtils.js";import"../rest/support/Query.js";import"../geometry.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./extentUtils.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"./jsonMap.js";import"../geometry/support/jsonUtils.js";import"../TimeExtent.js";import"./timeUtils.js";import"./enumeration.js";import"./DataLayerSource.js";import"../layers/support/Field.js";import"./domains.js";import"../layers/support/CodedValueDomain.js";import"../layers/support/Domain.js";import"../layers/support/InheritedDomain.js";import"../layers/support/RangeDomain.js";import"./fieldType.js";import"../rest/support/StatisticDefinition.js";import"./TileClipper.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./Geometry.js";import"./GeometryUtils2.js";import"./MaterialKey.js";import"./featureConversionUtils.js";import"./OptimizedGeometry.js";import"./OptimizedFeatureSet.js";import"./CIMSymbolHelper.js";import"../Color.js";import"./colorUtils.js";import"./floatRGBA.js";import"./utils7.js";import"./GeometryUtils.js";import"./cimAnalyzer.js";import"./arcadeOnDemand.js";import"./callExpressionWithFeature.js";import"./quantizationUtils.js";import"./defaultsJSON.js";import"./earcut.js";import"./TurboLine.js";import"./LRUCache.js";import"./MemCache.js";import"./ExpandedCIM.js";import"./devEnvironmentUtils.js";import"../portal/Portal.js";import"../core/Loadable.js";import"../core/Promise.js";import"./locale.js";import"../portal/PortalQueryParams.js";import"../portal/PortalQueryResult.js";import"../portal/PortalUser.js";import"../portal/PortalFolder.js";import"../portal/PortalGroup.js";import"./persistableUrlUtils.js";import"./styleUtils2.js";import"../core/HandleOwner.js";import"../core/Handles.js";import"../core/reactiveUtils.js";class S{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null}destroy(){}async fetchResource(e,t){const r=this._resourceMap,s=r.get(e);if(s)return s;let i=this._inFlightResourceMap.get(e);if(i)return i;try{i=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...t}),this._inFlightResourceMap.set(e,i),i.then((t=>(this._inFlightResourceMap.delete(e),r.set(e,t),t)))}catch(e){return l(e)?null:{width:0,height:0}}return i}getResource(e){return this._resourceMap.get(e)??null}}function M(e,t){return(!e.minScale||e.minScale>=t)&&(!e.maxScale||e.maxScale<=t)}function U(e){const t=e.message,r={message:{data:{},tileKey:t.tileKey,tileKeyOrigin:t.tileKeyOrigin,version:t.version},transferList:new Array};for(const e in t.data){const i=t.data[e];if(r.message.data[e]=null,o(i)){const t=i.stride,o=i.indices.slice(0),a=i.vertices.slice(0),n=i.records.slice(0),l={stride:t,indices:o,vertices:a,records:n,metrics:s(i.metrics,(e=>e.slice(0)))};r.transferList.push(o,a,n),r.message.data[e]=l}}return r}r.getLogger("esri.views.2d.layers.features.processors.SymbolProcessor");let v=class extends b{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new S(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(e){this._bufferIds.forEach((t=>{t.forEach(e)}))}async update(e,t){const r=t.schema.processors[0];if("symbol"!==r.type)return;const s=c(this._schema,r);u(s,"mesh")&&(e.mesh=!0,e.why.mesh.push("Symbology changed"),this._schema=r,this._factory=this._createFactory(r),this._factory.update(r,this.tileStore.tileScheme.tileInfo))}onTileMessage(e,t,r,s){return m(s),this._onTileData(e,t,r,s)}onTileClear(e){return this._bufferData.delete(e.key.id),this._bufferIds.delete(e.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:{clear:!0}})}onTileError(e,t,r){const s=r.signal,i={tileKey:e.id,error:t};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:s})}onTileUpdate(e){for(const t of e.removed)this._bufferData.has(t.key.id)&&this._bufferData.delete(t.key.id),this._bufferIds.has(t.key.id)&&this._bufferIds.delete(t.key.id);for(const t of e.added)this._bufferData.forEach((e=>{for(const r of e)r.message.tileKey===t.id&&this._updateTileMesh("append",t,U(r),[],!1,!1,null)}))}_addBufferData(e,t){this._bufferData.has(e)||this._bufferData.set(e,[]),this._bufferData.get(e).push(U(t))}_createFactory(e){const{geometryType:t,objectIdField:r,fields:i}=this.service,o={geometryType:t,fields:i,spatialReference:d.fromJSON(this.spatialReference)},a=new f(((e,t)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",e,t)),this.tileStore.tileScheme.tileInfo),{matcher:n,aggregateMatcher:l}=e.mesh;return this._store=a,this._matchers.feature=j(n,a,o,this._resourceManagerProxy),this._matchers.aggregate=s(l,(e=>j(e,a,o,this._resourceManagerProxy))),new y(t,r,a)}async _onTileData(e,t,r,s){m(s);const{type:a,addOrUpdate:n,remove:l,clear:p,end:c}=t,u=!!this._schema.mesh.sortKey;if(!n){const t={type:a,addOrUpdate:null,remove:l,clear:p,end:c,sort:u};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},s)}const d=this._processFeatures(e,n,r,s,t.status.version);try{const r=await d;if(i(r)){const t={type:a,addOrUpdate:null,remove:l,clear:p,end:c,sort:u};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},s)}const n=[];for(const t of r){let r=!1;const s=t.message.bufferIds,i=e.key.id,a=t.message.tileKey;if(i!==a&&o(s)){if(!this.tileStore.get(a)){this._addBufferData(i,t),n.push(t);continue}let e=this._bufferIds.get(a);e||(e=new Set,this._bufferIds.set(a,e));const o=Array.from(s);for(const t of o){if(e.has(t)){r=!0;break}e.add(t)}}r||(this._addBufferData(i,t),n.push(t))}await Promise.all(n.map((r=>{const i=e.key.id===r.message.tileKey,o=i?t.remove:[],n=i&&t.end;return this._updateTileMesh(a,e,r,o,n,t.clear,s.signal)})))}catch(t){this._handleError(e,t,s)}}async _updateTileMesh(e,t,r,i,o,a,l){const p=e,c=r.message.tileKey,u=!!this._schema.mesh.sortKey;c!==t.key.id&&(o=!1);const d=s(r,(e=>e.message)),h=s(r,(e=>e.transferList))||[],f={type:p,addOrUpdate:d,remove:i,clear:a,end:o,sort:u},j={transferList:n(h)||[],signal:l};return m(j),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:c,data:f},j)}async _processFeatures(e,t,r,s,o){if(i(t)||!t.hasFeatures)return null;const a={transform:e.transform,hasZ:!1,hasM:!1},n=this._factory,l={viewingMode:"",scale:e.scale},p=await this._matchers.feature,c=await this._matchers.aggregate;m(s);const u=this._getLabelInfos(e,t);return await n.analyze(t.getCursor(),this._resourceManagerProxy,p,c,a,l),m(s),this._writeFeatureSet(e,t,a,u,n,r,o)}_writeFeatureSet(e,t,r,s,i,a,n){const l=t.getSize(),m=new g(e.key.id,{features:l,records:l,metrics:0},this._schema.mesh.matcher.symbologyType,a,!0,n),p={viewingMode:"",scale:e.scale},c=t.getCursor();for(;c.next();)try{const t=c.getDisplayId(),a=o(s)?s.get(t):null;i.writeCursor(m,c,r,p,e.level,a,this._resourceManagerProxy)}catch(e){}const u=e.tileInfoView.tileInfo.isWrappable;return m.serialize(u)}_handleError(e,t,r){if(!l(t)){const s={tileKey:e.id,error:t.message};return this.remoteClient.invoke("tileRenderer.onTileError",s,{signal:r.signal})}}_getLabelingSchemaForScale(e){const t=this._schema.mesh.labels;if(i(t))return null;if("subtype"===t.type){const r={type:"subtype",classes:{}};let s=!1;for(const i in t.classes){const o=t.classes[i].filter((t=>M(t,e.scale)));s=s||!!o.length,r.classes[i]=o}return s?r:null}const r=t.classes.filter((t=>M(t,e.scale)));return r.length?{type:"simple",classes:r}:null}_getLabels(e,t){if("subtype"===t.type){const r=this.service.subtypeField,s=a(r,"Expected to find subtype Field"),i=e.readAttribute(s);return null==i?[]:t.classes[i]??[]}return t.classes}_getLabelInfos(e,r){const s=this._getLabelingSchemaForScale(e);if(i(s))return null;const o=new Map,a=r.getCursor();for(;a.next();){const e=a.getDisplayId(),r=[],i=h(e),n=i&&1!==a.readAttribute("cluster_count")?"aggregate":"feature",l=this._getLabels(a,s);for(const s of l){if(s.target!==n)continue;const o=a.getStorage(),l=i&&"feature"===n?o.getComputedStringAtIndex(a.readAttribute("referenceId"),s.fieldIndex):o.getComputedStringAtIndex(e,s.fieldIndex);if(!l)continue;const m=t(l.toString()),p=m[0],c=m[1];this._store.getMosaicItem(s.symbol,_(p)).then((e=>{r[s.index]={glyphs:e.glyphMosaicItems,rtl:c,index:s.index}}))}o.set(e,r)}return o}};v=e([p("esri.views.2d.layers.features.processors.SymbolProcessor")],v);const w=v;export{w as default};
