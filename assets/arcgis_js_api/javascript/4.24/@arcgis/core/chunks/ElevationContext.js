/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{e,a as t,i as n}from"./maybe.js";import{g as s,a as r}from"./unitConversionUtils.js";import{L as i}from"./Logger.js";import{h as o}from"./CameraSpace.glsl.js";import{l as a}from"./arcadeOnDemand.js";const u=i.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function f(e){const t=e&&e.expression;if("string"==typeof t){const e=p(t);if(null!=e)return{cachedResult:e}}return null}async function c(e,t,n){const s=e&&e.expression;if("string"!=typeof s)return null;const r=p(s);if(null!=r)return{cachedResult:r};const i=await a(),o=i.arcadeUtils,u=o.createSyntaxTree(s);return o.dependsOnView(u)?(null!=n&&n.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:o.createFunction(u),context:o.createExecContext(null,{sr:t}),modules:i}}}function l(e,t,n){return e.arcadeUtils.createFeature(t.attributes,t.geometry,n)}function d(e,t){if(null!=e&&!x(e)){if(!t||!e.arcade)return void u.errorOncePerTick("Arcade support required but not provided");const n=t;n._geometry&&(n._geometry=o(n._geometry)),e.arcade.modules.arcadeUtils.updateExecContext(e.arcade.context,t)}}function h(e,t=!1){let n=e&&e.featureExpressionInfo;const s=n&&n.expression;return t||"0"===s||(n=null),n}const m={cachedResult:0};function x(e){return null!=e.cachedResult}function p(e){return"0"===e?0:null}class E{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(e){this._unit=e,this._metersPerElevationInfoUnit=s(e)}get requiresSampledElevationInfo(){return"absolute-height"!==this.mode}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(e){this._meterUnitOffset=e,this._renderUnitOffset=0}set offsetElevationInfoUnits(e){this._meterUnitOffset=e*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(e){this._renderUnitOffset+=e}geometryZWithOffset(e,t){const n=this.calculateOffsetRenderUnits(t);return null!=this.featureExpressionInfoContext?n:e+n}calculateOffsetRenderUnits(e){let t=this._meterUnitOffset;const n=this.featureExpressionInfoContext;return null!=n&&(t+=function(e){if(null!=e){if(x(e))return e.cachedResult;const t=e.arcade;let n=e.arcade.modules.arcadeUtils.executeFunction(t.func,t.context);return"number"!=typeof n&&(e.cachedResult=0,n=0),n}return 0}(n)*this._metersPerElevationInfoUnit),t/e.unitInMeters+this._renderUnitOffset}setFromElevationInfo(t){this.mode=t.mode,this.unit=r(t.unit)?t.unit:"meters",this.offsetElevationInfoUnits=e(t.offset,0)}updateFeatureExpressionInfoContext(e,s,r){if(t(e))return void(this._featureExpressionInfoContext=null);const i=e&&e.arcade;var o;i&&n(s)&&n(r)?(this._featureExpressionInfoContext={cachedResult:(o=e).cachedResult,arcade:o.arcade?{func:o.arcade.func,context:o.arcade.modules.arcadeUtils.createExecContext(null,{sr:o.arcade.context.spatialReference}),modules:o.arcade.modules}:null},d(this._featureExpressionInfoContext,l(i.modules,s,r))):this._featureExpressionInfoContext=e}static fromElevationInfo(e){const t=new E;return n(e)&&t.setFromElevationInfo(e),t}}export{E,c as a,f as b,l as c,h as e,d as s,m as z};
