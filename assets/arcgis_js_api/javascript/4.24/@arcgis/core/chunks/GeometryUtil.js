/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{d as t,k as e,n,o as a,b as r,j as o,s,a as l,w as i,h as c}from"./mathUtils.js";import{f as u,c as h,a as f}from"./vec3f32.js";import{c as O,f as A,i as y}from"./plane.js";import{w as I}from"./ray.js";import{P as g}from"./basicInterfaces.js";import{e as M}from"./glUtil3D.js";import{g as d}from"./geometryDataUtils.js";import{a as w}from"./Util.js";import{V as m}from"./VertexAttribute.js";var N;!function(t){t.length=function(t,e){const n=t[e],a=t[e+1],r=t[e+2];return Math.sqrt(n*n+a*a+r*r)},t.normalize=function(t,e){const n=t[e],a=t[e+1],r=t[e+2],o=1/Math.sqrt(n*n+a*a+r*r);t[e]*=o,t[e+1]*=o,t[e+2]*=o},t.scale=function(t,e,n){t[e]*=n,t[e+1]*=n,t[e+2]*=n},t.add=function(t,e,n,a,r,o=e){(r=r||t)[o]=t[e]+n[a],r[o+1]=t[e+1]+n[a+1],r[o+2]=t[e+2]+n[a+2]},t.subtract=function(t,e,n,a,r,o=e){(r=r||t)[o]=t[e]-n[a],r[o+1]=t[e+1]-n[a+1],r[o+2]=t[e+2]-n[a+2]}}(N||(N={}));const P=N;var U,S,z,x;!function(t){const e=.5,n=[[-e,-e,e],[e,-e,e],[e,e,e],[-e,e,e],[-e,-e,-e],[e,-e,-e],[e,e,-e],[-e,e,-e]],a=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],r=[0,0,1,0,1,1,0,1],o=new Uint16Array([0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5]),s=new Uint16Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)s[6*t+e]=t;const l=new Uint16Array(36);for(let t=0;t<6;t++)l[6*t+0]=0,l[6*t+1]=1,l[6*t+2]=2,l[6*t+3]=2,l[6*t+4]=3,l[6*t+5]=0;t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(24);for(let a=0;a<8;a++)e[3*a]=n[a][0]*t[0],e[3*a+1]=n[a][1]*t[1],e[3*a+2]=n[a][2]*t[2];return new M([[m.POSITION,{size:3,data:e,exclusive:!0}],[m.NORMAL,{size:3,data:a}],[m.UV0,{size:2,data:r}]],[[m.POSITION,o],[m.NORMAL,s],[m.UV0,l]])}}(U||(U={})),function(t){const e=.5,n=[[-e,0,-e],[e,0,-e],[e,0,e],[-e,0,e],[0,-e,0],[0,e,0]],a=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],r=new Uint16Array([5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0]),o=new Uint16Array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]);t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(18);for(let a=0;a<6;a++)e[3*a]=n[a][0]*t[0],e[3*a+1]=n[a][1]*t[1],e[3*a+2]=n[a][2]*t[2];return new M([[m.POSITION,{size:3,data:e,exclusive:!0}],[m.NORMAL,{size:3,data:a}]],[[m.POSITION,r],[m.NORMAL,o]])}}(S||(S={})),function(a){const r=.5,o=u(-r,0,-r),s=u(r,0,-r),l=u(0,0,r),i=u(0,.5,0),c=h(),f=h(),O=h(),A=h(),y=h();t(c,o,i),t(f,o,s),e(O,c,f),n(O,O),t(c,s,i),t(f,s,l),e(A,c,f),n(A,A),t(c,l,i),t(f,l,o),e(y,c,f),n(y,y);const I=[o,s,l,i],g=[0,-1,0,O[0],O[1],O[2],A[0],A[1],A[2],y[0],y[1],y[2]],d=[0,1,2,3,1,0,3,2,1,3,0,2],w=[0,0,0,1,1,1,2,2,2,3,3,3];a.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(12);for(let n=0;n<4;n++)e[3*n]=I[n][0]*t[0],e[3*n+1]=I[n][1]*t[1],e[3*n+2]=I[n][2]*t[2];return new M([[m.POSITION,{size:3,data:e,exclusive:!0}],[m.NORMAL,{size:3,data:g}]],[[m.POSITION,new Uint16Array(d)],[m.NORMAL,new Uint16Array(w)]])}}(z||(z={})),function(N){N.createBoxGeometry=U.createGeometry,N.createDiamondGeometry=S.createGeometry,N.createTetrahedronGeometry=z.createGeometry,N.createSphereGeometry=function(t,e,n,a={uv:!0}){const r=-Math.PI,o=2*Math.PI,s=-Math.PI/2,l=Math.PI,i=Math.max(3,Math.floor(e)),c=Math.max(2,Math.floor(n)),u=(i+1)*(c+1),h=new Float32Array(3*u),f=new Float32Array(3*u),O=new Float32Array(2*u),A=[];let y=0;for(let e=0;e<=c;e++){const n=[],a=e/c,u=s+a*l,I=Math.cos(u);for(let e=0;e<=i;e++){const s=e/i,l=r+s*o,c=Math.cos(l)*I,A=Math.sin(u),g=-Math.sin(l)*I;h[3*y]=c*t,h[3*y+1]=A*t,h[3*y+2]=g*t,f[3*y]=c,f[3*y+1]=A,f[3*y+2]=g,O[2*y]=s,O[2*y+1]=a,n.push(y),++y}A.push(n)}const I=new Uint32Array(2*i*(c-1)*3);y=0;for(let t=0;t<c;t++)for(let e=0;e<i;e++){const n=A[t][e],a=A[t][e+1],r=A[t+1][e+1],o=A[t+1][e];0===t?(I[y++]=n,I[y++]=r,I[y++]=o):t===c-1?(I[y++]=n,I[y++]=a,I[y++]=r):(I[y++]=n,I[y++]=a,I[y++]=r,I[y++]=r,I[y++]=o,I[y++]=n)}const g=[[m.POSITION,I],[m.NORMAL,I]],d=[[m.POSITION,{size:3,data:h,exclusive:!0}],[m.NORMAL,{size:3,data:f,exclusive:!0}]];return a.uv&&(d.push([m.UV0,{size:2,data:O,exclusive:!0}]),g.push([m.UV0,I])),a.offset&&(g[0][0]=m.OFFSET,d[0][0]=m.OFFSET,g.push([m.POSITION,new Uint32Array(I.length)]),d.push([m.POSITION,{size:3,data:Float64Array.from(a.offset),exclusive:!0}])),new M(d,g)},N.createPolySphereGeometry=function(t,e,n){const a=t;let r,o;if(n)r=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],o=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const t=a*(1+Math.sqrt(5))/2;r=[-a,t,0,a,t,0,-a,-t,0,a,-t,0,0,-a,t,0,a,t,0,-a,-t,0,a,-t,t,0,-a,t,0,a,-t,0,-a,-t,0,a],o=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let e=0;e<r.length;e+=3)P.scale(r,e,t/P.length(r,e));let s={};function l(e,n){e>n&&([e,n]=[n,e]);const a=e.toString()+"."+n.toString();if(s[a])return s[a];let o=r.length;return r.length+=3,P.add(r,3*e,r,3*n,r,o),P.scale(r,o,t/P.length(r,o)),o/=3,s[a]=o,o}for(let t=0;t<e;t++){const t=o.length,e=new Uint32Array(4*t);for(let n=0;n<t;n+=3){const t=o[n],a=o[n+1],r=o[n+2],s=l(t,a),i=l(a,r),c=l(r,t),u=4*n;e[u]=t,e[u+1]=s,e[u+2]=c,e[u+3]=a,e[u+4]=i,e[u+5]=s,e[u+6]=r,e[u+7]=c,e[u+8]=i,e[u+9]=s,e[u+10]=i,e[u+11]=c}o=e,s={}}const i=new Float32Array(r);for(let t=0;t<i.length;t+=3)P.normalize(i,t);const c=[[m.POSITION,o],[m.NORMAL,o]],u=[[m.POSITION,{size:3,data:new Float32Array(r),exclusive:!0}],[m.NORMAL,{size:3,data:i,exclusive:!0}]];return new M(u,c)},N.createPointGeometry=function(t,e,n,a,r,o,s){const l=e?[e[0],e[1],e[2]]:[0,0,0],i=t?[t[0],t[1],t[2]]:[0,0,1];o=o||[0,0];const c=n?[255*n[0],255*n[1],255*n[2],n.length>3?255*n[3]:255]:[255,255,255,255],u=null!=a&&2===a.length?a:[1,1],h=[[m.POSITION,{size:3,data:l,exclusive:!0}],[m.NORMAL,{size:3,data:i,exclusive:!0}],[m.UV0,{size:o.length,data:o}],[m.COLOR,{size:4,data:c,exclusive:!0}],[m.SIZE,{size:2,data:u}]];if(null!=r){const t=new Float32Array([r[0],r[1],r[2],r[3]]);h.push([m.AUXPOS1,{size:4,data:t}])}if(null!=s){const t=new Float32Array([s[0],s[1],s[2],s[3]]);h.push([m.AUXPOS2,{size:4,data:t}])}return new M(h,null,g.Point)},N.updatePointGeometry=function(t,e,n,a,r,o,s,l){if(null!=t){const{data:e}=l.getMutableAttribute(m.NORMAL);e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=e){const{data:t}=l.getMutableAttribute(m.POSITION);t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=n){const{data:t}=l.getMutableAttribute(m.COLOR);t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3]}if(null!=a){const{data:t}=l.getMutableAttribute(m.SIZE);t[0]=a[0],t[1]=a[1]}if(null!=r){const{data:t}=l.getMutableAttribute(m.AUXPOS1);t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3]}if(null!=o){const{data:t}=l.getMutableAttribute(m.UV0);t[0]=o[0],t[1]=o[1]}if(null!=s){const{data:t}=l.getMutableAttribute(m.AUXPOS2);t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3]}},N.createPointArrayGeometry=function(t,e){const n=new Float32Array(3*t.length),a=new Float32Array(e?3*t.length:3),r=new Uint32Array(t.length),o=new Uint32Array(t.length);for(let s=0;s<t.length;s++)n[3*s]=t[s][0],n[3*s+1]=t[s][1],n[3*s+2]=t[s][2],e&&(a[3*s]=e[s][0],a[3*s+1]=e[s][1],a[3*s+2]=e[s][2]),r[s]=s,o[s]=0;e||(a[0]=0,a[1]=1,a[2]=0);const s=[[m.POSITION,r],[m.NORMAL,e?r:o],[m.UV0,o]],l=[[m.POSITION,{size:3,data:n,exclusive:!0}],[m.NORMAL,{size:3,data:a,exclusive:!0}],[m.UV0,{size:2,data:[0,0],exclusive:!0}]];return new M(l,s,g.Point)},N.createTriangleGeometry=function(){const t=new Uint16Array([0,1,2]),e=new Uint16Array([0,0,0]),n=new Uint16Array([0,0,0]),a=[[m.POSITION,t],[m.NORMAL,e],[m.UV0,n]],r=[[m.POSITION,{size:3,data:[0,0,0,0,0,100,100,0,0],exclusive:!0}],[m.NORMAL,{size:3,data:[0,1,0],exclusive:!0}],[m.UV0,{size:2,data:[0,0],exclusive:!0}]];return new M(r,a)};const x=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function v(t,a,r,s,l){return!(Math.abs(o(a,t))>l||(e(r,t,a),n(r,r),e(s,r,t),n(s,s),0))}function L(t,e,n,a,r,o,s){return v(t,e,r,o,s)||v(t,n,r,o,s)||v(t,a,r,o,s)}N.createSquareGeometry=function(t=x){const e=new Array(12);for(let n=0;n<4;n++)for(let a=0;a<3;a++)e[3*n+a]=t[n][a];const n=new Uint32Array([0,1,2,2,3,0]),a=new Uint32Array([0,0,0,0,0,0]),r=[[m.POSITION,n],[m.NORMAL,a],[m.UV0,n],[m.COLOR,a]],o=[[m.POSITION,{size:3,data:e,exclusive:!0}],[m.NORMAL,{size:3,data:[0,0,1],exclusive:!0}],[m.UV0,{size:2,data:[0,0,1,0,1,1,0,1],exclusive:!0}],[m.COLOR,{size:4,data:[255,255,255,255],exclusive:!0}]];return new M(o,r)},N.createConeGeometry=function(t,e,n,a,r=!0,o=!0){let s=0;const l=e,i=t;let c=u(0,s,0),h=u(0,s+i,0),f=u(0,-1,0),O=u(0,1,0);a&&(s=i,h=u(0,0,0),c=u(0,s,0),f=u(0,1,0),O=u(0,-1,0));const A=[h,c],y=[f,O],I=n+2,g=Math.sqrt(i*i+l*l);if(a)for(let t=n-1;t>=0;t--){const e=t*(2*Math.PI/n),a=u(Math.cos(e)*l,s,Math.sin(e)*l);A.push(a);const r=u(i*Math.cos(e)/g,-l/g,i*Math.sin(e)/g);y.push(r)}else for(let t=0;t<n;t++){const e=t*(2*Math.PI/n),a=u(Math.cos(e)*l,s,Math.sin(e)*l);A.push(a);const r=u(i*Math.cos(e)/g,l/g,i*Math.sin(e)/g);y.push(r)}const d=new Uint32Array(2*(n+2)*3),w=new Uint32Array(2*(n+2)*3);let N=0,P=0;if(r){for(let t=3;t<A.length;t++)d[N++]=1,d[N++]=t-1,d[N++]=t,w[P++]=0,w[P++]=0,w[P++]=0;d[N++]=A.length-1,d[N++]=2,d[N++]=1,w[P++]=0,w[P++]=0,w[P++]=0}if(o){for(let t=3;t<A.length;t++)d[N++]=t,d[N++]=t-1,d[N++]=0,w[P++]=t,w[P++]=t-1,w[P++]=1;d[N++]=0,d[N++]=2,d[N++]=A.length-1,w[P++]=1,w[P++]=2,w[P++]=y.length-1}const U=new Float32Array(3*I);for(let t=0;t<I;t++)U[3*t]=A[t][0],U[3*t+1]=A[t][1],U[3*t+2]=A[t][2];const S=new Float32Array(3*I);for(let t=0;t<I;t++)S[3*t]=y[t][0],S[3*t+1]=y[t][1],S[3*t+2]=y[t][2];const z=[[m.POSITION,d],[m.NORMAL,w]],x=[[m.POSITION,{size:3,data:U,exclusive:!0}],[m.NORMAL,{size:3,data:S,exclusive:!0}]];return new M(x,z)},N.createCylinderGeometry=function(t,l,i,c,O,A){const y=c?f(c):u(1,0,0),I=O?f(O):u(0,0,0);A=null==A||A;const g=h();n(g,y);const d=h();a(d,g,Math.abs(t));const w=h();a(w,d,-.5),r(w,w,I);const N=u(0,1,0);Math.abs(1-o(g,N))<.2&&s(N,0,0,1);const P=h();e(P,g,N),n(P,P),e(N,P,g);const U=2*i+(A?2:0),S=i+(A?2:0),z=new Float32Array(3*U),x=new Float32Array(3*S),T=new Float32Array(2*U),p=new Uint32Array(3*i*(A?4:2)),v=new Uint32Array(3*i*(A?4:2));A&&(z[3*(U-2)+0]=w[0],z[3*(U-2)+1]=w[1],z[3*(U-2)+2]=w[2],T[2*(U-2)]=0,T[2*(U-2)+1]=0,z[3*(U-1)+0]=z[3*(U-2)+0]+d[0],z[3*(U-1)+1]=z[3*(U-2)+1]+d[1],z[3*(U-1)+2]=z[3*(U-2)+2]+d[2],T[2*(U-1)]=1,T[2*(U-1)+1]=1,x[3*(S-2)+0]=-g[0],x[3*(S-2)+1]=-g[1],x[3*(S-2)+2]=-g[2],x[3*(S-1)+0]=g[0],x[3*(S-1)+1]=g[1],x[3*(S-1)+2]=g[2]);const L=(t,e,n)=>{p[t]=e,v[t]=n};let R=0;const b=h(),G=h();for(let t=0;t<i;t++){const e=t*(2*Math.PI/i);a(b,N,Math.sin(e)),a(G,P,Math.cos(e)),r(b,b,G),x[3*t+0]=b[0],x[3*t+1]=b[1],x[3*t+2]=b[2],a(b,b,l),r(b,b,w),z[3*t+0]=b[0],z[3*t+1]=b[1],z[3*t+2]=b[2],T[2*t+0]=t/i,T[2*t+1]=0,z[3*(t+i)+0]=z[3*t+0]+d[0],z[3*(t+i)+1]=z[3*t+1]+d[1],z[3*(t+i)+2]=z[3*t+2]+d[2],T[2*(t+i)+0]=t/i,T[2*t+1]=1;const n=(t+1)%i;L(R++,t,t),L(R++,t+i,t),L(R++,n,n),L(R++,n,n),L(R++,t+i,t),L(R++,n+i,n)}if(A){for(let t=0;t<i;t++){const e=(t+1)%i;L(R++,U-2,S-2),L(R++,t,S-2),L(R++,e,S-2)}for(let t=0;t<i;t++){const e=(t+1)%i;L(R++,t+i,S-1),L(R++,U-1,S-1),L(R++,e+i,S-1)}}const F=[[m.POSITION,p],[m.NORMAL,v],[m.UV0,p]],V=[[m.POSITION,{size:3,data:z,exclusive:!0}],[m.NORMAL,{size:3,data:x,exclusive:!0}],[m.UV0,{size:2,data:T,exclusive:!0}]];return new M(V,F)},N.createTubeGeometry=function(t,e,n,a,r){n=n||10,a=null==a||a,w(t.length>1);const o=[],s=[];for(let t=0;t<n;t++){o.push([0,-t-1,-(t+1)%n-1]);const a=t/n*2*Math.PI;s.push([Math.cos(a)*e,Math.sin(a)*e])}return N.createPathExtrusionGeometry(s,t,[[0,0,0]],o,a,r)},N.createPathExtrusionGeometry=function(o,i,f,g,d,w=u(0,0,0)){const N=o.length,P=new Float32Array(i.length*N*3+(6*f.length||0)),U=new Float32Array(i.length*N*3+(f?6:0)),S=(i.length-1)*N*6+3*g.length*2,z=new Uint32Array(S),x=new Uint32Array(S);let p=0,v=0,R=0,b=0;const G=h(),F=h(),V=h(),j=h(),C=h(),E=h(),q=h(),D=c(),k=h(),X=h(),B=h(),Z=h(),H=h(),J=O();s(k,0,1,0),t(F,i[1],i[0]),n(F,F),d?(r(D,i[0],w),n(V,D)):s(V,0,0,1),L(F,V,k,k,C,V,T),l(j,V),l(Z,C);for(let t=0;t<f.length;t++)a(E,C,f[t][0]),a(D,V,f[t][2]),r(E,E,D),r(E,E,i[0]),P[p++]=E[0],P[p++]=E[1],P[p++]=E[2];U[v++]=-F[0],U[v++]=-F[1],U[v++]=-F[2];for(let t=0;t<g.length;t++)z[R++]=g[t][0]>0?g[t][0]:-g[t][0]-1+f.length,z[R++]=g[t][1]>0?g[t][1]:-g[t][1]-1+f.length,z[R++]=g[t][2]>0?g[t][2]:-g[t][2]-1+f.length,x[b++]=0,x[b++]=0,x[b++]=0;let K=f.length;const Q=f.length-1;for(let s=0;s<i.length;s++){let c=!1;s>0&&(l(G,F),s<i.length-1?(t(F,i[s+1],i[s]),n(F,F)):c=!0,r(X,G,F),n(X,X),r(B,i[s-1],j),A(i[s],X,J),y(J,I(B,G),D)?(t(D,D,i[s]),n(V,D),e(C,X,V),n(C,C)):L(X,j,Z,k,C,V,T),l(j,V),l(Z,C)),d&&(r(D,i[s],w),n(H,D));for(let t=0;t<N;t++)if(a(E,C,o[t][0]),a(D,V,o[t][1]),r(E,E,D),n(q,E),U[v++]=q[0],U[v++]=q[1],U[v++]=q[2],r(E,E,i[s]),P[p++]=E[0],P[p++]=E[1],P[p++]=E[2],!c){const e=(t+1)%N;z[R++]=K+t,z[R++]=K+N+t,z[R++]=K+e,z[R++]=K+e,z[R++]=K+N+t,z[R++]=K+N+e;for(let t=0;t<6;t++)x[b++]=z[R-6+t]-Q}K+=N}const W=i[i.length-1];for(let t=0;t<f.length;t++)a(E,C,f[t][0]),a(D,V,f[t][1]),r(E,E,D),r(E,E,W),P[p++]=E[0],P[p++]=E[1],P[p++]=E[2];const Y=v/3;U[v++]=F[0],U[v++]=F[1],U[v++]=F[2];const $=K-N;for(let t=0;t<g.length;t++)z[R++]=g[t][0]>=0?K+g[t][0]:-g[t][0]-1+$,z[R++]=g[t][2]>=0?K+g[t][2]:-g[t][2]-1+$,z[R++]=g[t][1]>=0?K+g[t][1]:-g[t][1]-1+$,x[b++]=Y,x[b++]=Y,x[b++]=Y;const _=[[m.POSITION,z],[m.NORMAL,x]],tt=[[m.POSITION,{size:3,data:P,exclusive:!0}],[m.NORMAL,{size:3,data:U,exclusive:!0}]];return new M(tt,_)},N.createPolylineGeometry=function(t,e,n){w(t.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),w(3===t[0].length,"createPolylineGeometry(): malformed vertex"),w(null==e||e.length===t.length,"createPolylineGeometry: need same number of points and normals"),w(null==e||3===e[0].length,"createPolylineGeometry(): malformed normal");const a=new Float64Array(3*t.length),r=new Uint32Array(2*(t.length-1));let o=0,s=0;for(let e=0;e<t.length;e++){for(let n=0;n<3;n++)a[o++]=t[e][n];e>0&&(r[s++]=e-1,r[s++]=e)}const l=[],i=[];if(l.push([m.POSITION,r]),i.push([m.POSITION,{size:3,data:a,exclusive:!0}]),e){const n=new Float32Array(3*e.length);let a=0;for(let r=0;r<t.length;r++)for(let t=0;t<3;t++)n[a++]=e[r][t];l.push([m.NORMAL,r]),i.push([m.NORMAL,{size:3,data:n,exclusive:!0}])}return n&&(i.push([m.COLOR,{size:4,data:n}]),l.push([m.COLOR,d(n.length/4)])),new M(i,l,g.Line)},N.createExtrudedTriangle=function(t,e,n,a,r=0){const o=new Array(18),s=[[-e,r,a/2],[n,r,a/2],[0,t+r,a/2],[-e,r,-a/2],[n,r,-a/2],[0,t+r,-a/2]],l=new Uint16Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]);for(let t=0;t<6;t++)o[3*t]=s[t][0],o[3*t+1]=s[t][1],o[3*t+2]=s[t][2];return new M([[m.POSITION,{size:3,data:o,exclusive:!0}]],[[m.POSITION,l]])},N.transformInPlace=function(t,e){const n=t.getMutableAttribute(m.POSITION).data;for(let t=0;t<n.length;t+=3){const a=n[t],r=n[t+1],o=n[t+2];s(p,a,r,o),i(p,p,e),n[t]=p[0],n[t+1]=p[1],n[t+2]=p[2]}},N.cgToGIS=function(t,e=t){const n=t.vertexAttributes,a=n.get(m.POSITION).data,r=n.get(m.NORMAL).data;if(r){const t=e.getMutableAttribute(m.NORMAL).data;for(let e=0;e<r.length;e+=3){const n=r[e+1];t[e+1]=-r[e+2],t[e+2]=n}}if(a){const t=e.getMutableAttribute(m.POSITION).data;for(let e=0;e<a.length;e+=3){const n=a[e+1];t[e+1]=-a[e+2],t[e+2]=n}}return e},N.makeOrthoBasisDirUp=v,N.makeOrthoBasisDirUpFallback=L}(x||(x={}));const T=.99619469809,p=h(),v=x;export{v as G};
