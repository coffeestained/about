/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import"../geometry.js";import{open as r}from"../core/workers/workers.js";import t from"./Point.js";import{fromJSON as n}from"./support/jsonUtils.js";import"../chunks/ensureType.js";import"../core/lang.js";import"../chunks/maybe.js";import"../chunks/Logger.js";import"../config.js";import"../chunks/object.js";import"../chunks/string.js";import"./Extent.js";import"../chunks/tslib.es6.js";import"../core/accessorSupport/decorators/property.js";import"../chunks/get.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../core/Error.js";import"../core/accessorSupport/decorators/subclass.js";import"../chunks/tracking.js";import"./Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../chunks/ArrayPool.js";import"../chunks/watch.js";import"../core/scheduling.js";import"../chunks/nextTick.js";import"../core/promiseUtils.js";import"../chunks/reader.js";import"./SpatialReference.js";import"../chunks/writer.js";import"./support/webMercatorUtils.js";import"../chunks/Ellipsoid.js";import"../core/accessorSupport/decorators/cast.js";import"./Multipoint.js";import"../chunks/zmUtils.js";import"./Polygon.js";import"../chunks/extentUtils.js";import"./Polyline.js";import"../chunks/typeUtils.js";import"../chunks/jsonMap.js";import"../core/workers/Connection.js";import"../chunks/Queue.js";import"../core/workers/RemoteClient.js";import"../kernel.js";import"../core/urlUtils.js";import"../chunks/assets.js";import"../request.js";import"../intl.js";import"../chunks/number2.js";import"../chunks/locale.js";import"../chunks/messages.js";function e(r){return Array.isArray(r)?r[0]?.spatialReference:r?.spatialReference}function o(r){return r?Array.isArray(r)?r.map(o):r.toJSON?r.toJSON():r:r}function i(r){return Array.isArray(r)?r.map((r=>n(r))):n(r)}let s;async function c(t,n){return(await async function(){return s||(s=r("geometryEngineWorker",{strategy:"distributed"})),s}()).invoke("executeGEOperation",{operation:t,parameters:o(n)})}function a(r){return c("extendedSpatialReferenceInfo",[r])}async function u(r,t){return i(await c("clip",[e(r),r,t]))}async function p(r,t){return i(await c("cut",[e(r),r,t]))}function m(r,t){return c("contains",[e(r),r,t])}function f(r,t){return c("crosses",[e(r),r,t])}function l(r,t,n){return c("distance",[e(r),r,t,n])}function j(r,t){return c("equals",[e(r),r,t])}function y(r,t){return c("intersects",[e(r),r,t])}function h(r,t){return c("touches",[e(r),r,t])}function k(r,t){return c("within",[e(r),r,t])}function w(r,t){return c("disjoint",[e(r),r,t])}function d(r,t){return c("overlaps",[e(r),r,t])}function g(r,t,n){return c("relate",[e(r),r,t,n])}function S(r){return c("isSimple",[e(r),r])}async function A(r){return i(await c("simplify",[e(r),r]))}async function x(r,t=!1){return i(await c("convexHull",[e(r),r,t]))}async function E(r,t){return i(await c("difference",[e(r),r,t]))}async function O(r,t){return i(await c("symmetricDifference",[e(r),r,t]))}async function R(r,t){return i(await c("intersect",[e(r),r,t]))}async function J(r,t=null){const n=function(r,t){let n;return Array.isArray(r)?n=r:(n=[],n.push(r),null!=t&&n.push(t)),n}(r,t);return i(await c("union",[e(n),n]))}async function N(r,t,n,o,s,a){return i(await c("offset",[e(r),r,t,n,o,s,a]))}async function b(r,t,n,o=!1){const s=[e(r),r,t,n,o];return i(await c("buffer",s))}async function U(r,t,n,o,s,a){const u=[e(r),r,t,n,o,s,a];return i(await c("geodesicBuffer",u))}async function I(r,n,o=!0){const i=await c("nearestCoordinate",[e(r),r,n,o]);return{...i,coordinate:t.fromJSON(i.coordinate)}}async function P(r,n){const o=await c("nearestVertex",[e(r),r,n]);return{...o,coordinate:t.fromJSON(o.coordinate)}}async function v(r,n,o,i){return(await c("nearestVertices",[e(r),r,n,o,i])).map((r=>({...r,coordinate:t.fromJSON(r.coordinate)})))}function z(r){return"xmin"in r?r.center:"x"in r?r:r.extent.center}async function C(r,t,n){if(null==r)throw new Error("Illegal Argument Exception");const e=r.spatialReference;n=n??z(r);const o=r.constructor.fromJSON(await c("rotate",[e,r,t,n]));return o.spatialReference=e,o}async function L(r,t){if(null==r)throw new Error("Illegal Argument Exception");const n=r.spatialReference;t=t??z(r);const e=r.constructor.fromJSON(await c("flipHorizontal",[n,r,t]));return e.spatialReference=n,e}async function M(r,t){if(null==r)throw new Error("Illegal Argument Exception");const n=r.spatialReference;t=t??z(r);const e=r.constructor.fromJSON(await c("flipVertical",[n,r,t]));return e.spatialReference=n,e}async function V(r,t,n,o){return i(await c("generalize",[e(r),r,t,n,o]))}async function q(r,t,n){return i(await c("densify",[e(r),r,t,n]))}async function D(r,t,n,o=0){return i(await c("geodesicDensify",[e(r),r,t,n,o]))}function G(r,t){return c("planarArea",[e(r),r,t])}function H(r,t){return c("planarLength",[e(r),r,t])}function T(r,t,n){return c("geodesicArea",[e(r),r,t,n])}function B(r,t,n){return c("geodesicLength",[e(r),r,t,n])}export{b as buffer,u as clip,m as contains,x as convexHull,f as crosses,p as cut,q as densify,E as difference,w as disjoint,l as distance,j as equals,a as extendedSpatialReferenceInfo,L as flipHorizontal,M as flipVertical,V as generalize,T as geodesicArea,U as geodesicBuffer,D as geodesicDensify,B as geodesicLength,R as intersect,y as intersects,S as isSimple,I as nearestCoordinate,P as nearestVertex,v as nearestVertices,N as offset,d as overlaps,G as planarArea,H as planarLength,g as relate,C as rotate,A as simplify,O as symmetricDifference,h as touches,J as union,k as within};
