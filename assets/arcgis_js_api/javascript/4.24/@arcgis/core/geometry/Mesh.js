/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import e from"../core/Error.js";import{HandleOwnerMixin as r}from"../core/HandleOwner.js";import n from"../core/Loadable.js";import{L as o}from"../chunks/Logger.js";import{i as s,a as i}from"../chunks/maybe.js";import{EsriPromiseMixin as a}from"../core/Promise.js";import{whenOrAbort as c,eachAlwaysValues as l,isAborted as p,throwIfAborted as u}from"../core/promiseUtils.js";import{watch as h}from"../core/reactiveUtils.js";import{property as f}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"../chunks/ensureType.js";import{subclass as m}from"../core/accessorSupport/decorators/subclass.js";import{h as g,b as d,F as x,n as y,s as w,d as j,w as b,Z as v,o as A,f as k}from"../chunks/mathUtils.js";import M from"./Extent.js";import R from"./Geometry.js";import F from"./Point.js";import P from"./Polygon.js";import{c as O,a as U,b as z,d as L,f as C}from"../chunks/axisAngleDegrees.js";import S,{M as $}from"./support/MeshComponent.js";import{i as T,u as I,g as B,a as E,M as G}from"../chunks/georeference.js";import{t as Z}from"../chunks/triangulationUtils.js";import{projectPointToVector as q,computeTranslationToOriginAndRotation as D}from"./projection.js";import{makeRelative as V,removeFile as H}from"../core/urlUtils.js";import{f as N}from"../chunks/mat3.js";import{b as W}from"../chunks/quatf64.js";import{c as _}from"../chunks/mat4f64.js";import{c as J}from"../chunks/projectionEllipsoid.js";import{p as K,a as Q,b as X,c as Y,d as tt,e as et}from"../chunks/projection.js";import{h as rt}from"../chunks/mat4.js";import"../chunks/object.js";import"../config.js";import"../chunks/string.js";import"../core/Accessor.js";import"../chunks/get.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../chunks/ArrayPool.js";import"../chunks/tracking.js";import"../chunks/watch.js";import"../core/scheduling.js";import"../chunks/nextTick.js";import"../core/Handles.js";import"../core/Collection.js";import"../core/Evented.js";import"../chunks/shared.js";import"../chunks/SimpleObservable.js";import"../chunks/common.js";import"./SpatialReference.js";import"../core/JSONSupport.js";import"../chunks/writer.js";import"./support/webMercatorUtils.js";import"../chunks/Ellipsoid.js";import"../chunks/reader.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/extentUtils.js";import"../chunks/zmUtils.js";import"../chunks/quat.js";import"./support/MeshMaterial.js";import"../Color.js";import"../chunks/colorUtils.js";import"./support/MeshTexture.js";import"../chunks/persistableUrlUtils.js";import"../chunks/screenshotUtils.js";import"./support/MeshMaterialMetallicRoughness.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/BufferView.js";import"../chunks/vec2.js";import"../chunks/vec3.js";import"../chunks/earcut.js";import"../chunks/deduplicate.js";import"./Multipoint.js";import"../chunks/pe.js";import"../chunks/assets.js";import"../request.js";import"../kernel.js";import"./Polyline.js";import"../chunks/aaBoundingRect.js";import"../chunks/geodesicConstants.js";import"./support/GeographicTransformation.js";import"./support/GeographicTransformationStep.js";import"../chunks/zscale.js";const nt=o.getLogger("esri.geometry.support.meshUtils.centerAt"),ot=g(),st=g();function it(t){const e=H(t.url);return r=>{const n=V(r,e,e),o=n?n.replace(/^ *\.\//,""):null;return t.files.get(o)??r}}async function at(t,r){return t instanceof Blob?ct.fromBlob(t):"string"==typeof t?new ct(t):Array.isArray(t)?async function(t,r){const n=new Map;let o=null;const s=await l(t.map((async t=>({name:t.name,source:await at(t instanceof Blob?t:t.source,r)})))),a=[];for(const t of s)t&&(p(r)?t.source.dispose():a.push(t));u(r);for(const{name:t,source:e}of a)(i(o)||/\.(gltf|glb)/i.test(t))&&(o=e.url),n.set(t,e.url),e.files&&e.files.forEach(((t,e)=>n.set(e,t)));if(i(o))throw new e("mesh-load-external:missing-files","Missing files to load external mesh source");return new ct(o,(()=>a.forEach((({source:t})=>t.dispose()))),n)}(t,r):async function(t,e){const{default:r}=await c(import("../request.js").then((t=>t.r)),e),n="string"==typeof t.multipart[0]?await Promise.all(t.multipart.map((async t=>(await r(t,{responseType:"array-buffer"})).data))):t.multipart;return ct.fromBlob(new Blob(n))}(t,r)}class ct{constructor(t,e=(()=>{}),r=new Map){this.url=t,this.dispose=e,this.files=r}static fromBlob(t){const e=URL.createObjectURL(t);return new ct(e,(()=>URL.revokeObjectURL(e)))}}const lt=o.getLogger("esri.geometry.support.meshUtils.offset");function pt(t,e){if(t)for(let r=0;r<t.length;r+=3)for(let n=0;n<3;n++)t[r+n]+=e[n]}const ut=g(),ht=_(),ft=W(),mt={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function gt(t,e,r){t.isPlane||function(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5}(t),function(t,e){if(null==e)return;const r="number"==typeof e?[e,e,e]:[null!=e.width?e.width:1,null!=e.depth?e.depth:1,null!=e.height?e.height:1];wt[0]=r[0],wt[4]=r[1],wt[8]=r[2];for(let e=0;e<t.position.length;e+=3){for(let r=0;r<3;r++)yt[r]=t.position[e+r];x(yt,yt,wt);for(let r=0;r<3;r++)t.position[e+r]=yt[r]}if(r[0]!==r[1]||r[1]!==r[2]){wt[0]=1/r[0],wt[4]=1/r[1],wt[8]=1/r[2];for(let e=0;e<t.normal.length;e+=3){for(let r=0;r<3;r++)yt[r]=t.normal[e+r];x(yt,yt,wt),y(yt,yt);for(let r=0;r<3;r++)t.normal[e+r]=yt[r]}}}(t,r&&r.size);const{vertexAttributes:n,transform:o}=E(t,e,r);return{vertexAttributes:new $({...n,uv:t.uv}),transform:o,components:[new S({faces:t.faces,material:r&&r.material||null})],spatialReference:e.spatialReference}}const dt={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},xt={south:0,east:1,north:2,west:3,up:4,down:5},yt=g(),wt=W(),jt=o.getLogger("esri.geometry.support.meshUtils.rotate");function bt(t,e,r,n=v){if(!i(t)){rt(Mt,L(e),z(e));for(let e=0;e<t.length;e+=r){for(let r=0;r<3;r++)vt[r]=t[e+r]-n[r];b(vt,vt,Mt);for(let r=0;r<3;r++)t[e+r]=vt[r]+n[r]}}}const vt=g(),At=g(),kt=O(),Mt=_(),Rt=W(),Ft=g(),Pt=o.getLogger("esri.geometry.support.meshUtils.scale");function Ot(t,e,r=v){if(t)for(let n=0;n<t.length;n+=3){for(let e=0;e<3;e++)Ut[e]=t[n+e]-r[e];A(Ut,Ut,e);for(let e=0;e<3;e++)t[n+e]=Ut[e]+r[e]}}const Ut=g(),zt=g(),Lt=g();var Ct;const St=o.getLogger("esri.geometry.Mesh");let $t=Ct=class extends(r(n.LoadableMixin(a(R)))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new $,this.type="mesh"}initialize(){(i(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.handles.add(h((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((t=>t.clone())),transform:s(this.transform)?this.transform.clone():null})),(()=>this._set("external",null)),{once:!0,sync:!0}))}))}get hasExtent(){return!this.loaded&&s(this.external)&&s(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const t=this.vertexAttributes.position,e=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new M({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:e}),center:new F({x:0,y:0,z:0,spatialReference:e})};const r=s(this.transform)?this.transform.project(t,e):t;let n=1/0,o=1/0,i=1/0,a=-1/0,c=-1/0,l=-1/0,p=0,u=0,h=0;const f=r.length,m=1/(f/3);let g=0;for(;g<f;){const t=r[g++],e=r[g++],s=r[g++];n=Math.min(n,t),o=Math.min(o,e),i=Math.min(i,s),a=Math.max(a,t),c=Math.max(c,e),l=Math.max(l,s),p+=m*t,u+=m*e,h+=m*s}return{extent:new M({xmin:n,ymin:o,zmin:i,xmax:a,ymax:c,zmax:l,spatialReference:e}),center:new F({x:p,y:u,z:h,spatialReference:e})}}get anchor(){if(s(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this.boundingInfo;return new F({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return s(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&s(this.external)&&s(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(S.from(t)),this.notifyChange("components")):St.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return this.components.splice(e,1),void this.notifyChange("components")}St.error("removeComponent()","Provided component is not part of the list of components")}else St.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,e,r,n){return C(Tt.x,t,It),C(Tt.y,e,Bt),C(Tt.z,r,Et),U(It,Bt,It),U(It,Et,It),function(t,e,r){if(!t.vertexAttributes||!t.vertexAttributes.position||0===e[3])return;const n=t.spatialReference;if(s(t.transform)){null!=r?.geographic&&r.geographic!==t.transform.geographic&&jt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=r?.origin??t.transform.getOriginPoint(n);!function(t,e,r){const n=w(vt,r.x,r.y,r.z),o=j(vt,n,t.origin);t.applyLocalInverse(o,At),t.rotation=U(t.rotation,e,O()),t.applyLocalInverse(o,o),j(o,o,At),t.translation=d(g(),t.translation,o)}(t.transform,e,o)}else{const n=r?.origin??t.origin;T(t.spatialReference,r)?function(t,e,r){const n=t.spatialReference,o=J(n),i=Ft;q(r,i,o)||q(t.origin,i,o);const a=t.vertexAttributes.position,c=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,p=new Float64Array(a.length),u=s(c)?new Float32Array(c.length):null,h=s(l)?new Float32Array(l.length):null;D(o,i,Mt,o),N(Rt,Mt);const f=kt;x(z(kt),z(e),Rt),f[3]=e[3],K(a,n,p),s(c)&&Q(c,a,p,n,u),s(l)&&X(l,a,p,n,h),bt(p,f,3,i),Y(p,a,n),s(c)&&(bt(u,f,3),tt(u,a,p,n,c)),s(l)&&(bt(h,f,4),et(h,a,p,n,l)),t.vertexAttributesChanged()}(t,e,n):function(t,e,r){const n=Ft;if(!q(r,n,t.spatialReference)){const e=t.origin;n[0]=e.x,n[1]=e.y,n[2]=e.z,jt.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}bt(t.vertexAttributes.position,e,3,n),bt(t.vertexAttributes.normal,e,3),bt(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}(t,e,n)}}(this,It,n),this}offset(t,e,r,n){return this.loaded?(Gt[0]=t,Gt[1]=e,Gt[2]=r,function(t,e,r){t.vertexAttributes&&t.vertexAttributes.position&&(s(t.transform)?(null!=r?.geographic&&r.geographic!==t.transform.geographic&&lt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e){const r=t.origin;t.origin=d(g(),r,e)}(t.transform,e)):T(t.spatialReference,r)?function(t,e){const r=t.spatialReference,n=t.vertexAttributes.position,o=t.vertexAttributes.normal,i=t.vertexAttributes.tangent,a=new Float64Array(n.length),c=s(o)?new Float32Array(o.length):null,l=s(i)?new Float32Array(i.length):null,p=t.extent.center,u=ut;D(r,[p.x,p.y,p.z],ht,J(r)),N(ft,ht),x(u,e,ft),K(n,r,a),s(o)&&Q(o,n,a,r,c),s(i)&&X(i,n,a,r,l),pt(a,u),Y(a,n,r),s(o)&&tt(c,n,a,r,o),s(i)&&et(l,n,a,r,i),t.vertexAttributesChanged()}(t,e):function(t,e){pt(t.vertexAttributes.position,e),t.vertexAttributesChanged()}(t,e))}(this,Gt,n),this):(St.error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,e){return this.loaded?(function(t,e,r){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const n=t.spatialReference;if(s(t.transform)){null!=r?.geographic&&r.geographic!==t.transform.geographic&&Pt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=r?.origin??t.transform.getOriginPoint(n);!function(t,e,r){const n=w(Ut,r.x,r.y,r.z),o=j(Ut,n,t.origin);t.applyLocalInverse(o,zt);const s=A(g(),t.scale,e);t.scale=s,t.applyLocalInverse(o,o),j(o,o,zt),t.translation=d(g(),t.translation,o)}(t.transform,e,o)}else{const n=T(t.spatialReference,r),o=r&&r.origin||t.origin;n?function(t,e,r){const n=t.spatialReference,o=J(n),i=Lt;q(r,i,o)||q(t.origin,i,o);const a=t.vertexAttributes.position,c=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,p=new Float64Array(a.length),u=s(c)?new Float32Array(c.length):null,h=s(l)?new Float32Array(l.length):null;K(a,n,p),s(c)&&Q(c,a,p,n,u),s(l)&&X(l,a,p,n,h),Ot(p,e,i),Y(p,a,n),s(c)&&tt(u,a,p,n,c),s(l)&&et(h,a,p,n,l),t.vertexAttributesChanged()}(t,e,o):function(t,e,r){const n=Lt;if(!q(r,n,t.spatialReference)){const e=t.origin;n[0]=e.x,n[1]=e.y,n[2]=e.z,Pt.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Ot(t.vertexAttributes.position,e,n),t.vertexAttributesChanged()}(t,e,o)}}(this,t,e),this):(St.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,e){return this.loaded?(function(t,e,r){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const n=r?.origin??t.origin;s(t.transform)?(null!=r?.geographic&&r.geographic!==t.transform.geographic&&nt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e,r){const n=e.x-r.x,o=e.y-r.y,s=e.hasZ&&r.hasZ?e.z-r.z:0,i=t.origin;t.origin=[i[0]+n,i[1]+o,i[2]+s]}(t.transform,e,n)):T(t.spatialReference,r)?function(t,e,r){const n=I(t.vertexAttributes,r,{geographic:!0}),{position:o,normal:s,tangent:i}=B(n,e,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=s,t.vertexAttributes.tangent=i,t.vertexAttributesChanged()}(t,e,n):function(t,e,r){const n=st,o=ot;if(q(e,o,t.spatialReference)){if(!q(r,n,t.spatialReference)){const e=t.origin;n[0]=e.x,n[1]=e.y,n[2]=e.z,nt.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function(t,e,r){if(t)for(let n=0;n<t.length;n+=3)for(let o=0;o<3;o++)t[n+o]+=e[o]-r[o]})(t.vertexAttributes.position,o,n),t.vertexAttributesChanged()}else nt.error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`)}(t,e,n)}(this,t,e),this):(St.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return s(this.external)&&this.addResolvingPromise(async function(t,e,r){const{loadGLTFMesh:n}=await c(import("../chunks/loadGLTFMesh.js"),r),o=await at(e,r),i=n(new F({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:it(o),useTransform:!0,signal:s(r)?r.signal:null});i.then((()=>o.dispose()),(()=>o.dispose()));const{vertexAttributes:a,components:l}=await i;t.vertexAttributes=a,t.components=l}(this,this.external.source,t)),Promise.resolve(this)}clone(){const t=this.components?new Map:null,e=this.components?new Map:null,r={components:this.components?this.components.map((r=>r.cloneWithDeduplication(t,e))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:s(this.transform)?this.transform.clone():null,external:s(this.external)?{source:this.external.source,extent:s(this.external.extent)?this.external.extent.clone():null}:null};return new Ct(r)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const{toBinaryGLTF:e}=await import("../chunks/gltfexport.js");return e(this,t)}static createBox(t,e){if(!(t instanceof F))return St.error(".createBox()","expected location to be a Point instance"),null;const r=new Ct(gt(function(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:r}=dt,n=4*t.length,o=new Float64Array(3*n),s=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array(2*t.length*3);let c=0,l=0,p=0,u=0;for(let n=0;n<t.length;n++){const h=t[n],f=c/3;for(const t of e)a[u++]=f+t;const m=h.corners;for(let t=0;t<4;t++){const e=m[t];let n=0;i[p++]=.25*r[t][0]+h.uvOrigin[0],i[p++]=h.uvOrigin[1]-.25*r[t][1];for(let t=0;t<3;t++)0!==h.axis[t]?(o[c++]=.5*h.axis[t],s[l++]=h.axis[t]):(o[c++]=.5*e[n++],s[l++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),t,e));return e&&e.imageFace&&"all"!==e.imageFace?function(t,e){const r=t.components[0],n=r.faces,o=xt[e],i=6*o,a=new Uint32Array(6),c=new Uint32Array(n.length-6);let l=0,p=0;for(let t=0;t<n.length;t++)t>=i&&t<i+6?a[l++]=n[t]:c[p++]=n[t];if(s(t.vertexAttributes.uv)){const e=new Float32Array(t.vertexAttributes.uv),r=4*o*2,n=[0,1,1,1,1,0,0,0];for(let t=0;t<n.length;t++)e[r+t]=n[t];t.vertexAttributes.uv=e}return t.components=[new S({faces:a,material:r.material}),new S({faces:c})],t}(r,e.imageFace):r}static createSphere(t,e){return t instanceof F?new Ct(gt(function(t=0){const e=Math.round(8*2**t),r=2*e,n=(e-1)*(r+1)+2*r,o=new Float64Array(3*n),s=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array((e-1)*r*2*3);let c=0,l=0,p=0,u=0;for(let t=0;t<=e;t++){const n=t/e*Math.PI+.5*Math.PI,h=Math.cos(n),f=Math.sin(n);yt[2]=f;const m=0===t||t===e,g=m?r-1:r;for(let n=0;n<=g;n++){const f=n/g*2*Math.PI;yt[0]=-Math.sin(f)*h,yt[1]=Math.cos(f)*h;for(let t=0;t<3;t++)o[c]=.5*yt[t],s[c]=yt[t],++c;i[l++]=(n+(m?.5:0))/r,i[l++]=t/e,0!==t&&n!==r&&(t!==e&&(a[p++]=u,a[p++]=u+1,a[p++]=u-r),1!==t&&(a[p++]=u,a[p++]=u-r,a[p++]=u-r-1)),u++}}return{position:o,normal:s,uv:i,faces:a}}(e&&e.densificationFactor||0),t,e)):(St.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,e){return t instanceof F?new Ct(gt(function(t=0){const e=Math.round(16*2**t),r=4*(e+1)+2*e,n=new Float64Array(3*r),o=new Float32Array(3*r),s=new Float32Array(2*r),i=new Uint32Array(4*e*3);let a=0,c=0,l=0,p=0,u=0;for(let t=0;t<=5;t++){const r=0===t||5===t,h=t<=1||t>=4,f=2===t||4===t,m=r?e-1:e;for(let g=0;g<=m;g++){const d=g/m*2*Math.PI,x=r?0:.5;yt[0]=x*Math.sin(d),yt[1]=x*-Math.cos(d),yt[2]=t<=2?.5:-.5;for(let e=0;e<3;e++)n[a++]=yt[e],o[c++]=h?2===e?t<=1?1:-1:0:2===e?0:yt[e]/x;s[l++]=(g+(r?.5:0))/e,s[l++]=t<=1?1*t/3:t<=3?1*(t-2)/3+1/3:1*(t-4)/3+2/3,f||0===t||g===e||(5!==t&&(i[p++]=u,i[p++]=u+1,i[p++]=u-e),1!==t&&(i[p++]=u,i[p++]=u-e,i[p++]=u-e-1)),u++}}return{position:n,normal:o,uv:s,faces:i}}(e&&e.densificationFactor||0),t,e)):(St.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,e){if(!(t instanceof F))return St.error(".createPlane()","expected location to be a Point instance"),null;const r=e?.facing??"up",n=function(t,e){const r="number"==typeof e?e:null!=e?e.width:1,n="number"==typeof e?e:null!=e?e.height:1;switch(t){case"up":case"down":return{width:r,depth:n};case"north":case"south":return{width:r,height:n};case"east":case"west":return{depth:r,height:n}}}(r,e?.size);return new Ct(gt(function(t){const e=mt.facingAxisOrderSwap[t],r=mt.position,n=mt.normal,o=new Float64Array(r.length),s=new Float32Array(n.length);let i=0;for(let t=0;t<4;t++){const t=i;for(let a=0;a<3;a++){const c=e[a],l=Math.abs(c)-1,p=c>=0?1:-1;o[i]=r[t+l]*p,s[i]=n[t+l]*p,i++}}return{position:o,normal:s,uv:new Float32Array(mt.uv),faces:new Uint32Array(mt.faces),isPlane:!0}}(r),t,{...e,size:n}))}static createFromPolygon(t,e){if(!(t instanceof P))return St.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const r=Z(t);return new Ct({vertexAttributes:new $({position:r.position}),components:[new S({faces:r.faces,shading:"flat",material:e&&e.material||null})],spatialReference:t.spatialReference})}static async createFromGLTF(t,r,n){if(!(t instanceof F))throw St.error(".createfromGLTF()","expected location to be a Point instance"),new e("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:o}=await c(import("../chunks/loadGLTFMesh.js"),n);return new Ct(await o(t,r,n))}static createWithExternalSource(t,e,r){const n=r?.extent??null,o=r?.transform.clone()??new G;o.origin=[t.x,t.y,t.z??0];const s=t.spatialReference;return new Ct({external:{source:e,extent:n},transform:o,spatialReference:s})}static createIncomplete(t,r){const n=r?.transform.clone()??new G;n.origin=[t.x,t.y,t.z??0];const o=t.spatialReference,s=new Ct({transform:n,spatialReference:o});return s.addResolvingPromise(Promise.reject(new e("mesh-incomplete","Mesh resources are not complete"))),s}};t([f({type:[S],json:{write:!0}})],$t.prototype,"components",void 0),t([f({type:G,json:{write:!0}})],$t.prototype,"transform",void 0),t([f({constructOnly:!0})],$t.prototype,"external",void 0),t([f({readOnly:!0})],$t.prototype,"hasExtent",null),t([f({readOnly:!0})],$t.prototype,"boundingInfo",null),t([f({readOnly:!0})],$t.prototype,"anchor",null),t([f({readOnly:!0})],$t.prototype,"origin",null),t([f({readOnly:!0,json:{read:!1}})],$t.prototype,"extent",null),t([f({readOnly:!0,json:{read:!1,write:!0,default:!0}})],$t.prototype,"hasZ",void 0),t([f({readOnly:!0,json:{read:!1,write:!0,default:!1}})],$t.prototype,"hasM",void 0),t([f({type:$,nonNullable:!0,json:{write:!0}})],$t.prototype,"vertexAttributes",void 0),$t=Ct=t([m("esri.geometry.Mesh")],$t);const Tt={x:k(1,0,0),y:k(0,1,0),z:k(0,0,1)},It=O(),Bt=O(),Et=O(),Gt=g(),Zt=$t;export{Zt as default};
