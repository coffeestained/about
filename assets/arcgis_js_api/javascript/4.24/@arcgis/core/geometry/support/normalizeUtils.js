/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import t from"../../config.js";import e from"../../core/Error.js";import{L as s}from"../../chunks/Logger.js";import{a as n,i as r}from"../../chunks/maybe.js";import o from"../Polygon.js";import i from"../Polyline.js";import{g as c,c as p,o as l,u}from"../../chunks/normalizeUtilsCommon.js";import{g as f}from"../SpatialReference.js";import{geographicToWebMercator as a,webMercatorToGeographic as m}from"./webMercatorUtils.js";import"../../geometry.js";import h from"../../request.js";import{urlToObject as g}from"../../core/urlUtils.js";import{getJsonType as y,fromJSON as j,getGeometryType as x}from"./jsonUtils.js";import"../../core/lang.js";import"../../chunks/object.js";import"../../chunks/string.js";import"../../chunks/tslib.es6.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/ensureType.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/tracking.js";import"../../chunks/writer.js";import"../Extent.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../chunks/ArrayPool.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/Ellipsoid.js";import"../../chunks/extentUtils.js";import"../../chunks/zmUtils.js";import"../Multipoint.js";import"../../chunks/typeUtils.js";import"../../chunks/jsonMap.js";import"../../kernel.js";function d(t){return{geometryType:y(t[0]),geometries:t.map((t=>t.toJSON()))}}const k=s.getLogger("esri.geometry.support.normalizeUtils");function w(t){const e=[];let s=0,n=0;for(let r=0;r<t.length;r++){const o=t[r];let i=null;for(let t=0;t<o.length;t++)i=o[t],e.push(i),0===t?(s=i[0],n=s):(s=Math.min(s,i[0]),n=Math.max(n,i[0]));i&&e.push([(s+n)/2,0])}return e}function S(t,s){if(!(t instanceof i||t instanceof o)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw k.error(t),new e(t)}const n=c(t),r=[];for(const t of n){const e=[];r.push(e),e.push([t[0][0],t[0][1]]);for(let n=0;n<t.length-1;n++){const r=t[n][0],o=t[n][1],i=t[n+1][0],c=t[n+1][1],p=Math.sqrt((i-r)*(i-r)+(c-o)*(c-o)),l=(c-o)/p,u=(i-r)/p,f=p/s;if(f>1){for(let t=1;t<=f-1;t++){const n=t*s,i=u*n+r,c=l*n+o;e.push([i,c])}const t=(p+Math.floor(f-1)*s)/2,n=u*t+r,i=l*t+o;e.push([n,i])}e.push([i,c])}}return function(t){return"polygon"===t.type}(t)?new o({rings:r,spatialReference:t.spatialReference}):new i({paths:r,spatialReference:t.spatialReference})}function R(t,e,s){if(e){const e=S(t,1e6);t=m(e,!0)}return s&&(t=u(t,s)),t}function M(t,e,s){if(Array.isArray(t)){const n=t[0];if(n>e){const s=l(n,e);t[0]=n+s*(-2*e)}else if(n<s){const e=l(n,s);t[0]=n+e*(-2*s)}}else{const n=t.x;if(n>e){const s=l(n,e);t=t.clone().offset(s*(-2*e),0)}else if(n<s){const e=l(n,s);t=t.clone().offset(e*(-2*s),0)}}return t}async function U(e,s,m){if(!Array.isArray(e))return U([e],s);s&&"string"!=typeof s&&k.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const w="string"==typeof s?s:s?.url??t.geometryServiceUrl;let S,b,N,J,O,P,q,A,L=0;const z=[],T=[];for(const t of e)if(n(t))T.push(t);else if(S||(S=t.spatialReference,b=f(S),N=S.isWebMercator,P=N?102100:4326,J=p[P].maxX,O=p[P].minX,q=p[P].plus180Line,A=p[P].minus180Line),b)if("mesh"===t.type)T.push(t);else if("point"===t.type)T.push(M(t.clone(),J,O));else if("multipoint"===t.type){const e=t.clone();e.points=e.points.map((t=>M(t,J,O))),T.push(e)}else if("extent"===t.type){const e=t.clone()._normalize(!1,!1,b);T.push(e.rings?new o(e):e)}else if(t.extent){const e=t.extent,s=l(e.xmin,O)*(2*J);let n=0===s?t.clone():u(t.clone(),s);e.offset(s,0),e.intersects(q)&&e.xmax!==J?(L=e.xmax>L?e.xmax:L,n=R(n,N),z.push(n),T.push("cut")):e.intersects(A)&&e.xmin!==O?(L=e.xmax*(2*J)>L?e.xmax*(2*J):L,n=R(n,N,360),z.push(n),T.push("cut")):T.push(n)}else T.push(t.clone());else T.push(t);let I=l(L,J),v=-90;const E=I,C=new i;for(;I>0;){const t=360*I-180;C.addPath([[t,v],[t,-1*v]]),v*=-1,I--}if(z.length>0&&E>0){const t=await async function(t,e,s,n){const r="string"==typeof t?g(t):t,o=e[0].spatialReference,i={...n,query:{...r.query,f:"json",sr:JSON.stringify(o),target:JSON.stringify({geometryType:y(e[0]),geometries:e}),cutter:JSON.stringify(s)}},c=await h(r.path+"/cut",i),{cutIndexes:p,geometries:l=[]}=c.data;return{cutIndexes:p,geometries:l.map((t=>{const e=j(t);return e.spatialReference=o,e}))}}(w,z,C,m),s=function(t,e){let s=-1;for(let n=0;n<e.cutIndexes.length;n++){const r=e.cutIndexes[n],o=e.geometries[n],i=c(o);for(let t=0;t<i.length;t++){const e=i[t];e.some((s=>{if(s[0]<180)return!0;{let s=0;for(let t=0;t<e.length;t++){const n=e[t][0];s=n>s?n:s}s=Number(s.toFixed(9));const n=-360*l(s,180);for(let s=0;s<e.length;s++){const e=o.getPoint(t,s);o.setPoint(t,s,e.clone().offset(n,0))}return!0}}))}if(r===s){if("polygon"===t[0].type)for(const e of c(o))t[r]=t[r].addRing(e);else if("polyline"===t[0].type)for(const e of c(o))t[r]=t[r].addPath(e)}else s=r,t[r]=o}return t}(z,t),n=[],o=[];for(let t=0;t<T.length;t++){const i=T[t];if("cut"!==i)o.push(i);else{const i=s.shift(),c=e[t];r(c)&&"polygon"===c.type&&c.rings&&c.rings.length>1&&i.rings.length>=c.rings.length?(n.push(i),o.push("simplify")):o.push(N?a(i):i)}}if(!n.length)return o;const i=await async function(t,e,s){const n="string"==typeof t?g(t):t,r=e[0].spatialReference,o=y(e[0]),i={...s,query:{...n.query,f:"json",sr:r.wkid?r.wkid:JSON.stringify(r),geometries:JSON.stringify(d(e))}};return function(t,e,s){const n=x(e);return t.map((t=>{const e=n.fromJSON(t);return e.spatialReference=s,e}))}((await h(n.path+"/simplify",i)).data,o,r)}(w,n,m),p=[];for(let t=0;t<o.length;t++){const e=o[t];"simplify"!==e?p.push(e):p.push(N?a(i.shift()):i.shift())}return p}const X=[];for(let t=0;t<T.length;t++){const e=T[t];if("cut"!==e)X.push(e);else{const t=z.shift();X.push(!0===N?a(t):t)}}return X}function b(t){if(!t)return null;const e=t.extent;if(!e)return null;const s=t.spatialReference&&f(t.spatialReference);if(!s)return e;const[n,r]=s.valid,o=2*r,{width:i}=e;let c,{xmin:p,xmax:l}=e;if([p,l]=[l,p],"extent"===t.type||0===i||i<=r||i>o||p<n||l>r)return e;switch(t.type){case"polygon":if(!(t.rings.length>1))return e;c=w(t.rings);break;case"polyline":if(!(t.paths.length>1))return e;c=w(t.paths);break;case"multipoint":c=t.points}const u=e.clone();for(let t=0;t<c.length;t++){let e=c[t][0];e<0?(e+=r,l=Math.max(e,l)):(e-=r,p=Math.min(e,p))}return u.xmin=p,u.xmax=l,u.width<i?(u.xmin-=r,u.xmax-=r,u):e}function N(t,e){const s=f(e);if(s){const[e,n]=s.valid,r=n-e;if(t<e)for(;t<e;)t+=r;if(t>n)for(;t>n;)t-=r}return t}export{b as getDenormalizedExtent,U as normalizeCentralMeridian,N as normalizeMapX,S as straightLineDensify};
