/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as r}from"../chunks/tslib.es6.js";import e from"../core/Collection.js";import{r as t}from"../chunks/collectionUtils.js";import{L as s}from"../chunks/Logger.js";import{isPromiseLike as o}from"../core/promiseUtils.js";import{property as i}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"../chunks/ensureType.js";import{subclass as n}from"../core/accessorSupport/decorators/subclass.js";import a from"../layers/Layer.js";import"../chunks/ArrayPool.js";import"../core/Evented.js";import"../core/Accessor.js";import"../chunks/maybe.js";import"../chunks/get.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../chunks/tracking.js";import"../chunks/watch.js";import"../core/scheduling.js";import"../chunks/nextTick.js";import"../core/Error.js";import"../chunks/object.js";import"../config.js";import"../chunks/string.js";import"../chunks/shared.js";import"../chunks/SimpleObservable.js";import"../geometry.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"../core/JSONSupport.js";import"../chunks/reader.js";import"../geometry/SpatialReference.js";import"../chunks/writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"../chunks/Ellipsoid.js";import"../geometry/Multipoint.js";import"../chunks/zmUtils.js";import"../geometry/Polygon.js";import"../chunks/extentUtils.js";import"../geometry/Polyline.js";import"../chunks/typeUtils.js";import"../chunks/jsonMap.js";import"../geometry/support/jsonUtils.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"../chunks/Identifiable.js";import"../core/Loadable.js";import"../core/Promise.js";function p(r,e,t){let s,o;if(r)for(let i=0,n=r.length;i<n;i++){if(s=r.getItemAt(i),s[e]===t)return s;if("group"===s?.type&&(o=p(s.layers,e,t),o))return o}}const m=s.getLogger("esri.support.LayersMixin"),l=s=>{let l=class extends s{constructor(...r){super(...r),this.layers=new e;const t=r=>{r.parent=this,this.layerAdded(r),"elevation"!==r.type&&"base-elevation"!==r.type||m.error(`Layer 'title:${r.title}, id:${r.id}' of type '${r.type}' is not supported as an operational layer and will therefore be ignored.`)},s=r=>{r.parent=null,this.layerRemoved(r)};this.layers.on("before-add",(r=>{var e;(e=r.item).parent&&"remove"in e.parent&&e.parent.remove(e)})),this.layers.on("after-add",(r=>t(r.item))),this.layers.on("after-remove",(r=>s(r.item)))}destroy(){const r=this.layers.removeAll();for(const e of r)this.layerRemoved(e),e.destroy();this.layers.destroy()}set layers(r){this._set("layers",t(r,this._get("layers")))}add(r,e){const t=this.layers;if(e=t.getNextIndex(e),r instanceof a){const s=r;s.parent===this?this.reorder(s,e):t.add(s,e)}else o(r)?r.then((r=>{this.destroyed||this.add(r,e)})):m.error("#add()","The item being added is not a Layer or a Promise that resolves to a Layer.")}addMany(r,e){const t=this.layers;e=t.getNextIndex(e),r.slice().forEach((r=>{r.parent!==this?(t.add(r,e),e+=1):this.reorder(r,e)}))}findLayerById(r){return p(this.layers,"id",r)}findLayerByUid(r){return p(this.layers,"uid",r)}remove(r){return this.layers.remove(r)}removeMany(r){return this.layers.removeMany(r)}removeAll(){return this.layers.removeAll()}reorder(r,e){return this.layers.reorder(r,e)}layerAdded(r){}layerRemoved(r){}};return r([i()],l.prototype,"layers",null),l=r([n("esri.support.LayersMixin")],l),l};export{l as LayersMixin};
