// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.24/esri/copyright.txt for details.
//>>built
define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Graphic ../../core/Accessor ../../core/Collection ../../core/Error ../../core/maybe ../../core/reactiveUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/has ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ../../rest/query/support/AttachmentInfo ../../rest/support/AttachmentQuery ../Feature/support/featureUtils".split(" "),function(n,k,y,f,z,g,A,
t,p,G,H,B,C,D,u,E){const v={editing:!1,operations:{add:!0,update:!0,delete:!0}},w=z.ofType(D);f=function(x){function q(b){var a=x.call(this,b)||this;a._getAttachmentsPromise=null;a._attachmentLayer=null;a.abilities={...v};a.activeAttachmentInfo=null;a.attachmentInfos=new w;a.graphic=null;a.mode="view";a.own(t.watch(()=>a.graphic,()=>a._graphicChanged(),t.initial));return a}n._inheritsLoose(q,x);var h=q.prototype;h.destroy=function(){this.graphic=this._attachmentLayer=null};h.castAbilities=function(b){return{...v,
...b}};h.getAttachments=function(){var b=n._asyncToGenerator(function*(){const {_attachmentLayer:a,attachmentInfos:c}=this;if(!a||"function"!==typeof a.queryAttachments)throw new g("invalid-layer","getAttachments(): A valid layer is required.");const d=this._getFeatureId();var e=new u({objectIds:[d],returnMetadata:!0});const l=[];this._getAttachmentsPromise=e=a.queryAttachments(e).then(m=>m[d]||l).catch(()=>l);this.notifyChange("state");e=yield e;c.removeAll();e.length&&c.addMany(e);this._getAttachmentsPromise=
null;this.notifyChange("state");return e});return function(){return b.apply(this,arguments)}}();h.addAttachment=function(){var b=n._asyncToGenerator(function*(a){const {_attachmentLayer:c,attachmentInfos:d,graphic:e,abilities:l}=this;if(!a)throw new g("invalid-attachment","addAttachment(): An attachment is required.",{attachment:a});if(!l.operations.add)throw new g("invalid-abilities","addAttachment(): add abilities are required.");if(!c||"function"!==typeof c.addAttachment)throw new g("invalid-layer",
"addAttachment(): A valid layer is required.");a=yield c.addAttachment(e,a).then(m=>this._queryAttachment(m.objectId));d.add(a);return a});return function(a){return b.apply(this,arguments)}}();h.deleteAttachment=function(){var b=n._asyncToGenerator(function*(a){const {_attachmentLayer:c,attachmentInfos:d,graphic:e,abilities:l}=this;if(!a)throw new g("invalid-attachment-info","deleteAttachment(): An attachmentInfo is required.",{attachmentInfo:a});if(!l.operations.delete)throw new g("invalid-abilities",
"deleteAttachment(): delete abilities are required.");if(!c||"function"!==typeof c.deleteAttachments)throw new g("invalid-layer","deleteAttachment(): A valid layer is required.");const m=yield c.deleteAttachments(e,[a.id]).then(()=>a);d.remove(m);return m});return function(a){return b.apply(this,arguments)}}();h.updateAttachment=function(){var b=n._asyncToGenerator(function*(a,c=this.activeAttachmentInfo){const {_attachmentLayer:d,attachmentInfos:e,graphic:l,abilities:m}=this;if(!a)throw new g("invalid-attachment",
"updateAttachment(): An attachment is required.",{attachment:a});if(!c)throw new g("invalid-attachment-info","updateAttachment(): An attachmentInfo is required.",{attachmentInfo:c});if(!m.operations.update)throw new g("invalid-abilities","updateAttachment(): Update abilities are required.");const F=e.findIndex(r=>r===c);if(!d||"function"!==typeof d.updateAttachment)throw new g("invalid-layer","updateAttachment(): A valid layer is required.");a=yield d.updateAttachment(l,c.id,a).then(r=>this._queryAttachment(r.objectId));
e.splice(F,1,a);return a});return function(a){return b.apply(this,arguments)}}();h._queryAttachment=function(){var b=n._asyncToGenerator(function*(a){if(!a)throw new g("invalid-attachment-id","Could not query attachment.");const {_attachmentLayer:c}=this,d=this._getFeatureId();a=new u({objectIds:[d],attachmentsWhere:`AttachmentId=${a}`,returnMetadata:!0});return c.queryAttachments(a).then(e=>e[d][0])});return function(a){return b.apply(this,arguments)}}();h._getFeatureId=function(){const {_attachmentLayer:b,
graphic:a}=this;if(!b||!a)return null;const {objectIdField:c}=b,{attributes:d}=a;return d&&d[c]};h._graphicChanged=function(){this.graphic&&(this._setAttachmentLayer(),this.getAttachments().catch(()=>{}))};h._setAttachmentLayer=function(){var {graphic:b}=this;this._attachmentLayer=(b=E.getSourceLayer(b))?"scene"===b.type&&A.isSome(b.associatedLayer)?b.associatedLayer:b:null};n._createClass(q,[{key:"state",get:function(){return this._getAttachmentsPromise?"loading":this.graphic?"ready":"disabled"}},
{key:"supportsResizeAttachments",get:function(){return this.get("graphic.layer.capabilities.operations.supportsResizeAttachments")||!1}}]);return q}(f);k.__decorate([p.property()],f.prototype,"abilities",void 0);k.__decorate([B.cast("abilities")],f.prototype,"castAbilities",null);k.__decorate([p.property()],f.prototype,"activeAttachmentInfo",void 0);k.__decorate([p.property({readOnly:!0,type:w})],f.prototype,"attachmentInfos",void 0);k.__decorate([p.property({type:y})],f.prototype,"graphic",void 0);
k.__decorate([p.property()],f.prototype,"mode",void 0);k.__decorate([p.property({readOnly:!0})],f.prototype,"state",null);k.__decorate([p.property({readOnly:!0})],f.prototype,"supportsResizeAttachments",null);return f=k.__decorate([C.subclass("esri.widgets.Attachments.AttachmentsViewModel")],f)});