// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.24/esri/copyright.txt for details.
//>>built
define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/arrayUtils ../../../core/mathUtils ../../../core/maybe ../../../geometry/support/aaBoundingBox ../../../core/has ../../../geometry/Extent ../../../geometry/support/Ellipsoid ../support/buffer/glUtil ./ElevationData ./GeometryState ./interfaces ./LayerClass ./PatchGeometry ./terrainUtils ./TextureFader ./Tile ./TileOverlayData ./tileUtils ../webgl-engine/lib/DefaultVertexAttributeLocations ../../webgl/BufferObject ../../webgl/VertexArrayObject".split(" "),
function(C,M,N,G,x,O,B,V,W,P,H,Q,X,E,I,t,F,Y,R,S,T,J,U){B=function(){function y(){this.geometryInfo=new I.PatchGeometry;this.geometryState=this.intersectionData=null;this._textureRef=new F.TextureFader(()=>this.tile.surface.textureFadeDuration);this.overlay=new R;this._geometryStateChangedSinceLastUpdate=!0;this._wireframeChanged=this._clippingAreaChanged=this._cornerElevationChanged=this._edgeNeighborChanged=this._edgeResolutionChanged=this._samplerDataChanged=this._numVerticesPerSideChanged=this._hasGeometry=
!1}var n=y.prototype;n.init=function(a){this._tile=a;this.clear();a=this.geometryInfo;a.indices=null;a.vertexAttributes=null;O.empty(a.boundingBox);a.indexCount=0;a.numVerticesPerSide=0;this.intersectionData=null;this.geometryState=new Q.GeometryState;this.localOrigin=null;this.overlay.clear()};n.clear=function(){this._releaseGeometry();this.releaseTexture();this._textureRef.clear()};n.updateGeometryIfChanged=function(a,b){b=this.updateGeometryStateAndPrepareForGeometryGeneration(b);this._hasGeometry=
!0;return this.updateNeighborDataAndGeometryIfNeeded(b,a)};n.updateNeighborDataAndGeometryIfNeeded=function(a=!1,b=this.vao.context){const d=this._updateNeighborData();if(a=a||this._geometryStateChangedSinceLastUpdate||d)this._updateGeometry(b),this._geometryStateChangedSinceLastUpdate=!1;return a};n._calculateEdgeResolution=function(a,b){const d=this.tile,g=this.geometryState.numVerticesPerSide-1;if(!d.surface.isGlobal){var f=d.surface.extent;if(x.isSome(f)&&(0===a&&d.extent[3]>f[3]||1===a&&d.extent[2]>
f[2]||2===a&&d.extent[1]<f[1]||3===a&&d.extent[0]<f[0]))return g}const l=d.level;f=t.neighborEdgeIndices[a];b=b||d.findNeighborTile(f,e=>e.isLoaded||e.level===l);if(!b||b.isLeaf&&!b.isLoaded){var u;t.internalAssert(x.isNone(null==(u=d.surface)?void 0:u.rootTiles)||d.surface.updatingRootTiles||!d.shouldHaveNeighbor(f));return g}if(b.isLoaded)return u=b.renderData.geometryState,b=l-b.level,0===b?Math.max(u.numVerticesPerSide-1,g):Math.max(1,u.neighborData.edgeResolutions[(a+2)%4]/2**b);t.internalAssert(!b.isLeaf);
let q=g;b.forAllSubtreeOnSide(t.oppositeEdge(f),e=>{if(e===d)return!0;if(e.isLoaded)return q=Math.max(q,2**(e.level-l)),!0;t.internalAssert(!e.isLeaf);return!1});return q};n._updateNeighborData=function(){const a=this.tile,b=e=>e.isLoaded||e.level===a.level,d=e=>e.isLoaded,g=[null,null,null,null],f=[null,null,null,null];(()=>{for(let e=0;4>e;++e){const r=a.findNeighborTile(t.neighborEdgeIndices[e],b);g[e]=r;f[e]=null!=r&&r.isLoaded?r:null}})();const l=[null,null,null,null];(()=>{for(let e=0;4>e;++e)l[e]=
a.findNeighborTile(t.neighborCornerIndices[e],d)})();const u=this.geometryState.neighborData;let q=!1;(()=>{for(let e=0;4>e;++e){const r=u.edgeResolutions[e],h=g[e],c=this._calculateEdgeResolution(e,h);u.edgeResolutions[e]=c;r!==c&&(this._edgeResolutionChanged=q=!0,h&&h!==a&&!h.isLoaded&&h.level===a.level&&(u.modifiedEdgeResolutions[e]=!0))}})();(()=>{const e=(c,k)=>{var m=c.reduce((D,K)=>{var L;return Math.min(D,null!=(L=null==K?void 0:K.level)?L:Infinity)},Infinity);for(var v=0;4>v;++v){var p=c[(v+
3)%4],w=c[v];if(p&&p.level<a.level&&p===w){c=p;var z=a.getNeighborEdgeStartVertexIndex(v,c);m=1===(v&1);var A=(z+(0===k||1===k&&!m||3===k&&m?1:0))/2**(a.level-c.level);z=m?0===k||1===k?c.extent[0]:c.extent[2]:G.lerp(c.extent[0],c.extent[2],A);m=m?G.lerp(c.extent[1],c.extent[3],A):0===k||3===k?c.extent[1]:c.extent[3];return H.sampleElevationOrZero(z,m,c.renderData.geometryState.samplerData)}}v=k=0;for(p=0;4>p;++p)if((w=c[p])&&w.level===m){const D=w.extent;w=H.sampleElevationOrZero(D[0===p||1===p?0:
2],D[0===p||3===p?1:3],null==(z=w.renderData)?void 0:null==(A=z.geometryState)?void 0:A.samplerData);v+=w;k++}return k?v/k:0},r=u.cornerNeighborData,h=(c,k)=>{const m=r[c],v=m.cornerTiles;for(let w=0;4>w;++w){var p=t.neighborCornerIndices[w];const z=k[w];p=null==z?void 0:z.findCorner(t.oppositeCorner(p),A=>(null==A?void 0:A.isLoaded)||A===a);v[w]=p}c=e(v,c);return m.elevation!==c?(m.elevation=c,!0):!1};for(let c=0;4>c;++c){const k=[l[c],f[(c+1)%4],a,f[c]],m=k.map((v,p)=>k[(p+4-c)%4]);h(c,m)&&(q=this._cornerElevationChanged=
!0)}})();(()=>{const e=u.edgeNeighbours;for(let m=0;4>m;++m){var r,h=f[m];h&&(t.internalAssert(null==h?void 0:h.isLoaded),t.internalAssert((null==h?void 0:h.lij[0])<=a.lij[0]));var c=e[m];const v=null==c?void 0:c.version;if(null==h||!h.isLoaded||h.lij[0]>a.lij[0])h=null;else{var k=h.renderData.geometryState;h={neighborSamplerData:k.samplerData,neighborEdgeOverlapResolution:k.neighborData.edgeResolutions[m+2],version:k.samplerDataVersion,neighborVerticesPerSide:k.numVerticesPerSide,neighborTile:h}}k=
null!=(r=null==h?void 0:h.version)?r:null;k=c&&h&&v!==k;const p=c&&h&&(null==c?void 0:c.neighborTile)!==(null==h?void 0:h.neighborTile);c=null!=c!==(null!=h)||k||p;this._edgeNeighborChanged||(this._edgeNeighborChanged=c);q||(q=c);if(c||!v)e[m]=h}})();return q};n.updateEdgeAfterResolutionChange=function(a){var b,d;const g=this._calculateEdgeResolution(a),f=this.geometryState.neighborData.edgeResolutions,l=f[a];t.internalAssert((null!=(b=null==(d=this.geometryState.neighborData.edgeNeighbours[a])?void 0:
d.neighborTile.level)?b:0)<=this.tile.level);g!==l&&(f[a]=g,this._edgeResolutionChanged=!0,y.deferTileNeighborUpdate?y.neighborTilesToUpdate.add(this.tile):this._updateGeometry(this.vao.context))};n._updateGeometry=function(a){this.intersectionData=null;const b=this.tile;var d=b.lij,g=y.updatedGeometryTiles.get(d)||0;y.updatedGeometryTiles.set(d,g+1);d=this.geometryInfo.vertexAttributes;d=!this._vao||!d||this._wireframeChanged||this._numVerticesPerSideChanged||this._samplerDataChanged||this._clippingAreaChanged||
this._edgeResolutionChanged;g=!d&&this._edgeNeighborChanged;const f=!g&&this._cornerElevationChanged;this._wireframeChanged=this._clippingAreaChanged=this._cornerElevationChanged=this._edgeNeighborChanged=this._edgeResolutionChanged=this._samplerDataChanged=this._numVerticesPerSideChanged=!1;d?(this._releaseGeometry(),this._createGeometry(a)):g?b.updateEdgeElevations():f?b.updateCornerElevations():console.warn("Update for no reason?")};n.releaseGeometry=function(){return this._releaseGeometry()};
n.ensureTexture=function(a,b){x.isSome(this._texture)&&this._texture.descriptor.width!==a&&this.releaseTexture();x.isNone(this._texture)&&(this._texture=b(),this.tile.setMemoryDirty());return this._texture};n.releaseTexture=function(){x.isSome(this._texture)&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())};n.updateGeometryStateAndPrepareForGeometryGeneration=function(a){const b=this._getElevationInfo();var d=b.samplerData?this.tile.getElevationBasedVerticesPerSide(b.maxTileLevel):
this.tile.getDefaultVerticesPerRowOnLevel();d=Math.max(d,5);let g=this.tile.clippingArea;if(!this.tile.intersectsClippingArea||this.tile.isWithinClippingArea)g=null;const f=this.geometryState;let l=!1;f.numVerticesPerSide!==d&&(this._numVerticesPerSideChanged=!0,f.numVerticesPerSide=d,f.samplerDataVersion++,l=!0);b.changed&&(this._samplerDataChanged=!0,f.samplerData=b.samplerData,f.samplerDataVersion++,l=!0);N.equals(f.clippingArea,g)||(this._clippingAreaChanged=!0,f.clippingArea=g,l=!0);f.wireframe!==
a&&(this._wireframeChanged=!0,f.wireframe=a,l=!0);this._geometryStateChangedSinceLastUpdate||(this._geometryStateChangedSinceLastUpdate=l);this._hasGeometry=!0;return l};n._createGeometry=function(a){this.tile.createGeometry();const b=this.geometryInfo.vertexAttributes,d=this.geometryInfo.indices,g=a.gl;this._vao=new U.VertexArrayObject(a,T.Default3D,{geometry:P.glLayout(b.layout)},{geometry:J.BufferObject.createVertex(a,g.STATIC_DRAW,b.buffer)},J.BufferObject.createIndex(a,g.STATIC_DRAW,d));this._hasGeometry=
!0};n._releaseGeometry=function(){this._hasGeometry=!1;if(!this._vao)return!1;this._vao.dispose();this._vao=null;I.releaseGeometry(this.geometryInfo);return!0};n.setTextureReference=function(a,b=F.ActivationTime.Immediate){x.isSome(a)&&a.texture!==this._texture&&this.releaseTexture();this._textureRef.push(a,b)};n._getElevationInfo=function(){const a=this.geometryState.samplerData,b=this.tile.layerInfo[E.LayerClass.ELEVATION],d=b.length;let g=Array(d),f=0;var l=0;let u=!1;for(let r=0;r<d;r++){var q=
b[r];if(x.isSome(q.upsampleInfo)){q=q.upsampleInfo.tile;var e=q.layerInfo[E.LayerClass.ELEVATION][r].data;e=e&&e.samplerData;a&&a[f]===e||(u=!0);g[f++]=e;l=Math.max(l,q.lij[0])}else q.data&&(e=this.tile.surface.layerViewByIndex(r,E.LayerClass.ELEVATION),S.fallsWithinLayer(this.tile,e.layer,!1)&&(l=q.data,a&&a[f]===l.samplerData||(u=!0),g[f++]=l.samplerData,l=this.tile.level))}x.isSome(a)&&a.length!==f&&(u=!0);0<f?g.length=f:g=null;return{changed:u,samplerData:g,maxTileLevel:l}};n.checkGeometryWaterproofness=
function(){};M._createClass(y,[{key:"tile",get:function(){return this._tile}},{key:"hasGeometry",get:function(){return this._hasGeometry}},{key:"vao",get:function(){return this._vao}},{key:"textureReference",get:function(){return this._textureRef.current}},{key:"nextTextureReference",get:function(){return this._textureRef.next}},{key:"textureFadeFactor",get:function(){return this._textureRef.fadeFactor}},{key:"textureIsFading",get:function(){return this._textureRef.isFading}},{key:"estimatedGeometryMemoryUsage",
get:function(){const a=x.mapOr(this.intersectionData,0,b=>b.estimatedMemoryUsage);return this.geometryInfo.indices.byteLength+this.geometryInfo.vertexAttributes.byteLength+a}},{key:"textureDescriptor",get:function(){return x.isSome(this._texture)?this._texture.descriptor:null}},{key:"test",get:function(){return{hasTexture:null!=this._texture}}}]);return y}();B.updatedGeometryTiles=new Map;B.deferTileNeighborUpdate=!1;B.neighborTilesToUpdate=new Set;Object.defineProperty(C,"ActivationTime",{enumerable:!0,
get:()=>F.ActivationTime});C.PatchRenderData=B;C.isElevationSampleIn=function(y,n,a){if(x.isSome(a))for(const d of a)if(d){a=d.x0;var b=d.width;const g=a+(b-1)/d.dx,f=d.y1;b=f-(b-1)/d.dy;if(y>=a-t.eps&&y<=g+t.eps&&b-t.eps<=n&&n<=f+t.eps)return!0}return!1};Object.defineProperties(C,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});