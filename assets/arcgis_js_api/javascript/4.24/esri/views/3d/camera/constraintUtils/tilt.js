// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.24/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/compilerUtils ../../../../core/mathUtils ../../../../core/maybe ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/projectionEllipsoid ../../../../chunks/sphere ./common ../../state/utils/viewUtils".split(" "),function(u,A,l,I,J,K,k,B,C,v,g,q){function D(c,a,b=g.defaultApplyOptions,d=!0){r.eyeCenterDistance=0;r.requiresTwoSteps=!1;const f=w(c,a,b,void 0,r);if(0===f)return!1;J.fromRotation(t,-f,
a.viewRight);switch(b.tiltMode){case g.TiltMode.LOOK_AROUND:k.transformMat4(m,a.viewForward,t);k.scale(m,m,r.eyeCenterDistance);a.center=k.add(n,a.eye,m);break;case g.TiltMode.TUMBLE:k.subtract(m,a.center,a.eye);k.transformMat4(m,m,t);a.eye=k.subtract(n,a.center,m);break;default:A.neverReached(b.tiltMode)}a.up=k.transformMat4(n,a.up,t);return r.requiresTwoSteps&&d?D(c,a,b,!1):!0}function w(c,a,b=g.defaultApplyOptions,d=g.defaultApplyOptions,f){if(!c.state.constraints.tilt)return 0;var e=c.state.constraints.tilt(a.distance,
L);if(b.interactionType!==g.InteractionType.NONE){var {interactionStartCamera:p,interactionFactor:E}=b,{min:M,max:N}=e,h=w(c,p,g.defaultApplyOptions,b),F=0===h?0:q.viewAngle(c.renderCoordsHelper,p.center,p.eye);e.min=M;e.max=N;b.interactionType===g.InteractionType.TUMBLE?(g.hasConstraintType(b.selection,g.ConstraintTypes.ALTITUDE)&&G(c,p,e),g.adjustRangeForInteraction(h,F,!0,E,H,e)):g.adjustRangeForInteraction(h,F,!1,E,H,e)}d.interactionType===g.InteractionType.TUMBLE&&g.hasConstraintType(d.selection,
g.ConstraintTypes.ALTITUDE)&&G(c,d.interactionStartCamera,e);if(b.tiltMode===g.TiltMode.LOOK_AROUND||d.tiltMode===g.TiltMode.LOOK_AROUND){a:switch(f&&(f.requiresTwoSteps=!1),c.viewingMode){case "global":b=O;h=c.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude;d=h+C.getReferenceEllipsoid(c.spatialReference).radius;h=c.renderCoordsHelper.intersectManifold(a.ray,h,n);b.eyeCenterDistance=a.distance;b.centerIsOnSurface=!1;I.isSome(h)?(b.eyeCenterDistance=k.distance(a.eye,h),b.tiltAtCenter=
q.viewAngle(c.renderCoordsHelper,h,a.eye),b.centerIsOnSurface=!0):c.state.isLocal?b.tiltAtCenter=q.viewAngle(c.renderCoordsHelper,a.center,a.eye):(v.closestPointOnSilhouette(v.fromRadius(v.tmpSphere,d),a.ray,n),b.eyeCenterDistance=k.distance(a.eye,n),b.tiltAtCenter=l.acosClamped(-k.dot(a.viewForward,k.normalize(n,n))));b.radius=d;b.eyeRadius=k.length(a.eye);b.constraints=c.state.constraints;a=l.clamp(b.tiltAtCenter,e.min,e.max);if(1E-9<Math.abs(b.tiltAtCenter-a)){if(b.centerIsOnSurface){{const {constraints:x,
eyeCenterDistance:P,tiltAtCenter:y}=b;a=y;c=x.clampTilt(P,y);e=z(b,c);if(x.clampTilt(e,y)!==c)for(e=0;10>e&&1E-9<Math.abs(c-a);)d=(a+c)/2,h=z(b,d),h=x.clampTilt(h,d),1E-9<Math.abs(h-d)?a=d:c=d,e++;a=c}e=a;c=l.asinClamped(b.radius/b.eyeRadius*Math.sin(b.tiltAtCenter));e=l.asinClamped(b.radius/b.eyeRadius*Math.sin(e));c=b.eyeRadius>b.radius?c-e:e-c}else a=b.constraints.clampTilt(b.eyeCenterDistance,b.tiltAtCenter),f&&a<Math.PI/2&&(f.requiresTwoSteps=!0,a=Math.PI/2-1E-5),c=b.tiltAtCenter-Math.PI/2-(a-
Math.PI/2);f&&(f.eyeCenterDistance=z(b,a));f=c}else f=0;break a;case "local":d=q.viewAngle(c.renderCoordsHelper,a.center,a.eye);b=l.clamp(d,e.min,e.max);e=d-b;1E-9<Math.abs(e)?(f&&(d=c.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,c=c.renderCoordsHelper.getAltitude(a.eye)-d,b=Math.cos(b),f.eyeCenterDistance=1E-4<Math.abs(b)?c/b:a.distance),f=e):f=0;break a;default:A.neverReached(c.viewingMode),f=void 0}return f}f=q.viewAngle(c.renderCoordsHelper,a.center,a.eye);b=l.clamp(f,e.min,
e.max);f-=b;f=1E-9<Math.abs(f)?f:0;return f}function z(c,a){if(!c.centerIsOnSurface)return c.eyeCenterDistance;a=Math.PI-l.clamp(a,0,Math.PI);const b=l.asinClamped(c.radius/c.eyeRadius*Math.sin(a)),d=Math.sin(Math.PI-a-b)/Math.sin(a);return c.eyeRadius<c.radius&&1<d?Math.sin(Math.PI-a-(Math.PI-b))/Math.sin(a)*c.eyeRadius:d*c.eyeRadius}function G(c,a,b){if(!c.state.isLocal){var d=c.state.constraints;if(d.altitude){var f=k.squaredLength(a.center),e=Math.sqrt(f);a=a.distance;var p=C.getReferenceEllipsoid(c.spatialReference).radius;
c=d.altitude.min+p;d=d.altitude.max+p;c=(c*c-a*a-f)/(-2*e*a);b.min=Math.max(b.min,Math.min(Math.PI-l.acosClamped((d*d-a*a-f)/(-2*e*a)),b.max));b.max=Math.min(b.max,Math.PI-l.acosClamped(c))}}}const m=B.create(),t=K.create(),n=B.create(),H=l.deg2rad(5),L={min:0,max:0},O={constraints:null,radius:0,eyeRadius:0,centerIsOnSurface:!0,eyeCenterDistance:0,tiltAtCenter:0},r={eyeCenterDistance:0,requiresTwoSteps:!1};u.applyTiltConstraint=D;u.getTiltConstraintError=w;Object.defineProperties(u,{__esModule:{value:!0},
[Symbol.toStringTag]:{value:"Module"}})});