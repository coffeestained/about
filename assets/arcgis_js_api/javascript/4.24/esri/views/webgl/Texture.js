// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.24/esri/copyright.txt for details.
//>>built
define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/has ../../core/mathUtils ../../core/maybe ./checkWebGLError ./context-util ./enums ./capabilities/isWebGL2Context".split(" "),function(F,I,C,G,v,y,z,f,A){function B(g){return v.isSome(g)&&"type"in g&&"compressed"===g.type}function D(g){var l;if(l=v.isSome(g)&&!B(g))l=!(v.isSome(g)&&"byteLength"in g);return l}function w(g){return g===f.TextureType.TEXTURE_3D||g===f.TextureType.TEXTURE_2D_ARRAY}function H(g,l,a,b=1){l=Math.max(l,a);g===
f.TextureType.TEXTURE_3D&&(l=Math.max(l,b));return Math.round(Math.log(l)/Math.LN2)+1}C=function(){function g(a,b,c=null){this._context=a;this.type="texture";this._glName=null;this._descriptor=void 0;this._wasImmutablyAllocated=this._wrapModeDirty=this._samplingModeDirty=!1;a.instanceCounter.increment(f.ResourceType.Texture,this);this._descriptor={target:f.TextureType.TEXTURE_2D,samplingMode:f.TextureSamplingMode.LINEAR,wrapMode:f.TextureWrapMode.REPEAT,flipped:!1,hasMipmap:!1,isOpaque:!1,unpackAlignment:4,
preMultiplyAlpha:!1,isImmutable:!1,...b};if(a.type!==z.ContextType.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),w(this._descriptor.target)))throw Error("3D and array textures are not supported in WebGL1");this._descriptor.target===f.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(c):this.setData(c)}var l=g.prototype;l.dispose=function(){this._context.gl&&this._glName&&(this._context.unbindTexture(this),this._context.gl.deleteTexture(this._glName),this._glName=null,this._context.instanceCounter.decrement(f.ResourceType.Texture,
this))};l.release=function(){this.dispose()};l.resize=function(a,b){const c=this._descriptor;if(c.width!==a||c.height!==b){if(this._wasImmutablyAllocated)throw Error("Immutable textures can't be resized!");c.width=a;c.height=b;this._descriptor.target===f.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}};l._setDataCubeMap=function(a=null){for(let b=f.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X;b<=f.TextureType.TEXTURE_CUBE_MAP_NEGATIVE_Z;b++)this._setData(a,b)};l.setData=function(a){this._setData(a)};
l._setData=function(a,b){var c;if(this._context&&this._context.gl){var e=this._context.gl;this._glName||(this._glName=e.createTexture());void 0===a&&(a=null);var d=this._descriptor;null!=(c=b)?c:b=d.target;c=w(b);if(null===a&&(d.width=d.width||4,d.height=d.height||4,c)){var n;d.depth=null!=(n=d.depth)?n:1}n=this._context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES);g._validateTexture(this._context,d);this._configurePixelStorage();var h=d.pixelFormat,
k=d.internalFormat?d.internalFormat:this._deriveInternalFormat(h,d.dataType);if(D(a)){h=a.width;let m=a.height;a instanceof HTMLVideoElement&&(h=a.videoWidth,m=a.videoHeight);d.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(b,k,d.hasMipmap,h,m,1);this._texImage(b,0,k,h,m,1,a);y.checkWebGLError(e);d.hasMipmap&&this.generateMipmap();void 0===d.width&&(d.width=h);void 0===d.height&&(d.height=m);c&&void 0===d.depth&&(d.depth=1)}else{const {width:m,height:p,depth:t}=d;null!=m&&null!=p||console.error("Width and height must be specified!");
c&&null==t&&console.error("Depth must be specified!");d.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(b,k,d.hasMipmap,m,p,t);e.DEPTH24_STENCIL8&&k===e.DEPTH_STENCIL&&(k=e.DEPTH24_STENCIL8);if(B(a)){const u=a.levels;a=H(b,m,p,t);c=Math.min(a-1,u.length-1);A(e)?e.texParameteri(d.target,e.TEXTURE_MAX_LEVEL,c):d.hasMipmap=d.hasMipmap&&a===u.length;const q=k;if(!(q in f.CompressedTextureFormat))throw Error("Attempting to use compressed data with an umcompressed format!");this._forEachMipmapLevel((r,
x,E,J)=>{this._compressedTexImage(b,r,q,x,E,J,u[Math.min(r,u.length-1)])},c)}else v.isSome(a)?(this._texImage(b,0,k,m,p,t,a),y.checkWebGLError(e),d.hasMipmap&&this.generateMipmap()):this._forEachMipmapLevel((u,q,r,x)=>{this._texImage(b,u,k,q,r,x,null);y.checkWebGLError(e)})}g._applySamplingMode(e,this._descriptor);g._applyWrapMode(e,this._descriptor);g._applyAnisotropicFilteringParameters(this._context,this._descriptor);y.checkWebGLError(e);this._context.bindTexture(n,g.TEXTURE_UNIT_FOR_UPDATES)}};
l.updateData=function(a,b,c,e,d,n){n||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");const h=this._context.gl,k=this._descriptor,{pixelFormat:m,internalFormat:p,dataType:t,isImmutable:u,target:q}=k;if(u&&!this._wasImmutablyAllocated)throw Error("Cannot update immutable texture before allocation!");const r=this._context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);(0>b||0>c||e>k.width||d>k.height||b+e>k.width||c+d>k.height)&&
console.error("An attempt to update out of bounds of the texture!");this._configurePixelStorage();D(n)?h.texSubImage2D(q,a,b,c,m,t,n):B(n)?h.compressedTexSubImage2D(q,a,b,c,e,d,p,n.levels[a]):h.texSubImage2D(q,a,b,c,e,d,m,t,n);this._context.bindTexture(r,g.TEXTURE_UNIT_FOR_UPDATES)};l.updateData3D=function(a,b,c,e,d,n,h,k){k||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");const m=this._context.gl;if(!A(m))throw Error("3D textures are not supported in WebGL1");
const p=this._descriptor,{pixelFormat:t,dataType:u,isImmutable:q,target:r,internalFormat:x}=p;if(q&&!this._wasImmutablyAllocated)throw Error("Cannot update immutable texture before allocation!");w(r)||console.warn("Attempting to set 3D texture data on a non-3D texture");const E=this._context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES);(0>b||0>c||0>e||d>p.width||n>p.height||h>p.depth||b+d>p.width||c+n>p.height||e+h>p.depth)&&console.error("An attempt to update out of bounds of the texture!");
this._configurePixelStorage();B(k)?(k=k.levels[a],m.compressedTexSubImage3D(r,a,b,c,e,d,n,h,x,k)):m.texSubImage3D(r,a,b,c,e,d,n,h,t,u,k);this._context.bindTexture(E,g.TEXTURE_UNIT_FOR_UPDATES)};l.generateMipmap=function(){const a=this._descriptor;if(!a.hasMipmap){if(this._wasImmutablyAllocated)throw Error("Cannot add mipmaps to immutable texture after allocation");this._samplingModeDirty=a.hasMipmap=!0;g._validateTexture(this._context,a)}a.samplingMode===f.TextureSamplingMode.LINEAR?(this._samplingModeDirty=
!0,a.samplingMode=f.TextureSamplingMode.LINEAR_MIPMAP_NEAREST):a.samplingMode===f.TextureSamplingMode.NEAREST&&(this._samplingModeDirty=!0,a.samplingMode=f.TextureSamplingMode.NEAREST_MIPMAP_NEAREST);const b=this._context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES);this._context.gl.generateMipmap(a.target);this._context.bindTexture(b,g.TEXTURE_UNIT_FOR_UPDATES)};l.setSamplingMode=function(a){a!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=
a,this._samplingModeDirty=!0)};l.setWrapMode=function(a){a!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=a,g._validateTexture(this._context,this._descriptor),this._wrapModeDirty=!0)};l.applyChanges=function(){const a=this._context.gl,b=this._descriptor;this._samplingModeDirty&&(g._applySamplingMode(a,b),this._samplingModeDirty=!1);this._wrapModeDirty&&(g._applyWrapMode(a,b),this._wrapModeDirty=!1)};l._deriveInternalFormat=function(a,b){if(this._context.type===z.ContextType.WEBGL1)return a;
switch(b){case f.PixelType.FLOAT:switch(a){case f.PixelFormat.RGBA:return f.SizedPixelFormat.RGBA32F;case f.PixelFormat.RGB:return f.SizedPixelFormat.RGB32F;default:throw Error("Unable to derive format");}case f.PixelType.UNSIGNED_BYTE:switch(a){case f.PixelFormat.RGBA:return f.SizedPixelFormat.RGBA8;case f.PixelFormat.RGB:return f.SizedPixelFormat.RGB8}default:return a}};l._configurePixelStorage=function(){const a=this._context.gl,{unpackAlignment:b,flipped:c,preMultiplyAlpha:e}=this._descriptor;
a.pixelStorei(a.UNPACK_ALIGNMENT,b);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,c?1:0);a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e?1:0)};l._texStorage=function(a,b,c,e,d,n){const h=this._context.gl;if(!A(h))throw Error("Immutable textures are not supported in WebGL1");if(!(b in f.SizedPixelFormat))throw Error("Immutable textures must have a sized internal format");this._descriptor.isImmutable&&(c=c?H(a,e,d,n):1,w(a)?h.texStorage3D(a,c,b,e,d,n):h.texStorage2D(a,c,b,e,d),this._wasImmutablyAllocated=!0)};
l._texImage=function(a,b,c,e,d,n,h){const k=this._context.gl;let m=null;const p=this._context.type===z.ContextType.WEBGL2,t=w(a),{isImmutable:u,pixelFormat:q,dataType:r}=this._descriptor;p&&(m=k);!p&&D(h)?k.texImage2D(a,0,c,q,r,h):u?v.isSome(h)&&(t?m.texSubImage3D(a,b,0,0,0,e,d,n,q,r,h):k.texSubImage2D(a,b,0,0,e,d,q,r,h)):(h=v.unwrap(h),t?m.texImage3D(a,b,c,e,d,n,0,q,r,h):k.texImage2D(a,b,c,e,d,0,q,r,h))};l._compressedTexImage=function(a,b,c,e,d,n,h){const k=this._context.gl;let m=null;const p=w(a),
t=this._descriptor.isImmutable;if(p){if(this._context.type!==z.ContextType.WEBGL2)throw Error("3D textures are not supported in WebGL1");m=k}t?v.isSome(h)&&(p?m.compressedTexSubImage3D(a,b,0,0,0,e,d,n,c,h):k.compressedTexSubImage2D(a,b,0,0,e,d,c,h)):p?m.compressedTexImage3D(a,b,c,e,d,n,0,h):k.compressedTexImage2D(a,b,c,e,d,0,h)};l._forEachMipmapLevel=function(a,b=Infinity){let {width:c,height:e,depth:d,hasMipmap:n,target:h}=this._descriptor;const k=h===f.TextureType.TEXTURE_3D;for(let m=0;;++m){a(m,
c,e,d);if(!n||1===c&&1===e&&(!k||1===d)||m>=b)break;c=Math.max(1,c>>1);e=Math.max(1,e>>1);k&&(d=Math.max(1,d>>1))}};g._validateTexture=function(a,b){(0>b.width||0>b.height||0>b.depth)&&console.error("Negative dimension parameters are not allowed!");a=A(a.gl);const c=G.isPowerOfTwo(b.width)&&G.isPowerOfTwo(b.height);a||!b.isImmutable&&!w(b.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!");a||c||("number"===typeof b.wrapMode?b.wrapMode!==f.TextureWrapMode.CLAMP_TO_EDGE&&
console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):(b.wrapMode.s!==f.TextureWrapMode.CLAMP_TO_EDGE||b.wrapMode.t!==f.TextureWrapMode.CLAMP_TO_EDGE)&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),b.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))};g._applySamplingMode=function(a,b){let c=b.samplingMode,e=b.samplingMode;if(c===f.TextureSamplingMode.LINEAR_MIPMAP_NEAREST||c===f.TextureSamplingMode.LINEAR_MIPMAP_LINEAR)c=
f.TextureSamplingMode.LINEAR,b.hasMipmap||(e=f.TextureSamplingMode.LINEAR);else if(c===f.TextureSamplingMode.NEAREST_MIPMAP_NEAREST||c===f.TextureSamplingMode.NEAREST_MIPMAP_LINEAR)c=f.TextureSamplingMode.NEAREST,b.hasMipmap||(e=f.TextureSamplingMode.NEAREST);a.texParameteri(b.target,a.TEXTURE_MAG_FILTER,c);a.texParameteri(b.target,a.TEXTURE_MIN_FILTER,e)};g._applyWrapMode=function(a,b){"number"===typeof b.wrapMode?(a.texParameteri(b.target,a.TEXTURE_WRAP_S,b.wrapMode),a.texParameteri(b.target,a.TEXTURE_WRAP_T,
b.wrapMode)):(a.texParameteri(b.target,a.TEXTURE_WRAP_S,b.wrapMode.s),a.texParameteri(b.target,a.TEXTURE_WRAP_T,b.wrapMode.t))};g._applyAnisotropicFilteringParameters=function(a,b){var c;const e=a.capabilities.textureFilterAnisotropic;e&&a.gl.texParameterf(b.target,e.TEXTURE_MAX_ANISOTROPY,null!=(c=b.maxAnisotropy)?c:1)};I._createClass(g,[{key:"glName",get:function(){return this._glName}},{key:"descriptor",get:function(){return this._descriptor}},{key:"isDirty",get:function(){return this._samplingModeDirty||
this._wrapModeDirty}}]);return g}();C.TEXTURE_UNIT_FOR_UPDATES=0;F.Texture=C;Object.defineProperties(F,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});