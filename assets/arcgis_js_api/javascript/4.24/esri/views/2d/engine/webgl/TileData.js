// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.24/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/maybe ./enums ./MemoryRequirements ./TileBufferData ./TileDisplayData ./Utils ./WGLDisplayRecord ./cpuMapped/DisplayRecordReader ./mesh/VertexBuffer ./mesh/VertexVector ./util/Writer".split(" "),function(y,B,C,t,w,z,u,A,D,E,F,G){const v=new t,n=new t;t=function(){function l(){this.tileBufferData=this.tileDisplayData=null}var q=l.prototype;q.reshuffle=function(){v.reset();var c=[[],[],[],[],[]];var a=this.tileDisplayData.displayObjects;for(var b of a)for(var e of b.displayRecords)c[e.geometryType].push(e);
for(var h of c)for(var f of h)f&&v.needMore(f.geometryType,f.meshData?f.meshData.vertexCount:f.vertexCount,f.meshData?f.meshData.indexData.length:f.indexCount);h=c.length;f=new w;for(a=0;a<h;++a){f.geometries[a].indexBuffer=new Uint32Array(Math.round(1.5*v.indicesFor(a)));b=[];for(var d in this.tileBufferData.geometries[a].vertexBuffer)b.push(this.tileBufferData.geometries[a].vertexBuffer[d].stride);b=l._computeVertexAlignment(b);e=Math.round(1.5*v.verticesFor(a));b=l._align(e,b);for(var g in this.tileBufferData.geometries[a].vertexBuffer)e=
this.tileBufferData.geometries[a].vertexBuffer[g].stride,f.geometries[a].vertexBuffer[g]={stride:e,data:u.allocateTypedArrayBuffer(b,e)}}n.reset();this.tileDisplayData.displayList.clear();for(d=0;d<h;++d){g=c[d];for(const k of g){if(k.meshData)k.writeMeshDataToBuffers(n.verticesFor(d),f.geometries[d].vertexBuffer,n.indicesFor(d),f.geometries[d].indexBuffer),k.meshData=null;else{g=this.tileBufferData.geometries[d].vertexBuffer;a=this.tileBufferData.geometries[d].indexBuffer;b=f.geometries[d].vertexBuffer;
e=f.geometries[d].indexBuffer;const p=n.verticesFor(d),m=n.indicesFor(d);u.copyMeshData(p,m,b,e,k,g,a);k.vertexFrom=p;k.indexFrom=m}n.needMore(d,k.vertexCount,k.indexCount)}}for(const k of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(k.displayRecords);this.tileBufferData=f};q.getStrides=function(){const c=[];for(let a=0;a<this.tileBufferData.geometries.length;++a){const b=this.tileBufferData.geometries[a];c[a]={};for(const e in b.vertexBuffer)c[a][e]=b.vertexBuffer[e].stride}return c};
q.clone=function(){const c=new l;c.tileBufferData=this.tileBufferData.clone();c.tileDisplayData=this.tileDisplayData.clone();return c};q._guessSize=function(){const {displayObjects:c}=this.tileDisplayData,a=Math.min(c.length,4);let b=0;for(let e=0;e<a;e++)b=Math.max(b,c[e].displayRecords.length);return 2*(12*c.length+c.length*b*40)};q.serialize=function(){const c=this.tileBufferData.serialize(),a=this.tileBufferData.getBuffers(),b=this.tileDisplayData.serialize(new G(Int32Array,this._guessSize())).buffer();
a.push(b);return{result:{displayData:b,bufferData:c},transferList:a}};l.fromVertexData=function(c,a){const b={},e=new Map;for(const h of a)e.set(h.id,h);u.forEachGeometryType(h=>{const f=c.data[h];if(B.isSome(f)){const g=D.DisplayRecordReader.from(f.records).getCursor();for(;g.next();){var d=g.id;const k=g.materialKey,p=g.indexFrom,m=g.indexCount,r=g.vertexFrom,x=g.vertexCount,H=e.get(d);d=new A(d,h,k);d.indexFrom=p;d.indexCount=m;d.vertexFrom=r;d.vertexCount=x;H.displayRecords.push(d)}b[h]=E.VertexBuffers.fromVertexData(f,
h)}else b[h]=(new F.VertexVectors(h,0,C.WGLSymbologyType.DEFAULT)).intoBuffers()});return l.fromMeshData({displayObjects:a,vertexBuffersMap:b})};l.fromMeshData=function(c){const a=new l,b=new z,e=new w;b.displayObjects=c.displayObjects;for(const h in c.vertexBuffersMap){const f=c.vertexBuffersMap[h];e.geometries[h].indexBuffer=f.indexBuffer;e.geometries[h].vertexBuffer=f.namedBuffers}a.tileDisplayData=b;a.tileBufferData=e;return a};l.bind=function(c,a){const b=new l;b.tileDisplayData=c;b.tileBufferData=
a;return b};l.create=function(c,a){const b=new l;b.tileDisplayData=new z;b.tileDisplayData.displayObjects=c;const e=[0,0,0,0,0],h=[0,0,0,0,0],f=[[],[],[],[],[]];for(var d of c)for(var g of d.displayRecords)f[g.geometryType].push(g),e[g.geometryType]+=g.meshData.vertexCount,h[g.geometryType]+=g.meshData.indexData.length;c=new w;a=[a.fill||{},a.line||{},a.icon||{},a.text||{},a.label||{}];for(d=0;5>d;d++){g=new Uint32Array(h[d]);{var k=a[d];var p=e[d];const m={};for(const r in k){const x={data:u.allocateTypedArrayBuffer(p,
k[r]),stride:k[r]};m[r]=x}k=m}A.writeAllMeshDataToBuffers(f[d],k,g);c.geometries[d]={indexBuffer:g,vertexBuffer:k}}b.tileBufferData=c;return b};l._align=function(c,a){const b=c%a;return 0===b?c:c+(a-b)};l._computeVertexAlignment=function(c){let a=!1,b=!1;for(const e of c)2===e%4?a=!0:0!==e%4&&(b=!0);return b?4:a?2:1};return l}();y.TileData=t;Object.defineProperties(y,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});