// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.24/esri/copyright.txt for details.
//>>built
define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../geometry/support/aaBoundingRect ../../../../geometry/support/centroid ../../../../geometry/support/jsonUtils ../../../../geometry/support/quantizationUtils ../../../../geometry/support/spatialReferenceUtils ../../../../layers/graphics/featureConversionUtils ../../../../layers/graphics/OptimizedGeometry".split(" "),function(z,A,m,B,n,p,C,q,h){function w(d){d.coords.length=0;d.lengths.length=0}const l=new h,u=new h;
h=function(){function d(){this.bounds=m.create();this.graphic=null}d.acquire=function(b=null,f,c,g,a){let e;0===d._pool.length?e=new d:(e=d._pool.pop(),this._set.delete(e));e.acquire(b,f,c,g,a);return e};d.release=function(b){b&&!this._set.has(b)&&(b.release(),this._pool.push(b),this._set.add(b))};d.getCentroidQuantized=function(b,f){if(n.isPolygon(b.geometry)){const c=b.symbol;if(A.isNone(c))return null;if(0<(null==c?void 0:c.layers.length)&&c.layers.some(g=>"text"===g.type||"marker"===g.type))return b=
B.polygonCentroid(b.geometry),null!==b?p.quantizePoint(f,{},{x:b[0],y:b[1]},!1,!1):null}return null};var r=d.prototype;r.acquire=function(b=null,f,c,g,a){b&&this.set(b,f,c,g,a)};r.release=function(){this.geometry=this.symbolResource=this.graphic=null};r.set=function(b,f,c,g,a){this.graphic=b;this.geometry=c;this.symbolResource=f;this.bounds=g;a&&(this.size=a)};r.getGeometryQuantized=function(b,f,c,g){var a=this.geometry;if(n.isPolygon(a)){if(a=a.rings,1===a.length&&2===a[0].length)return p.quantizeGeometry(b,
{paths:[[a[0][0],a[0][1]]]})}else{if(n.isPolyline(a))return w(l),w(u),q.convertFromPolyline(l,a),q.generalizeOptimizedGeometry(u,l,a.hasZ,a.hasM,"esriGeometryPolyline",b.scale[0]),q.quantizeOptimizedGeometry(l,u,a.hasZ,a.hasM,"esriGeometryPolyline",b),q.convertToPolyline(l,a.hasZ,a.hasM);if(n.isMultipoint(a)){const e=.5*g*Math.max(Math.abs(this.size[0])+this.size[2]-this.size[0],Math.abs(this.size[1])+this.size[3]-this.size[1]);c=C.getInfo(c);a=a.points;if(c){const [x,v]=c.valid,y=v-x;a=a.filter(k=>
{if(k[0]+e>v||k[0]-e<x){const t=[...k];t[0]=k[0]+e>v?t[0]-y:t[0]+y;return m.containsPointWithMargin(f,k,e)||m.containsPointWithMargin(f,t,e)}return m.containsPointWithMargin(f,k,e)})}return 0===a.length?{points:a}:p.quantizeGeometry(b,{points:a})}}return p.quantizeGeometry(b,this.geometry)};z._createClass(d,[{key:"symbol",get:function(){return this.symbolResource.symbol}}]);return d}();h._pool=[];h._set=new Set;return h});