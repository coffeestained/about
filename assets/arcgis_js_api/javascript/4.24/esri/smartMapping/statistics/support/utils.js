// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.24/esri/copyright.txt for details.
//>>built
define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../geometry ../../../core/Error ../../../core/maybe ../../../core/screenUtils ../../../geometry/SpatialReference ../../../geometry/support/quantizationUtils ../../../geometry/support/spatialReferenceUtils ../../../layers/support/fieldUtils ../../../renderers/support/heatmapUtils ../../../statistics/utils ../../../support/arcadeOnDemand ../../../geometry/Point".split(" "),function(p,G,U,H,y,I,J,K,C,D,E,L,M,N){function z(){z=G._asyncToGenerator(function*(a,
b){if(!b)return[];const c=a.field,d=a.valueExpression,g=a.normalizationType,r=a.normalizationField,q=a.normalizationTotal,e=[],h=a.viewInfoParams;let f=null,n=null;if(d){if(!v){const {arcadeUtils:k}=yield M.loadArcade();v=k}f=v.createFunction(d);n=h&&v.getViewInfo({viewingMode:h.viewingMode,scale:h.scale,spatialReference:new J(h.spatialReference)})}a=a.fieldInfos;const l=b[0]&&"declaredClass"in b[0]&&"esri.Graphic"===b[0].declaredClass||!a?null:{fields:a};b.forEach(k=>{var m=k.attributes;if(d){var t=
v.createExecContext(l?{...k,layer:l}:k,n);t=v.executeFunction(f,t)}else m&&(t=m[c]);g&&isFinite(t)&&(m=m&&parseFloat(m[r]),t=L.getNormalizedValue(t,g,m,q));e.push(t)});return e});return z.apply(this,arguments)}function u(a,b){return new H(a,b)}function F(a,b){a=y.isSome(a)?a:"";y.isSome(b)&&b&&(a=a?"("+a+") AND ("+b+")":b);return a}function O(a){const b=a.layer;return a.fields.filter(c=>!b.getField(c))}function P(a){const b=a.layer;return a.fields.filter(c=>{c=b.getFieldUsageInfo(c);return!c||!c.supportsStatistics})}
let v=null;p.calculateHeatmapStats=function(a,b=18,c,d,g,r){const q=new Float64Array(g*r);b=Math.round(I.pt2px(b));let e=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY;var f=0;let n=0,l=0,k=0;c=E.createValueFunction(d,c);for(const {geometry:t,attributes:Q}of a){const {x:A,y:B}=t;a=Math.max(0,A-b);f=Math.max(0,B-b);d=Math.min(r,B+b);const R=Math.min(g,A+b),S=+c(Q);for(let w=f;w<d;w++)for(let x=a;x<R;x++){f=w*g+x;const T=E.evaluateDensityKernel(x-A,w-B,b);var m=q[f];f=q[f]+=T*S;m=f-m;n+=m;l+=m*
m;f<e&&(e=f);f>h&&(h=f);k++}}return k?{mean:n/k,stdDev:Math.sqrt((l-n*n/k)/k),min:e,max:h,mid:(h-e)/2,count:k}:{mean:0,stddev:0,min:0,max:0,mid:0,count:0}};p.createError=u;p.getDataValues=function(a,b){return z.apply(this,arguments)};p.getRangeExpr=function(a,b,c){b=null!=b?a+" \x3e\x3d "+b:"";a=null!=c?a+" \x3c\x3d "+c:"";c="";return(c=b&&a?F(b,a):b||a)?"("+c+")":""};p.getSQLFilterForNormalization=function(a){const b=a.field,c=a.normalizationType;a=a.normalizationField;let d;if("field"===c)d="(NOT "+
a+" \x3d 0)";else if("log"===c||"natural-log"===c||"square-root"===c)d=`(${b} > 0)`;return d};p.getSumOfAttributesExpr=function(a,b,c){const d=[],g=[],r=[],q=[],e=[];a.forEach((n,l)=>{const k=n.field?"field":"expression",m=n.field||n.valueExpression;n.field?(e.push(m),g.push(`var ${k}${l} = Number($feature["${m}"]);`)):(d.push(`function getValueForExpr${l}() {\n  ${m} \n}`),g.push(`var ${k}${l} = Number(getValueForExpr${l}());`));c||r.push(`${k}${l} = IIf(${k}${l} < 0, 0, ${k}${l});`);q.push(`${k}${l}`)});
a="return sum;";const h=d.length?null:e.reduce((n,l)=>`${n} + ${l}`);let f=null;b||c?b?c||(a="return IIf(sum \x3e\x3d 0, sum, null);",h&&(f=`(( ${h} ) >= 0)`)):(a="return IIf(sum !\x3d 0, sum, null);",h&&(f=`(( ${h} ) <> 0)`)):(a="return IIf(sum \x3e 0, sum, null);",h&&(f=`(( ${h} ) > 0)`));return{valueExpression:[d.length?d.join("\n"):"",g.join("\n"),r.join("\n"),`var sum = ${q.join(" + ")};`,a].filter(Boolean).join("\n\n"),sqlExpression:h,sqlWhere:f}};p.mergeWhereClauses=F;p.quantizeFeatures=function(a,
b,c,d){const g=C.isWrappable(c)?C.getInfo(c):null,r=g?Math.round((g.valid[1]-g.valid[0])/b.scale[0]):null;return a.map(q=>{const e=new N(y.unwrap(q.geometry));K.quantizePoint(b,e,e,e.hasZ,e.hasM);if(g){var h=d[0];0>e.x?e.x+=r:e.x>h&&(e.x-=r)}q.geometry=e;return q})};p.verifyBasicFieldValidity=function(a,b,c){const d=O({layer:a,fields:b});if(d.length)return u(c,"Unknown fields: "+d.join(", ")+". You can only use fields defined in the layer schema");a=P({layer:a,fields:b});if(a.length)return u(c,"Unsupported fields: "+
a.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true")};p.verifyFieldType=function(a,b,c,d){let g=null;b?b.name!==a.objectIdField&&d.includes(b.type)||(g=u(c,"'field' should be one of these types: "+d.join(","))):g=u(c,"'field' is not defined in the layer schema");return g};p.verifyNumericField=function(a,b,c){let d;b?b.name!==a.objectIdField&&D.isNumericField(b)||(d=u(c,"'field' should be one of these numeric types: "+D.numericTypes.join(","))):
d=u(c,"'field' is not defined in the layer schema");return d};Object.defineProperties(p,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});