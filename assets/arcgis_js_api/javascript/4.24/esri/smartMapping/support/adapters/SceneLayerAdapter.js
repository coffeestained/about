// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.24/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Graphic ../../../core/arrayUtils ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../core/reactiveUtils ../../../core/accessorSupport/decorators/property ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../layers/support/fieldType ../../../layers/support/fieldUtils ../../../rest/support/FeatureSet ../../statistics/support/statsWorker ../../statistics/support/WorkerClient ../utils ./FeatureLayerAdapter ./LayerAdapter ./support/utils ../../../statistics/utils".split(" "),
function(q,A,B,C,r,x,u,G,H,w,P,I,J,D,E,v,K,L,M,N,t,O){w=function(F){function y(b){return F.call(this,b)||this}q._inheritsLoose(y,F);var l=y.prototype;l.destroy=function(){var b;this._featureLayerAdapter=null;null==(b=this.workerClient)?void 0:b.destroy()};l._hasCachedStatistics=function(b){return this.layer.hasCachedStatistics(b)};l._updateQuery=function(b,a=[],c=[]){if(!c.length)return b;const d=this.layer.objectIdField;b=b.clone();a=a.filter(e=>{e=this.layer.getField(e);return!c.includes(e.name)});
const f=a.some(e=>this.layer.getField(e).name===d);b.outFields=f?a:[...a,d];return b};l._fetchFeaturesFromMemory=function(){var b=q._asyncToGenerator(function*(a,c,d){if(!a)throw new r("scene-layer-adapter:insufficient-data","view is required to fetch the features from layerView");const f=yield a.whenLayerView(this.layer);var e=new AbortController;a=e.signal;const h=G.whenOnce(()=>!f.updating,a);yield u.timeout(h,5E3,e);e=yield t.getMissingFields(this,d,f);u.throwIfAborted(a);c=this._updateQuery(c,
d,e);c=yield f.queryFeatures(c,{signal:a});u.throwIfAborted(a);a=c.features;return e.length?f.whenGraphicAttributes(a,e):a});return function(a,c,d){return b.apply(this,arguments)}}();l._fetchFeaturesJSONFromMemory=function(){var b=q._asyncToGenerator(function*(a,c,d){return this._fetchFeaturesFromMemory(a,c,d).then(t.ensureFeaturesJSON)});return function(a,c,d){return b.apply(this,arguments)}}();l._fetchFeaturesForStats=function(b,a){return L.getFieldsList({field:b.field,normalizationField:b.normalizationField,
valueExpression:b.valueExpression}).then(c=>this.getSampleFeatures({sampleSize:-1,view:b.view,returnGeometry:b.returnGeometry,requiredFields:c,signal:b.signal},a))};l._processStatsFromMemoryParams=function(){var b=q._asyncToGenerator(function*(a){const c=a.features;if(null!=c&&c.length)return c.length&&"declaredClass"in c[0]&&"esri.Graphic"===c[0].declaredClass?{graphics:c}:{featuresJSON:c};const {view:d,field:f,normalizationField:e,valueExpression:h,signal:k}=a;a=yield this._fetchFeaturesForStats({field:f,
valueExpression:h,normalizationField:e,view:d,signal:k});if(null==a||!a.length)throw new r("scene-layer-adapter:insufficient-data","No features are available to calculate statistics");return{graphics:a}});return function(a){return b.apply(this,arguments)}}();l._generateFeatureSetForCachedHistogram=function(b,a=b.minimum,c=b.maximum,d){const f=[];for(var e=0;e<d;e++)f[e]=0;e=b.counts.length;const h=b.minimum,k=b.maximum;for(let m=0;m<e;m++){var g=(m+.5)/e;g=((1-g)*h+g*k-a)/(c-a)*d;0<=g&&g<=d&&(f[g===
d?d-1:Math.floor(g)]+=b.counts[m])}const n=[];f.forEach((m,p)=>{const z=new B({attributes:{}});z.attributes.EXPR_1=p+1;z.attributes.countOFExpr=m;n.push(z)});b=new E;b.features=n;return b};l._getCachedStatistics=function(b,a){const c=this.layer;return b.valueExpression||b.sqlExpression||b.sqlWhere||b.minValue||b.maxValue?Promise.reject(new r("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified")):
c.queryCachedStatistics(a&&a.name,{signal:b.signal}).then(d=>{d=d.stats;const {min:f,max:e,totalValuesCount:h}=d;let {avg:k,stddev:g,sum:n,variance:m,count:p}=d;if(0!==f||0!==e)k=0===k?null:k,n=0===n?null:n,g=0===g?null:g,m=0===m?null:m,p=0===p?null:p;null==p&&(null!=n&&null!=k?p=Math.round(n/k):null!=h&&(p=h));return{avg:k,count:p,max:e,min:f,stddev:g,sum:n,variance:m}})};l._getNormalizationTotal=function(){var b=q._asyncToGenerator(function*(a,c,d){a=(c?yield this.workerClient.summaryStatistics({field:a},
c):yield v.summaryStatistics({attribute:{field:a},features:d})).sum;if(null==a)throw new r("scene-layer-adapter:invalid","invalid normalizationTotal");return a});return function(a,c,d){return b.apply(this,arguments)}}();l._getSummaryStatisticsFromMemory=function(){var b=q._asyncToGenerator(function*(a,c){const {view:d,field:f,normalizationField:e,valueExpression:h}=a,{featuresJSON:k,graphics:g}=yield this._processStatsFromMemoryParams(a),n={field:f,valueExpression:h,normalizationType:a.normalizationType,
normalizationField:e,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue};a.valueExpression&&d&&k&&(n.fieldType=null!=c&&c.type?J.kebabDict.toJSON(c.type):null,n.viewInfoParams=t.getViewInfoParams(d));"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(n.normalizationTotal=yield this._getNormalizationTotal(f,k,g));return k?this.workerClient.summaryStatistics(n,k):v.summaryStatistics({attribute:n,features:g})});return function(a,c){return b.apply(this,
arguments)}}();l._getCachedStatisticsForUniqueValues=function(b,a){const c=this.layer,d=a&&a.name,f=a&&this.getFieldDomain(b.field);return b.valueExpression||b.sqlExpression||b.sqlWhere?Promise.reject(new r("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified")):c.queryCachedStatistics(d,{signal:b.signal}).then(e=>{var h=e.stats;if(!h.mostFrequentValues)throw Error();e=e.labels&&e.labels.labels;const k=
{},g=[],n="countOF"+d;h.mostFrequentValues.forEach(m=>{const p=new B({attributes:{}});p.attributes[d]=a&&a.name!==c.objectIdField&&(D.isNumericField(a)||D.isDateField(a))?Number(m.value):m.value;p.attributes[n]=m.count;g.push(p)});e&&e.forEach(m=>{k[m.value]=m.label});h=new E;h.features=g;return t.getUniqueValuesFromFeatureSet(h,this,b.field,b.view,k,b.signal)}).then(e=>O.createUVResult(e,f,b.returnAllCodedValues))};l._getUniqueValuesFromMemory=function(){var b=q._asyncToGenerator(function*(a,c){c=
c&&this.getFieldDomain(a.field);const {view:d,field:f,valueExpression:e,returnAllCodedValues:h}=a;c={field:f,valueExpression:e,domain:c,returnAllCodedValues:h};const {featuresJSON:k,graphics:g}=yield this._processStatsFromMemoryParams(a);a.valueExpression&&d&&k&&(c.viewInfoParams=t.getViewInfoParams(d));return k?this.workerClient.uniqueValues(c,k):v.uniqueValues({attribute:c,features:g})});return function(a,c){return b.apply(this,arguments)}}();l._getCachedStatisticsForHistogram=function(b,a){const c=
this.layer;return b.valueExpression||b.sqlExpression||b.sqlWhere||b.normalizationType?Promise.reject(new r("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified")):c.queryCachedStatistics(a&&a.name,{signal:b.signal}).then(d=>{var f=d.stats;const {minValue:e,maxValue:h}=b;d=null!=e?e:f.min;const k=null!=h?h:f.max,g=b.numBins||10;f=this._generateFeatureSetForCachedHistogram(f.histogram,
d,k,g);return t.getHistogramFromFeatureSet(f,d,k,g)})};l._getClassBreaksFromMemory=function(){var b=q._asyncToGenerator(function*(a){const {view:c,field:d,normalizationField:f,valueExpression:e}=a,{featuresJSON:h,graphics:k}=yield this._processStatsFromMemoryParams(a),g={field:d,valueExpression:e,normalizationType:a.normalizationType,normalizationField:f,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,
numClasses:a.numClasses};a.valueExpression&&c&&h&&(g.viewInfoParams=t.getViewInfoParams(c));"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(g.normalizationTotal=yield this._getNormalizationTotal(d,h,k));return h?this.workerClient.classBreaks(g,h):v.classBreaks({attribute:g,features:k})});return function(a){return b.apply(this,arguments)}}();l._getHistogramFromMemory=function(){var b=q._asyncToGenerator(function*(a){const {view:c,field:d}=a,{featuresJSON:f,graphics:e}=yield this._processStatsFromMemoryParams(a),
h={field:d,valueExpression:a.valueExpression,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numBins:a.numBins};a.valueExpression&&c&&f&&(h.viewInfoParams=t.getViewInfoParams(c));"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(h.normalizationTotal=yield this._getNormalizationTotal(d,
f,e));return f?this.workerClient.histogram(h,f):v.histogram({attribute:h,features:e})});return function(a){return b.apply(this,arguments)}}();l.getField=function(b=""){return this.layer.getField(b)};l.getFieldUsageInfo=function(b){b=this.getField(b);if(!b)return null;b=this.layer.getFieldUsageInfo(b.name);return{supportsLabelingInfo:b.supportsLabelingInfo,supportsPopupTemplate:b.supportsPopupTemplate,supportsRenderer:b.supportsRenderer,supportsLayerQuery:b.supportsLayerQuery,supportsStatistics:!0}};
l.getFieldDomain=function(b,a){return this._featureLayerAdapter?this._featureLayerAdapter.getFieldDomain(b,a):null};l.summaryStatistics=function(b){const a=this.getField(b.field);return this._featureLayerAdapter?this._featureLayerAdapter.summaryStatistics(b):this._hasCachedStatistics(a&&a.name)?this._getCachedStatistics(b,a).catch(()=>{u.throwIfAborted(b.signal);return this._getSummaryStatisticsFromMemory(b,a)}):this._getSummaryStatisticsFromMemory(b,a)};l.uniqueValues=function(b){const a=this.getField(b.field);
return this._featureLayerAdapter?this._featureLayerAdapter.uniqueValues(b):this._hasCachedStatistics(a&&a.name)?this._getCachedStatisticsForUniqueValues(b,a).catch(()=>{u.throwIfAborted(b.signal);return this._getUniqueValuesFromMemory(b,a)}):this._getUniqueValuesFromMemory(b,a)};l.histogram=function(b){const a=this.getField(b.field);return this._featureLayerAdapter?this._featureLayerAdapter.histogram(b):this._hasCachedStatistics(a&&a.name)?this._getCachedStatisticsForHistogram(b,a).catch(()=>{u.throwIfAborted(b.signal);
return this._getHistogramFromMemory(b)}):this._getHistogramFromMemory(b)};l.classBreaks=function(b){const a=this.getField(b.field);return this._featureLayerAdapter?this._featureLayerAdapter.classBreaks(b):this._hasCachedStatistics(a&&a.name)?Promise.reject(new r("scene-layer-adapter:not-supported","Cached stats not supported")):this._getClassBreaksFromMemory(b)};l.queryFeatureCount=function(b){return this._featureLayerAdapter?this._featureLayerAdapter.queryFeatureCount(b):Promise.reject(new r("scene-layer-adapter:not-supported",
"SceneLayer without associated FeatureLayer does not support count query"))};l.generateRenderer=function(b,a){return this._featureLayerAdapter?this._featureLayerAdapter.generateRenderer(b,a):Promise.reject(new r("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support generateRenderer operation"))};l.heatmapStatistics=function(b){return this._featureLayerAdapter?this._featureLayerAdapter.heatmapStatistics(b):Promise.reject(new r("scene-layer-adapter:not-supported",
"SceneLayer without associated FeatureLayer does not support heatmapStatistics operation"))};l.predominantCategories=function(){var b=q._asyncToGenerator(function*(a){if(this._featureLayerAdapter)return this._featureLayerAdapter.predominantCategories(a);throw new r("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support predominantCategories");});return function(a){return b.apply(this,arguments)}}();l.getSampleFeatures=function(){var b=q._asyncToGenerator(function*(a,
c){const {view:d,sampleSize:f,requiredFields:e,returnGeometry:h,signal:k}=a;var g="json"===c;const n=this.layer.createQuery();n.outFields=e;n.returnGeometry=!!h;n.where=null;n.num=f;let m=[];try{if(m=g?yield this._fetchFeaturesJSONFromMemory(d,n,e):yield this._fetchFeaturesFromMemory(d,n,e),m.length&&0<f&&f<=m.length)return C.pickRandom(m,f,1)}catch(p){u.throwIfAborted(k)}g=null;this._featureLayerAdapter&&(a={...a},delete a.view,g=yield this._featureLayerAdapter.getSampleFeatures(a,c));return g&&
g.length?g:C.pickRandom(m,m.length,1)});return function(a,c){return b.apply(this,arguments)}}();l.load=function(b){var a=this;const c=this.layer.load(b).then(function(){var d=q._asyncToGenerator(function*(f){a.workerClient=K.WorkerClient.getInstance();yield a.workerClient.open(x.unwrap(x.unwrap(b).signal));const e=f.associatedLayer;a.geometryType=f.geometryType;if(x.isSome(e))return a._featureLayerAdapter=new M({layer:e}),a._featureLayerAdapter.load(b).then(()=>{a.objectIdField=a._featureLayerAdapter.objectIdField;
a.supportsSQLExpression=a._featureLayerAdapter.supportsSQLExpression;a.minScale=a._featureLayerAdapter.minScale;a.maxScale=a._featureLayerAdapter.maxScale;a.fullExtent=a._featureLayerAdapter.fullExtent});a.objectIdField=f.objectIdField;a.supportsSQLExpression=!1;a.hasQueryEngine=!1;a.fullExtent=f.fullExtent});return function(f){return d.apply(this,arguments)}}());this.addResolvingPromise(c);return Promise.resolve(this)};return y}(N);A.__decorate([H.property({constructOnly:!0})],w.prototype,"layer",
void 0);return w=A.__decorate([I.subclass("esri.smartMapping.support.adapters.SceneLayerAdapter")],w)});