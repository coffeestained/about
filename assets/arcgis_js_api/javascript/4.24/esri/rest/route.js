// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.24/esri/copyright.txt for details.
//>>built
define("exports ../chunks/_rollupPluginBabelHelpers ../request ../core/maybe ../geometry/support/normalizeUtils ./networkService ./utils ./route/utils ./support/RouteSolveResult".split(" "),function(C,G,H,y,I,q,J,K,L){function w(f){return"esri.rest.support.FeatureSet"===(null==f?void 0:f.declaredClass)}function z(){z=G._asyncToGenerator(function*(f,d,k){var l=[],g=[],e={};const r={},x=J.parseUrl(f);({path:f}=x);w(d.stops)&&q.collectGeometries(d.stops.features,g,"stops.features",e);w(d.pointBarriers)&&
q.collectGeometries(d.pointBarriers.features,g,"pointBarriers.features",e);w(d.polylineBarriers)&&q.collectGeometries(d.polylineBarriers.features,g,"polylineBarriers.features",e);w(d.polygonBarriers)&&q.collectGeometries(d.polygonBarriers.features,g,"polygonBarriers.features",e);g=yield I.normalizeCentralMeridian(g);for(const n in e){const p=e[n];l.push(n);r[n]=g.slice(p[0],p[1])}if(q.isInputGeometryZAware(r,l)){e=null;try{e=yield q.fetchServiceDescription(f,d.apiKey,k)}catch{}e&&!e.hasZ&&q.dropZValuesOffInputGeometry(r,
l)}for(const n in r)r[n].forEach((p,t)=>{d.get(n)[t].geometry=p});k={...k,query:{...x.query,...K.routeParametersToQueryParameters(d),f:"json"}};l=f.endsWith("/solve")?f:`${f}/solve`;({data:k}=yield H(l,k));return M(k)});return z.apply(this,arguments)}function M(f){var d;const {barriers:k,directionLines:l,directionPoints:g,directions:e,messages:r,polygonBarriers:x,polylineBarriers:n,routes:p,stops:t,traversedEdges:A,traversedJunctions:B,traversedTurns:D}=f,E=a=>{var b=m.find(c=>c.routeName===a);if(y.isSome(b))return b;
b={routeId:m.length+1,routeName:a};m.push(b);return b},v=a=>{var b=m.find(c=>c.routeId===a);if(y.isSome(b))return b;b={routeId:a,routeName:null};m.push(b);return b},m=[];null==p?void 0:p.features.forEach((a,b)=>{a.geometry.spatialReference=p.spatialReference;m.push({routeId:b+1,routeName:a.attributes.Name,route:a})});null==e?void 0:e.forEach(a=>{const {routeName:b}=a;E(b).directions=a});const F=null!=(d=null==t?void 0:t.features.every(a=>y.isNone(a.attributes.RouteName)))&&d&&0<m.length?m[0].routeName:
null;null==t?void 0:t.features.forEach(a=>{var b;if(a.geometry){var c,h;null!=(h=(c=a.geometry).spatialReference)?h:c.spatialReference=t.spatialReference}c=E(null!=F?F:a.attributes.RouteName);null!=(b=c.stops)?b:c.stops=[];c.stops.push(a)});null==l?void 0:l.features.forEach(a=>{var b;const c=v(a.attributes.RouteID),{geometryType:h,spatialReference:u}=l;null!=(b=c.directionLines)?b:c.directionLines={features:[],geometryType:h,spatialReference:u};c.directionLines.features.push(a)});null==g?void 0:g.features.forEach(a=>
{var b;const c=v(a.attributes.RouteID),{geometryType:h,spatialReference:u}=g;null!=(b=c.directionPoints)?b:c.directionPoints={features:[],geometryType:h,spatialReference:u};c.directionPoints.features.push(a)});null==A?void 0:A.features.forEach(a=>{var b;const c=v(a.attributes.RouteID),{geometryType:h,spatialReference:u}=A;null!=(b=c.traversedEdges)?b:c.traversedEdges={features:[],geometryType:h,spatialReference:u};c.traversedEdges.features.push(a)});null==B?void 0:B.features.forEach(a=>{var b;const c=
v(a.attributes.RouteID),{geometryType:h,spatialReference:u}=B;null!=(b=c.traversedJunctions)?b:c.traversedJunctions={features:[],geometryType:h,spatialReference:u};c.traversedJunctions.features.push(a)});null==D?void 0:D.features.forEach(a=>{var b;const c=v(a.attributes.RouteID);null!=(b=c.traversedTurns)?b:c.traversedTurns={features:[]};c.traversedTurns.features.push(a)});return L.fromJSON({routeResults:m,barriers:k,polygonBarriers:x,polylineBarriers:n,messages:r})}C.solve=function(f,d,k){return z.apply(this,
arguments)};Object.defineProperties(C,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});